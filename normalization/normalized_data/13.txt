python
advanc
:
finit
state
machin
in
python
python
advanc
cours
topic
advanc
topic
introduct
into
the
sy
modulepython
and
the
shellfork
and
fork
in
pythonintroduct
into
threadspip
,
pipe
and
``
99
bottl
of
beer
''
python
network
scannergraph
theori
and
graph
in
pythongraph
:
pygraphgraphsa
python
class
for
polynomi
functionscurri
in
pythonfinit
state
machin
in
pythontur
machin
in
pythonlevenshtein
distanceexampl
for
recurs
program
:
tower
of
hanoimastermind
/
bull
and
cowscreat
dynam
websit
with
wsgidynam
websit
with
mod_pythondynam
websit
with
pylonspython
,
sql
,
mysql
and
sqlitepython
score
wisdom
``
the
infinit
is
in
the
finit
of
everi
instant
''
(
zen
proverb
)
***
``
No
finit
point
ha
mean
without
an
infinit
refer
point
''
(
jean-paul
sartr
)
***
``
ask
what
time
is
,
it
is
noth
els
but
someth
of
etern
durat
becom
finit
,
measur
and
transitori
.
''
(
william
law
)
``
the
machin
doe
not
isol
us
from
the
great
problem
of
natur
but
plung
us
more
deepli
into
them
''
(
antoin
de
saint-exuperi
)
***
``
A
tool
is
but
the
extens
of
a
man
's
hand
,
and
a
machin
is
but
a
complex
tool
.
and
he
that
invent
a
machin
augment
the
power
of
a
man
and
the
well-b
of
mankind
.
''
(
henri
ward
beecher
)
thi
websit
is
support
by
:
python
train
cours
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
endlich
automaten
in
python
python
train
cours
If
you
want
to
learn
python
fast
and
effici
,
the
right
step
will
be
a
python
train
cours
at
bodenseo
.
there
are
also
special
seminar
for
advanc
student
like
the
python
&
xml
train
cours
.
If
you
want
to
acquir
special
knowledg
in
text
process
and
text
classif
,
then
``
python
text
process
cours
''
will
be
the
right
one
for
you
.
all
the
python
seminar
are
avail
in
german
as
well
:
python-kurs
''
python
cours
at
bodenseo
.
you
can
book
bernd
klein
for
on-sit
python
cours
as
well
.
text
classif
though
the
autom
classif
(
categor
)
of
text
ha
been
flourish
in
the
last
decad
,
it
ha
a
histori
,
which
date
back
to
about
1960
.
the
incred
increas
in
onlin
document
,
which
ha
been
mostli
due
to
the
expand
internet
,
ha
renew
the
interst
in
autom
document
classif
and
data
mine
.
while
text
classif
in
the
begin
wa
base
mainli
on
heurist
method
,
i.e
.
appli
a
set
of
rule
base
on
expert
knowledg
,
nowaday
the
focu
ha
turn
to
fulli
automat
learn
and
even
cluster
method
.
data
protect
declar
data
protect
declar
previou
chapter
:
curri
in
python
next
chapter
:
ture
machin
in
python
finit
state
machin
(
fsm
)
A
``
finit
state
machin
''
(
abbrevi
fsm
)
,
also
call
``
state
machin
''
or
``
finit
state
automaton
''
is
an
abstract
machin
which
consist
of
a
set
of
state
(
includ
the
initi
state
and
one
or
more
end
state
)
,
a
set
of
input
event
,
a
set
of
output
event
,
and
a
state
transit
function
.
A
transit
function
take
the
current
state
and
an
input
event
as
an
input
and
return
the
new
set
of
output
event
and
the
next
(
new
)
state
.
some
of
the
state
are
use
as
``
termin
state
''
.
the
oper
of
an
fsm
begin
with
a
special
state
,
call
the
start
state
,
proce
through
transit
depend
on
input
to
differ
state
and
normal
end
in
termin
or
end
state
.
A
state
which
mark
a
success
flow
of
oper
is
known
as
an
accept
state
.
mathemat
model
:
A
determinist
finit
state
machin
or
acceptor
determinist
finit
state
machin
is
a
quintupl
(
Σ
,
S
,
s0
,
δ
,
F
)
,
where
:
Σ
is
the
input
alphabet
(
a
finit
,
non-empti
set
of
symbol
)
.
S
is
a
finit
,
non-empti
set
of
state
.
s0
is
an
initi
state
,
an
element
of
S.
δ
is
the
state-transit
function
:
δ
:
S
x
Σ
→
S
(
in
a
nondeterminist
finit
state
machin
it
would
be
δ
:
S
x
Σ
→
℘
(
S
)
,
i.e.
,
δ
would
return
a
set
of
state
)
.
(
℘
(
S
)
is
the
power
set
of
S
)
F
is
the
set
of
final
state
,
a
(
possibl
empti
)
subset
of
S.
A
simpl
exampl
We
want
to
recogn
the
mean
of
veri
small
sentenc
with
an
extrem
limit
vocabulari
and
syntax
:
these
sentenc
should
start
with
``
python
is
''
follow
by
an
adject
or
the
word
``
not
''
follow
by
an
adject
.
e.g
.
``
python
is
great
''
→
posit
mean
``
python
is
stupid
''
→
neg
mean
``
python
is
not
ugli
''
→
posit
mean
A
finit
state
machin
in
python
To
implement
the
previou
exampl
,
we
program
first
a
gener
finit
state
machin
in
python
.
We
save
thi
class
as
statemachine.pi
:
class
statemachin
:
def
__init__
(
self
)
:
self.handl
=
{
}
self.startst
=
none
self.endst
=
[
]
def
add_stat
(
self
,
name
,
handler
,
end_state=0
)
:
name
=
name.upp
(
)
self.handl
[
name
]
=
handler
if
end_stat
:
self.endstates.append
(
name
)
def
set_start
(
self
,
name
)
:
self.startst
=
name.upp
(
)
def
run
(
self
,
cargo
)
:
tri
:
handler
=
self.handl
[
self.startst
]
except
:
rais
initializationerror
(
``
must
call
.set_start
(
)
befor
.run
(
)
''
)
if
not
self.endst
:
rais
initializationerror
(
``
at
least
one
state
must
be
an
end_stat
''
)
while
true
:
(
newstat
,
cargo
)
=
handler
(
cargo
)
if
newstate.upp
(
)
in
self.endst
:
print
(
``
reach
``
,
newstat
)
break
els
:
handler
=
self.handl
[
newstate.upp
(
)
]
thi
gener
fsm
is
use
in
the
next
program
:
from
statemachin
import
statemachin
positive_adject
=
[
``
great
''
,
''
super
''
,
``
fun
''
,
``
entertain
''
,
``
easi
''
]
negative_adject
=
[
``
bore
''
,
``
difficult
''
,
``
ugli
''
,
``
bad
''
]
def
start_transit
(
txt
)
:
splitted_txt
=
txt.split
(
none,1
)
word
,
txt
=
splitted_txt
if
len
(
splitted_txt
)
>
1
els
(
txt
,
''
''
)
if
word
==
``
python
''
:
newstat
=
``
python_st
''
els
:
newstat
=
``
error_st
''
return
(
newstat
,
txt
)
def
python_state_transit
(
txt
)
:
splitted_txt
=
txt.split
(
none,1
)
word
,
txt
=
splitted_txt
if
len
(
splitted_txt
)
>
1
els
(
txt
,
''
''
)
if
word
==
``
is
''
:
newstat
=
``
is_stat
''
els
:
newstat
=
``
error_st
''
return
(
newstat
,
txt
)
def
is_state_transit
(
txt
)
:
splitted_txt
=
txt.split
(
none,1
)
word
,
txt
=
splitted_txt
if
len
(
splitted_txt
)
>
1
els
(
txt
,
''
''
)
if
word
==
``
not
''
:
newstat
=
``
not_stat
''
elif
word
in
positive_adject
:
newstat
=
``
pos_stat
''
elif
word
in
negative_adject
:
newstat
=
``
neg_stat
''
els
:
newstat
=
``
error_st
''
return
(
newstat
,
txt
)
def
not_state_transit
(
txt
)
:
splitted_txt
=
txt.split
(
none,1
)
word
,
txt
=
splitted_txt
if
len
(
splitted_txt
)
>
1
els
(
txt
,
''
''
)
if
word
in
positive_adject
:
newstat
=
``
neg_stat
''
elif
word
in
negative_adject
:
newstat
=
``
pos_stat
''
els
:
newstat
=
``
error_st
''
return
(
newstat
,
txt
)
def
neg_stat
(
txt
)
:
print
(
``
hallo
''
)
return
(
``
neg_stat
''
,
``
''
)
if
__name__==
``
__main__
''
:
m
=
statemachin
(
)
m.add_stat
(
``
start
''
,
start_transit
)
m.add_stat
(
``
python_st
''
,
python_state_transit
)
m.add_stat
(
``
is_stat
''
,
is_state_transit
)
m.add_stat
(
``
not_stat
''
,
not_state_transit
)
m.add_stat
(
``
neg_stat
''
,
none
,
end_state=1
)
m.add_stat
(
``
pos_stat
''
,
none
,
end_state=1
)
m.add_stat
(
``
error_st
''
,
none
,
end_state=1
)
m.set_start
(
``
start
''
)
m.run
(
``
python
is
great
''
)
m.run
(
``
python
is
difficult
''
)
m.run
(
``
perl
is
ugli
''
)
If
we
save
the
applic
of
our
gener
finit
state
machin
in
statemachine_test.pi
and
call
it
with
python
statemachine_test.pi
we
get
the
follow
result
:
$
python
statemachine_test.pi
reach
pos_stat
which
is
an
end
state
reach
neg_stat
which
is
an
end
state
reach
error_st
which
is
an
end
state
the
code
of
the
finit
state
machin
is
compat
with
python3
as
well
!
previou
chapter
:
curri
in
python
next
chapter
:
ture
machin
in
python
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

python2
tutori
:
road
to
metaclass
python
cours
python
2
tutori
histori
and
philosophi
of
pythonwhi
python
?
interact
modeexecut
a
scriptstructur
with
indentationdata
type
and
variablesoperatorsinput
and
raw_input
via
the
keyboardcondit
statementswhil
loopsfor
loopsformat
outputoutput
with
printsequenti
data
typeslist
manipulationdictionariesset
and
frozen
setsshallow
and
deep
copyfunctionsrecurs
and
recurs
functionstest
,
doctest
,
unittestsdecoratorsmemo
with
decoratorspass
argumentsnamespacesglob
vs.
local
variablesfil
managementmodular
program
and
modulesintroduct
in
regular
expressionsregular
express
,
advancedlambda
oper
,
filter
,
reduc
and
maplist
comprehensiongeneratorsexcept
handlingobject
orient
programminginherit
exampleslotsclass
and
class
creationroad
to
metaclassesmetaclassesmetaclass
exampl
:
count
function
callsabstract
class
superclass
vs.
metaclass
metaclass
should
n't
be
withtaken
with
superclass
.
thi
websit
is
support
by
:
linux
and
python
cours
as
well
as
in-hous
cours
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
einführung
in
metaklassenpython
2.7thi
tutori
deal
with
python
version
2.7thi
chapter
from
our
cours
is
avail
in
a
version
for
python3
:
road
to
metaclassesclassroom
train
cours
thi
websit
contain
a
free
and
extens
onlin
tutori
by
bernd
klein
,
use
materi
from
hi
classroom
python
train
cours
.
If
you
are
interest
in
an
instructor-l
classroom
train
cours
,
you
may
have
a
look
at
the
python
class
by
bernd
klein
at
bodenseo
.
©
kabliczech
-
fotolia.com
quot
of
the
day
:
man
is
the
best
comput
we
can
put
aboard
a
spacecraft
...
and
the
onli
one
that
can
be
mass
produc
with
unskil
labor
.
(
wernher
von
braun
)
If
you
have
the
choic
work
with
python
2
or
python
3
,
we
recomend
to
switch
to
python
3
!
you
can
read
our
python
tutori
to
see
what
the
differ
are
.
data
protect
declar
data
protect
declar
previou
chapter
:
class
and
class
creation
next
chapter
:
metaclass
On
the
road
to
metaclassesmotiv
for
metaclass
In
thi
chapter
of
our
tutori
we
want
to
provid
some
incent
or
motiv
for
the
use
of
metaclass
.
To
demonstr
some
design
problem
,
which
can
be
solv
by
metaclass
,
we
will
introduc
and
design
a
bunch
of
philosoph
class
.
each
philosoph
class
(
philosopher1
,
philosopher2
,
and
so
on
)
need
the
same
``
set
''
of
method
(
in
our
exampl
just
one
,
i.e
.
``
the_answ
''
)
as
the
basic
for
hi
or
her
ponder
and
brood
.
A
stupid
way
to
implement
the
class
consist
in
have
the
same
code
in
everi
philosph
class
:
class
philosopher1
:
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher2
:
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher3
:
def
the_answ
(
self
,
*arg
)
:
return
42
plato
=
philosopher1
(
)
print
(
plato.the_answ
(
)
)
kant
=
philosopher2
(
)
#
let
's
see
what
kant
ha
to
say
:
-
)
print
(
kant.the_answ
(
)
)
42
42
We
can
see
that
we
have
multipl
copi
of
the
method
``
the_answ
''
.
thi
is
error
prone
and
tediou
to
maintain
,
of
cours
.
from
what
we
know
so
far
,
the
easiest
way
to
accomplish
our
goal
without
creat
redund
code
consist
in
design
a
base
,
which
contain
``
the_answ
''
as
a
method
.
each
philosoph
class
inherit
now
from
thi
base
class
:
class
answer
:
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher1
(
answer
)
:
pass
class
philosopher2
(
answer
)
:
pass
class
philosopher3
(
answer
)
:
pass
plato
=
philosopher1
(
)
print
(
plato.the_answ
(
)
)
kant
=
philosopher2
(
)
#
let
's
see
what
kant
ha
to
say
:
-
)
print
(
kant.the_answ
(
)
)
42
42
the
way
we
have
design
our
class
,
each
philosoph
class
will
alway
have
a
method
``
the_answ
''
.
let
's
assum
,
we
do
n't
know
a
priori
if
we
want
or
need
thi
method
.
let
's
assum
that
the
decis
,
if
the
class
have
to
be
augment
,
can
onli
be
made
at
runtim
.
thi
decis
might
depend
on
configur
file
,
user
input
or
some
calcul
.
#
the
follow
variabl
would
be
set
as
the
result
of
a
runtim
calcul
:
x
=
input
(
``
Do
you
need
the
answer
?
(
y/n
)
:
``
)
if
x==
''
y
''
:
requir
=
true
els
:
requir
=
fals
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher1
:
pass
if
requir
:
philosopher1.the_answ
=
the_answ
class
philosopher2
:
pass
if
requir
:
philosopher2.the_answ
=
the_answ
class
philosopher3
:
pass
if
requir
:
philosopher3.the_answ
=
the_answ
plato
=
philosopher1
(
)
kant
=
philosopher2
(
)
#
let
's
see
what
plato
and
kant
have
to
say
:
-
)
if
requir
:
print
(
kant.the_answ
(
)
)
print
(
plato.the_answ
(
)
)
els
:
print
(
``
the
silenc
of
the
philosph
''
)
Do
you
need
the
answer
?
(
y/n
)
:
y
42
42
even
though
thi
is
anoth
solut
to
our
problem
,
there
are
still
some
seriou
drawback
.
It
's
error-pron
,
becaus
we
have
to
add
the
same
code
to
everi
class
and
it
seem
like
that
we
might
forget
it
.
besid
thi
it
's
get
hardli
manag
and
mayb
even
confus
,
if
there
are
mani
method
we
want
to
add
.
We
can
improv
our
approach
by
defin
a
manag
function
and
avoid
redund
code
thi
way
.
the
manag
function
will
be
use
to
augment
the
class
condit
.
#
the
follow
variabl
would
be
set
as
the
result
of
a
runtim
calcul
:
x
=
input
(
``
Do
you
need
the
answer
?
(
y/n
)
:
``
)
if
x==
''
y
''
:
requir
=
true
els
:
requir
=
fals
def
the_answ
(
self
,
*arg
)
:
return
42
#
manag
function
def
augment_answ
(
cl
)
:
if
requir
:
cls.the_answ
=
the_answ
class
philosopher1
:
pass
augment_answ
(
philosopher1
)
class
philosopher2
:
pass
augment_answ
(
philosopher2
)
class
philosopher3
:
pass
augment_answ
(
philosopher3
)
plato
=
philosopher1
(
)
kant
=
philosopher2
(
)
#
let
's
see
what
plato
and
kant
have
to
say
:
-
)
if
requir
:
print
(
kant.the_answ
(
)
)
print
(
plato.the_answ
(
)
)
els
:
print
(
``
the
silenc
of
the
philosph
''
)
Do
you
need
the
answer
?
(
y/n
)
:
y
42
42
thi
is
again
use
to
solv
our
problem
,
but
we
,
i.e
.
the
class
design
,
must
be
care
not
to
forget
to
call
the
manag
function
``
augment_answ
''
.
the
code
should
be
execut
automat
.
We
need
a
way
to
make
sure
that
``
some
''
code
might
be
execut
automat
after
the
end
of
a
class
definit
.
#
the
follow
variabl
would
be
set
as
the
result
of
a
runtim
calcul
:
x
=
input
(
``
Do
you
need
the
answer
?
(
y/n
)
:
``
)
if
x==
''
y
''
:
requir
=
true
els
:
requir
=
fals
def
the_answ
(
self
,
*arg
)
:
return
42
def
augment_answ
(
cl
)
:
if
requir
:
cls.the_answ
=
the_answ
#
we
have
to
return
the
class
now
:
return
cl
@
augment_answ
class
philosopher1
:
pass
@
augment_answ
class
philosopher2
:
pass
@
augment_answ
class
philosopher3
:
pass
plato
=
philosopher1
(
)
kant
=
philosopher2
(
)
#
let
's
see
what
plato
and
kant
have
to
say
:
-
)
if
requir
:
print
(
kant.the_answ
(
)
)
print
(
plato.the_answ
(
)
)
els
:
print
(
``
the
silenc
of
the
philosph
''
)
Do
you
need
the
answer
?
(
y/n
)
:
y
42
42
metaclass
can
also
be
use
for
thi
purpos
as
we
will
learn
in
the
next
chapter
.
previou
chapter
:
class
and
class
creation
next
chapter
:
metaclass
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

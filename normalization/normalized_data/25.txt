python
tutori
:
properti
vs.
getter
and
setter
python
cours
python
3
tutori
the
origin
of
pythonstart
with
python
:
the
interact
shellexecut
a
scriptindentationdata
type
and
variablesoperatorssequenti
data
type
:
list
and
stringslist
manipulationsshallow
and
deep
copydictionariesset
and
frozen
setsan
extens
exampl
use
setsinput
via
the
keyboardcondit
statementsloop
,
while
loopfor
loopsdiffer
between
inter
und
iterablesoutput
with
printformat
output
with
string
modulo
and
the
format
methodfunctionsrecurs
and
recurs
functionsparamet
pass
in
functionsnamespacesglob
and
local
variablesdecoratorsmemo
with
decoratorsread
and
write
filesmodular
program
and
modulespackag
in
pythonregular
expressionsregular
express
,
advancedlambda
oper
,
filter
,
reduc
and
maplist
comprehensioniter
and
generatorsexcept
handlingtest
,
doctest
,
unittestsobject
orient
programmingclass
and
instanc
attributesproperti
vs.
getter
and
settersinheritancemultipl
inheritancemag
method
and
oper
overloadingoop
,
inherit
exampleslotsclass
and
class
creationroad
to
metaclassesmetaclassesmetaclass
use
case
:
count
function
callsabstract
class
organ
robberi
georg
bernard
shaw
onc
said
``
properti
is
organ
robberi
.
''
thi
is
true
in
a
veri
posit
sens
in
python
as
well
:
A
properti
in
python
``
rob
''
the
necess
to
need
getter
and
setter
for
attribut
and
to
make
it
possibl
to
start
with
public
attribut
instead
of
have
everyth
privat
!
say
about
properti
thi
is
not
python
relat
:
thiev
respect
properti
.
they
mere
wish
the
properti
to
becom
their
properti
that
they
may
more
perfectli
respect
it
.
``
properti
ha
it
duti
as
well
as
it
right
.
``
,
thoma
drummond
(
1797-1840
)
cute
wabbit
A
littl
girl
goe
into
a
pet
show
and
ask
for
a
wabbit
.
the
shop
keeper
look
down
at
her
,
smile
and
say
:
``
would
you
like
a
love
fluffi
littl
white
rabbit
,
or
a
cutesi
wootesli
littl
brown
rabbit
?
''
``
actual
''
,
say
the
littl
girl
,
``
I
do
n't
think
my
python
would
notic
.
''
(
nick
leaton
,
wed
,
04
dec
1996
)
thi
websit
is
support
by
:
linux
and
python
cours
and
seminar
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
properti
book
a
dedic
cours
the
goal
of
thi
websit
is
to
provid
educ
materi
,
allow
you
to
learn
python
on
your
own
.
nevertheless
,
it
is
faster
and
more
effici
to
attend
a
``
real
''
python
cours
in
a
classroom
,
with
an
experienc
trainer
.
So
whi
not
attend
one
of
the
live
python
cours
in
pari
,
london
,
berlin
,
munich
or
lake
constanc
by
bernd
klein
,
the
author
of
thi
tutori
?
onsit
train
cours
let
us
come
to
your
compani
or
institut
and
train
your
employe
,
as
we
've
done
it
mani
time
in
amsterdam
(
the
netherland
)
,
berlin
(
germani
)
,
bern
(
switzerland
)
,
basel
(
switzerland
)
,
zurich
(
switzerland
)
,
locarno
(
switzerland
)
,
den
haag
(
the
hagu
)
,
hamburg
(
germani
)
,
frankfurt
(
germani
)
,
toronto
(
canada
)
,
edmonton
(
canada
)
,
munich
(
germani
)
and
mani
other
citi
.
We
do
train
cours
in
england
,
switzerland
,
liechtenstein
,
austria
,
germani
,
franc
,
belgium
,
the
netherland
,
luxembourg
,
poland
,
UK
,
itali
and
other
locat
in
europ
and
in
canada
.
thi
way
you
will
get
a
perfect
train
up
to
your
need
and
it
will
be
extrem
cost
effici
as
well
.
contact
us
so
we
can
defin
and
find
the
best
cours
curriculum
to
meet
your
need
,
and
schedul
cours
session
to
be
held
at
your
locat
.
skill
python
programm
you
can
hire
skill
python
programm
or
even
a
skill
team
of
python
develop
to
work
exclus
on
your
project
.
contact
us
,
if
you
want
more
inform
.
quot
of
the
day
:
''
the
question
of
whether
a
comput
can
think
is
no
more
interest
than
the
question
of
whether
a
submarin
can
swim
.
''
(
edsger
wybe
dijkstra
)
data
protect
declar
data
protect
declar
previou
chapter
:
class
and
instanc
attribut
next
chapter
:
inherit
properti
vs.
getter
and
setter
properti
getter
and
setter
are
use
in
mani
object
orient
program
languag
to
ensur
the
principl
of
data
encapsul
.
they
are
known
as
mutat
method
as
well
.
data
encapsul
-
as
we
have
learnt
in
our
introduct
on
object
orient
program
of
our
tutori
-
is
seen
as
the
bundl
of
data
with
the
method
that
oper
on
these
data
.
these
method
are
of
cours
the
getter
for
retriev
the
data
and
the
setter
for
chang
the
data
.
accord
to
thi
principl
,
the
attribut
of
a
class
are
made
privat
to
hide
and
protect
them
from
other
code
.
unfortun
,
it
is
widespread
belief
that
a
proper
python
class
should
encapsul
privat
attribut
by
use
getter
and
setter
.
As
soon
as
one
of
these
programm
introduc
a
new
attribut
,
he
or
she
will
make
it
a
privat
variabl
and
creat
``
automat
''
a
getter
and
a
setter
for
thi
attribut
.
such
programm
may
even
use
an
editor
or
an
ide
,
which
automat
creat
getter
and
setter
for
all
privat
attribut
.
these
tool
even
warn
the
programm
if
she
or
he
use
a
public
attribut
!
java
programm
will
wrinkl
their
brow
,
screw
up
their
nose
,
or
even
scream
with
horror
when
they
read
the
follow
:
the
python
way
to
introduc
attribut
is
to
make
them
public
.
We
will
explain
thi
later
.
first
,
we
demonstr
in
the
follow
exampl
,
how
we
can
design
a
class
in
a
javaesqu
way
with
getter
and
setter
to
encapsul
the
privat
attribut
``
self.__x
''
:
class
P
:
def
__init__
(
self
,
x
)
:
self.__x
=
x
def
get_x
(
self
)
:
return
self.__x
def
set_x
(
self
,
x
)
:
self.__x
=
x
We
can
see
in
the
follow
demo
session
how
to
work
with
thi
class
and
the
method
:
>
>
>
from
mutat
import
P
>
>
>
p1
=
P
(
42
)
>
>
>
p2
=
P
(
4711
)
>
>
>
p1.get_x
(
)
42
>
>
>
p1.set_x
(
47
)
>
>
>
p1.set_x
(
p1.get_x
(
)
+p2.get_x
(
)
)
>
>
>
p1.get_x
(
)
4758
>
>
>
what
do
you
think
about
the
express
``
p1.set_x
(
p1.get_x
(
)
+p2.get_x
(
)
)
''
?
It
's
ugli
,
is
n't
it
?
It
's
a
lot
easier
to
write
an
express
like
the
follow
,
if
we
had
a
public
attribut
x
:
p1.x
=
p1.x
+
p2.x
such
an
assign
is
easier
to
write
and
abov
all
easier
to
read
than
the
javaesqu
express
.
let
's
rewrit
the
class
P
in
a
python
way
.
No
getter
,
no
setter
and
instead
of
the
privat
attribut
``
self.__x
''
we
use
a
public
one
:
class
P
:
def
__init__
(
self
,
x
)
:
self.x
=
x
beauti
,
is
n't
it
?
just
three
line
of
code
,
if
we
do
n't
count
the
blank
line
!
>
>
>
from
p
import
P
>
>
>
p1
=
P
(
42
)
>
>
>
p2
=
P
(
4711
)
>
>
>
p1.x
42
>
>
>
p1.x
=
47
>
>
>
p1.x
=
p1.x
+
p2.x
>
>
>
p1.x
4758
>
>
>
``
but
,
but
,
but
,
but
,
but
...
``
,
we
can
hear
them
howl
and
scream
,
``
but
there
is
NO
data
encapsul
!
''
ye
,
in
thi
case
there
is
no
data
encapsul
.
We
do
n't
need
it
in
thi
case
.
the
onli
thing
get_x
and
set_x
in
our
start
exampl
did
wa
``
get
the
data
through
''
without
do
anyth
,
no
check
noth
.
but
what
happen
if
we
want
to
chang
the
implement
in
the
futur
.
thi
is
a
seriou
argument
.
let
's
assum
we
want
to
chang
the
implement
like
thi
:
the
attribut
x
can
have
valu
between
0
and
1000
.
If
a
valu
larger
than
1000
is
assign
,
x
should
be
set
to
1000
.
correspondingli
,
x
should
be
set
to
0
,
if
the
valu
is
less
than
0
.
It
is
easi
to
chang
our
first
P
class
to
cover
thi
problem
.
We
chang
the
set_x
method
accordingli
:
class
P
:
def
__init__
(
self
,
x
)
:
self.set_x
(
x
)
def
get_x
(
self
)
:
return
self.__x
def
set_x
(
self
,
x
)
:
if
x
<
0
:
self.__x
=
0
elif
x
>
1000
:
self.__x
=
1000
els
:
self.__x
=
x
the
follow
python
session
show
that
it
work
the
way
we
want
it
to
work
:
>
>
>
from
mutat
import
P
>
>
>
p1
=
P
(
1001
)
>
>
>
p1.get_x
(
)
1000
>
>
>
p2
=
P
(
15
)
>
>
>
p2.get_x
(
)
15
>
>
>
p3
=
P
(
-1
)
>
>
>
p3.get_x
(
)
0
but
there
is
a
catch
:
let
's
assum
we
have
design
our
class
with
the
public
attribut
and
no
method
.
peopl
have
alreadi
use
it
a
lot
and
they
have
written
code
like
thi
:
from
p
import
P
p1
=
P
(
42
)
p1.x
=
1001
our
new
class
mean
break
the
interfac
.
the
attribut
x
is
not
avail
anymor
.
that
's
whi
in
java
e.g
.
peopl
are
recommend
to
use
onli
privat
attribut
with
getter
and
setter
,
so
that
they
can
chang
the
implement
without
have
to
chang
the
interfac
.
but
python
offer
a
solut
to
thi
problem
.
the
solut
is
call
properti
!
the
class
with
a
properti
look
like
thi
:
class
P
:
def
__init__
(
self
,
x
)
:
self.x
=
x
@
properti
def
x
(
self
)
:
return
self.__x
@
x.setter
def
x
(
self
,
x
)
:
if
x
<
0
:
self.__x
=
0
elif
x
>
1000
:
self.__x
=
1000
els
:
self.__x
=
x
A
method
which
is
use
for
get
a
valu
is
decor
with
``
@
properti
''
,
i.e
.
we
put
thi
line
directli
in
front
of
the
header
.
the
method
which
ha
to
function
as
the
setter
is
decor
with
``
@
x.setter
''
.
If
the
function
had
been
call
``
f
''
,
we
would
have
to
decor
it
with
``
@
f.setter
''
.
two
thing
are
noteworthi
:
We
just
put
the
code
line
``
self.x
=
x
''
in
the
__init__
method
and
the
properti
method
x
is
use
to
check
the
limit
of
the
valu
.
the
second
interest
thing
is
that
we
wrote
``
two
''
method
with
the
same
name
and
a
differ
number
of
paramet
``
def
x
(
self
)
''
and
``
def
x
(
self
,
x
)
''
.
We
have
learn
in
a
previou
chapter
of
our
cours
that
thi
is
not
possibl
.
It
work
here
due
to
the
decor
:
>
>
>
from
p
import
P
>
>
>
p1
=
P
(
1001
)
>
>
>
p1.x
1000
>
>
>
p1.x
=
-12
>
>
>
p1.x
0
>
>
>
altern
,
we
could
have
use
a
differ
syntax
without
decor
to
defin
the
properti
.
As
you
can
see
,
the
code
is
definit
less
eleg
and
we
have
to
make
sure
that
we
use
the
getter
function
in
the
__init__
method
again
:
class
P
:
def
__init__
(
self
,
x
)
:
self.set_x
(
x
)
def
get_x
(
self
)
:
return
self.__x
def
set_x
(
self
,
x
)
:
if
x
<
0
:
self.__x
=
0
elif
x
>
1000
:
self.__x
=
1000
els
:
self.__x
=
x
x
=
properti
(
get_x
,
set_x
)
there
is
still
anoth
problem
in
the
most
recent
version
.
We
have
now
two
way
to
access
or
chang
the
valu
of
x
:
either
by
use
``
p1.x
=
42
''
or
by
``
p1.set_x
(
42
)
''
.
thi
way
we
are
violat
one
of
the
fundament
of
python
:
``
there
should
be
one
--
and
prefer
onli
one
--
obviou
way
to
do
it
.
''
(
see
zen
of
python
)
We
can
easili
fix
thi
problem
by
ture
the
getter
and
the
setter
method
into
privat
method
,
which
ca
n't
be
access
anymor
by
the
user
of
our
class
P
:
class
P
:
def
__init__
(
self
,
x
)
:
self.__set_x
(
x
)
def
__get_x
(
self
)
:
return
self.__x
def
__set_x
(
self
,
x
)
:
if
x
<
0
:
self.__x
=
0
elif
x
>
1000
:
self.__x
=
1000
els
:
self.__x
=
x
x
=
properti
(
__get_x
,
__set_x
)
even
though
we
fix
thi
problem
by
use
a
privat
getter
and
setter
,
the
version
with
the
decor
``
@
properti
''
is
the
python
way
to
do
it
!
from
what
we
have
written
so
far
,
and
what
can
be
seen
in
other
book
and
tutori
as
well
,
we
could
easili
get
the
impress
that
there
is
a
one-to-on
connect
between
properti
(
or
mutat
method
)
and
the
attribut
,
i.e
.
that
each
attribut
ha
or
should
have
it
own
properti
(
or
getter-setter-pair
)
and
the
other
way
around
.
even
in
other
object
orient
languag
than
python
,
it
's
usual
not
a
good
idea
to
implement
a
class
like
that
.
the
main
reason
is
that
mani
attribut
are
onli
intern
need
and
creat
interfac
for
the
user
of
the
class
increas
unnecessarili
the
usabl
of
the
class
.
the
possibl
user
of
a
class
should
n't
be
``
drown
''
with
umpteen
-
of
mainli
unnecessari
-
method
or
properti
!
the
follow
exampl
show
a
class
,
which
ha
intern
attribut
,
which
ca
n't
be
access
from
outsid
.
these
are
the
privat
attribut
self.__potential_phys
and
self.__potential_psych
.
furthermor
we
show
that
a
properti
can
be
deduc
from
the
valu
of
more
than
one
attribut
.
the
properti
``
condit
''
of
our
exampl
return
the
condit
of
the
robot
in
a
descript
string
.
the
condit
depend
on
the
sum
of
the
valu
of
the
psychic
and
the
physic
condit
of
the
robot
.
class
robot
:
def
__init__
(
self
,
name
,
build_year
,
lk
=
0.5
,
lp
=
0.5
)
:
self.nam
=
name
self.build_year
=
build_year
self.__potential_phys
=
lk
self.__potential_psych
=
lp
@
properti
def
condit
(
self
)
:
s
=
self.__potential_phys
+
self.__potential_psych
if
s
<
=
-1
:
return
``
I
feel
miser
!
''
elif
s
<
=
0
:
return
``
I
feel
bad
!
''
elif
s
<
=
0.5
:
return
``
could
be
wors
!
''
elif
s
<
=
1
:
return
``
seem
to
be
okay
!
''
els
:
return
``
great
!
''
if
__name__
==
``
__main__
''
:
x
=
robot
(
``
marvin
''
,
1979
,
0.2
,
0.4
)
y
=
robot
(
``
caliban
''
,
1993
,
-0.4
,
0.3
)
print
(
x.condit
)
print
(
y.condit
)
public
instead
of
privat
attribut
let
's
summar
the
usag
of
privat
and
public
attribut
,
getter
and
setter
and
properti
:
let
's
assum
that
we
are
design
a
new
class
and
we
ponder
about
an
instanc
or
class
attribut
``
ouratt
''
,
which
we
need
for
the
design
of
our
class
.
We
have
to
observ
the
follow
issu
:
will
the
valu
of
``
ouratt
''
be
need
by
the
possibl
user
of
our
class
?
If
not
,
we
can
or
should
make
it
a
privat
attribut
.
If
it
ha
to
be
access
,
we
make
it
access
as
a
public
attribut
We
will
defin
it
as
a
privat
attribut
with
the
correspond
properti
,
if
and
onli
if
we
have
to
do
some
check
or
transform
of
the
data
.
(
As
an
exampl
,
you
can
have
a
look
again
at
our
class
P
,
where
the
attribut
ha
to
be
in
the
interv
between
0
and
1000
,
which
is
ensur
by
the
properti
``
x
''
)
altern
,
you
could
use
a
getter
and
a
setter
,
but
use
a
properti
is
the
python
way
to
deal
with
it
!
let
's
assum
we
have
defin
``
ouratt
''
as
a
public
attribut
.
our
class
ha
been
success
use
by
other
user
for
quit
a
while
.
now
come
the
point
which
frighten
some
tradit
oopista
out
of
their
wit
:
imagin
``
ouratt
''
ha
been
use
as
an
integ
.
now
,
our
class
ha
to
ensur
that
``
ouratt
''
ha
to
be
a
valu
between
0
and
1000
?
without
properti
,
thi
is
realli
a
horribl
scenario
!
due
to
properti
it
's
easi
:
We
creat
a
properti
version
of
``
ouratt
''
.
class
ourclass
:
def
__init__
(
self
,
a
)
:
self.ouratt
=
a
x
=
ourclass
(
10
)
print
(
x.ouratt
)
class
ourclass
:
def
__init__
(
self
,
a
)
:
self.ouratt
=
a
@
properti
def
ouratt
(
self
)
:
return
self.__ouratt
@
ouratt.sett
def
ouratt
(
self
,
val
)
:
if
val
<
0
:
self.__ouratt
=
0
elif
val
>
1000
:
self.__ouratt
=
1000
els
:
self.__ouratt
=
val
x
=
ourclass
(
10
)
print
(
x.ouratt
)
thi
is
great
,
is
n't
it
:
you
can
start
with
the
simplest
implement
imagin
,
and
you
are
free
to
later
migrat
to
a
properti
version
without
have
to
chang
the
interfac
!
So
properti
are
not
just
a
replac
for
getter
and
setter
!
someth
els
you
might
have
alreadi
notic
:
for
the
user
of
a
class
,
properti
are
syntact
ident
to
ordinari
attribut
.
previou
chapter
:
class
and
instanc
attribut
next
chapter
:
inherit
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

numer
&
scientif
comput
with
python
:
data
type
object
,
dtype
numer
python
cours
numer
program
numpi
introductioncr
numpi
arraysdata
type
object
,
dtypenumer
oper
on
numpi
arrayschang
the
dimens
of
arrayspython
,
numpi
and
probabilityweight
choic
and
weight
samplescr
of
synthet
test
databoolean
mask
of
arraysmatrix
arithmeticread
and
write
ndarraysmatplotlib
introductionspin
and
tickslegend
and
annotationsmultipl
figur
and
axeshistogramscontour
plotspython
imag
process
tutorialimag
process
techniquespanda
tutorialpanda
dataframespanda
data
filesd
with
nanbin
datapanda
tutori
continu
:
multi-level
indexingdata
visual
with
panda
and
pythonpython
,
date
and
timepython
,
panda
and
timeserieslinear
combin
definit
of
data
type
In
a
program
languag
data
type
are
a
classif
on
the
set
of
all
possibl
data
.
thi
classif
is
base
on
the
possibl
valu
of
the
type
and
the
oper
which
can
be
perform
on
them
.
most
program
languag
come
with
basic
data
type
like
integ
,
real
,
float
or
boolean
.
In
program
languag
like
C
,
c++
or
java
,
there
is
a
one-to-on
correspond
between
data
type
and
a
variabl
name
.
thi
is
differ
in
python
,
where
a
variabl
name
correspond
to
the
object
it
refer
.
thi
is
explain
in
detail
in
the
chapter
``
data
type
and
variabl
''
of
our
python
tutori
.
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
datentyp-objekt
:
dtypeclassroom
train
cours
thi
websit
contain
a
free
and
extens
onlin
tutori
by
bernd
klein
,
use
materi
from
hi
classroom
python
train
cours
.
If
you
are
interest
in
an
instructor-l
classroom
train
cours
,
you
may
have
a
look
at
the
python
class
by
bernd
klein
at
bodenseo
.
©
kabliczech
-
fotolia.com
quot
of
the
day
:
''
the
digit
revolut
is
far
more
signific
than
the
invent
of
write
or
even
of
print
.
''
(
dougla
engelbart
)
If
you
have
the
choic
work
with
python
2
or
python
3
,
we
recomend
to
switch
to
python
3
!
you
can
read
our
python
tutori
to
see
what
the
differ
are
.
data
protect
declar
data
protect
declar
previou
chapter
:
creat
numpi
array
next
chapter
:
numer
oper
on
numpi
array
data
type
object
,
dtype
dtype
the
data
type
object
'dtype
'
is
an
instanc
of
numpy.dtyp
class
.
It
can
be
creat
with
numpy.dtyp
.
So
far
,
we
have
use
in
our
exampl
of
numpi
array
onli
fundament
numer
data
type
like
'int
'
and
'float
'
.
these
numpi
array
contain
sole
homogen
data
type
.
dtype
object
are
constru
by
combin
of
fundament
data
type
.
with
the
aid
of
dtype
we
are
capabl
to
creat
``
structur
array
''
,
-
also
known
as
``
record
array
''
.
the
structur
array
provid
us
with
the
abil
to
have
differ
data
type
per
column
.
It
ha
similar
to
the
structur
of
excel
or
csv
document
.
thi
make
it
possib
to
defin
data
like
the
one
in
the
follow
tabl
with
dtype
:
|country|
popul
densiti
|
area
|
nbsp
;
popul
|
|
--
--
--
--
--
--
|
--
--
--
--
--
:
|
--
--
:
|
--
--
:
|
|netherland
|
393
|
41526
|
16,928,800
|
|belgium
|337
|
30510
|11,007,020|
|unit
kingdom
|256
|
243610
|
62,262,000|
|germani
|233
|
357021
|
81,799,600
|
|liechtenstein
|
205
|
160
|32,842|
|itali
|
192
|
301230
|
59,715,625|
|switzerland
|
177
|
41290
|
7,301,994
|
|luxembourg
|
173
|
2586
|
512,000|
|franc
|
111
|
547030
|
63,601,002|
|austria
|
97
|
83858
|
8,169,929|
|greec
|
81
|
131940
|
11,606,813|
|ireland
|
65
|
70280
|
4,581,269|
|sweden
|
20
|
449964
|
9,515,744|
|finland
|
16
|
338424
|
5,410,233|
|norway
|
13
|
385252
|
5,033,675|
befor
we
start
with
a
complex
data
structur
like
the
previou
data
,
we
want
to
introduc
dtype
in
a
veri
simpl
exampl
.
We
defin
an
int16
data
type
and
call
thi
type
i16
.
(
We
have
to
admit
,
that
thi
is
not
a
nice
name
,
but
we
use
it
onli
here
!
)
.
the
element
of
the
list
'lst
'
are
turn
into
i16
type
to
creat
the
two-dimension
array
A.
import
numpi
as
np
i16
=
np.dtype
(
np.int16
)
print
(
i16
)
lst
=
[
[
3.4
,
8.7
,
9.9
]
,
[
1.1
,
-7.8
,
-0.7
]
,
[
4.1
,
12.3
,
4.8
]
]
A
=
np.array
(
lst
,
dtype=i16
)
print
(
A
)
int16
[
[
3
8
9
]
[
1
-7
0
]
[
4
12
4
]
]
We
introduc
a
new
name
for
a
basic
data
type
in
the
previou
exampl
.
thi
ha
noth
to
do
with
the
structur
array
,
which
we
mention
in
the
introduct
of
thi
chapter
of
our
dtype
tutori
.
structur
arraysndarray
are
homogen
data
object
,
i.e
.
all
element
of
an
array
have
to
be
of
the
same
data
type
.
the
data
type
dytp
on
the
other
hand
allow
as
to
defin
separ
data
type
for
each
column
.
now
we
will
take
the
first
step
toward
implement
the
tabl
with
european
countri
and
the
inform
on
popul
,
area
and
popul
densiti
.
We
creat
a
structur
array
with
the
'densiti
'
column
.
the
data
type
is
defin
as
np.dtype
(
[
(
'densiti
'
,
np.int
)
]
)
.
We
assign
thi
data
type
to
the
variabl
'dt
'
for
the
sake
of
conveni
.
We
use
thi
data
type
in
the
darray
definit
,
in
which
we
use
the
first
three
densiti
.
import
numpi
as
np
dt
=
np.dtype
(
[
(
'densiti
'
,
np.int32
)
]
)
x
=
np.array
(
[
(
393
,
)
,
(
337
,
)
,
(
256
,
)
]
,
dtype=dt
)
print
(
x
)
print
(
``
\nthe
intern
represent
:
''
)
print
(
repr
(
x
)
)
[
(
393
,
)
(
337
,
)
(
256
,
)
]
the
intern
represent
:
array
(
[
(
393
,
)
,
(
337
,
)
,
(
256
,
)
]
,
dtype=
[
(
'densiti
'
,
'
<
i4
'
)
]
)
We
can
access
the
content
of
the
densiti
column
by
index
x
with
the
key
'densiti
'
.
It
look
like
access
a
dictionari
in
python
:
print
(
x
[
'densiti
'
]
)
[
393
337
256
]
you
may
wonder
that
we
have
use
'np.int32
'
in
our
definit
and
the
intern
represent
show
'
<
i4
'
.
We
can
use
in
the
dtype
definit
the
type
directli
(
e.g
.
np.int32
)
or
we
can
use
a
string
(
e.g
.
'i4
'
)
.
So
,
we
could
have
defin
our
dtype
like
thi
as
well
:
dt
=
np.dtype
(
[
(
'densiti
'
,
'i4
'
)
]
)
x
=
np.array
(
[
(
393
,
)
,
(
337
,
)
,
(
256
,
)
]
,
dtype=dt
)
print
(
x
)
[
(
393
,
)
(
337
,
)
(
256
,
)
]
the
'
i
'
mean
integ
and
the
4
mean
4
byte
.
what
about
the
less-than
sign
in
front
of
i4
in
the
result
?
We
could
have
written
'
<
i4
'
in
our
definit
as
well
.
We
can
prefix
a
type
with
the
'
<
'
and
'
>
'
sign
.
'
<
'
mean
that
the
encod
will
be
little-endian
and
'
>
'
mean
that
the
encod
will
be
big-endian
.
No
prefix
mean
that
we
get
the
nativ
byte
order
.
We
demonstr
thi
in
the
follow
by
defin
a
double-precis
floating-point
number
in
variou
order
:
#
little-endian
order
dt
=
np.dtype
(
'
<
d
'
)
print
(
dt.name
,
dt.byteord
,
dt.items
)
#
big-endian
order
dt
=
np.dtype
(
'
>
d
'
)
print
(
dt.name
,
dt.byteord
,
dt.items
)
#
nativ
byte
order
dt
=
np.dtype
(
'd
'
)
print
(
dt.name
,
dt.byteord
,
dt.items
)
float64
=
8
float64
>
8
float64
=
8
the
equal
charact
'=
'
stand
for
'nativ
byte
order
'
,
defin
by
the
oper
system
.
In
our
case
thi
mean
'little-endian
'
,
becaus
we
use
a
linux
comput
.
anoth
thing
in
our
densiti
array
might
be
confus
.
We
defin
the
array
with
a
list
contain
one-tupl
.
So
you
may
ask
yourself
,
if
it
is
possibl
to
use
tupl
and
list
interchang
?
thi
is
not
possibl
.
the
tupl
are
use
to
defin
the
record
-
in
our
case
consist
sole
of
a
densiti
-
and
the
list
is
the
'contain
'
for
the
record
or
in
other
word
'the
list
are
curs
upon
'
.
the
tupl
defin
the
atom
element
of
the
structur
and
the
list
the
dimens
.
now
we
will
add
the
countri
name
,
the
area
and
the
popul
number
to
our
data
type
:
dt
=
np.dtype
(
[
(
'countri
'
,
's20
'
)
,
(
'densiti
'
,
'i4
'
)
,
(
'area
'
,
'i4
'
)
,
(
'popul
'
,
'i4
'
)
]
)
population_t
=
np.array
(
[
(
'netherland
'
,
393
,
41526
,
16928800
)
,
(
'belgium
'
,
337
,
30510
,
11007020
)
,
(
'unit
kingdom
'
,
256
,
243610
,
62262000
)
,
(
'germani
'
,
233
,
357021
,
81799600
)
,
(
'liechtenstein
'
,
205
,
160
,
32842
)
,
(
'itali
'
,
192
,
301230
,
59715625
)
,
(
'switzerland
'
,
177
,
41290
,
7301994
)
,
(
'luxembourg
'
,
173
,
2586
,
512000
)
,
(
'franc
'
,
111
,
547030
,
63601002
)
,
(
'austria
'
,
97
,
83858
,
8169929
)
,
(
'greec
'
,
81
,
131940
,
11606813
)
,
(
'ireland
'
,
65
,
70280
,
4581269
)
,
(
'sweden
'
,
20
,
449964
,
9515744
)
,
(
'finland
'
,
16
,
338424
,
5410233
)
,
(
'norway
'
,
13
,
385252
,
5033675
)
]
,
dtype=dt
)
print
(
population_t
[
:4
]
)
[
(
b'netherland
'
,
393
,
41526
,
16928800
)
(
b'belgium
'
,
337
,
30510
,
11007020
)
(
b'unit
kingdom
'
,
256
,
243610
,
62262000
)
(
b'germani
'
,
233
,
357021
,
81799600
)
]
We
can
acc
everi
column
individu
:
print
(
population_t
[
'densiti
'
]
)
print
(
population_t
[
'countri
'
]
)
print
(
population_t
[
'area
'
]
[
2:5
]
)
[
393
337
256
233
205
192
177
173
111
97
81
65
20
16
13
]
[
b'netherland
'
b'belgium
'
b'unit
kingdom
'
b'germani
'
b'liechtenstein
'
b'itali
'
b'switzerland
'
b'luxembourg
'
b'franc
'
b'austria
'
b'greec
'
b'ireland
'
b'sweden
'
b'finland
'
b'norway
'
]
[
243610
357021
160
]
unicod
string
in
arraysom
may
have
notic
that
the
string
in
our
previou
array
have
been
prefix
with
a
lower
case
``
b
''
.
thi
mean
that
we
have
creat
binari
string
with
the
definit
``
(
'countri
'
,
's20
'
)
''
.
To
get
unicod
string
we
exchang
thi
with
the
definit
``
(
'countri
'
,
np.unicod
,
20
)
''
.
We
will
redefin
our
popul
tabl
now
:
dt
=
np.dtype
(
[
(
'countri
'
,
np.unicod
,
20
)
,
(
'densiti
'
,
'i4
'
)
,
(
'area
'
,
'i4
'
)
,
(
'popul
'
,
'i4
'
)
]
)
population_t
=
np.array
(
[
(
'netherland
'
,
393
,
41526
,
16928800
)
,
(
'belgium
'
,
337
,
30510
,
11007020
)
,
(
'unit
kingdom
'
,
256
,
243610
,
62262000
)
,
(
'germani
'
,
233
,
357021
,
81799600
)
,
(
'liechtenstein
'
,
205
,
160
,
32842
)
,
(
'itali
'
,
192
,
301230
,
59715625
)
,
(
'switzerland
'
,
177
,
41290
,
7301994
)
,
(
'luxembourg
'
,
173
,
2586
,
512000
)
,
(
'franc
'
,
111
,
547030
,
63601002
)
,
(
'austria
'
,
97
,
83858
,
8169929
)
,
(
'greec
'
,
81
,
131940
,
11606813
)
,
(
'ireland
'
,
65
,
70280
,
4581269
)
,
(
'sweden
'
,
20
,
449964
,
9515744
)
,
(
'finland
'
,
16
,
338424
,
5410233
)
,
(
'norway
'
,
13
,
385252
,
5033675
)
]
,
dtype=dt
)
print
(
population_t
[
:4
]
)
[
(
'netherland
'
,
393
,
41526
,
16928800
)
(
'belgium
'
,
337
,
30510
,
11007020
)
(
'unit
kingdom
'
,
256
,
243610
,
62262000
)
(
'germani
'
,
233
,
357021
,
81799600
)
]
input
and
output
of
structur
arraysin
most
applic
it
will
be
necessari
to
save
the
data
from
a
program
into
a
file
.
We
will
write
our
previous
creat
``
darray
''
to
a
file
with
the
command
savetxt
.
you
will
find
a
detail
introduct
into
thi
topic
in
our
chapter
read
and
write
data
file
np.savetxt
(
``
population_table.csv
''
,
population_t
,
fmt=
''
%
s
;
%
d
;
%
d
;
%
d
''
,
delimiter=
''
;
''
)
It
is
highli
probabl
that
you
will
need
to
read
in
the
previous
written
file
at
a
later
date
.
thi
can
be
achiev
with
the
function
genfromtxt
.
dt
=
np.dtype
(
[
(
'countri
'
,
np.unicod
,
20
)
,
(
'densiti
'
,
'i4
'
)
,
(
'area
'
,
'i4
'
)
,
(
'popul
'
,
'i4
'
)
]
)
x
=
np.genfromtxt
(
``
population_table.csv
''
,
dtype=dt
,
delimiter=
''
;
''
)
print
(
x
)
[
(
'netherland
'
,
393
,
41526
,
16928800
)
(
'belgium
'
,
337
,
30510
,
11007020
)
(
'unit
kingdom
'
,
256
,
243610
,
62262000
)
(
'germani
'
,
233
,
357021
,
81799600
)
(
'liechtenstein
'
,
205
,
160
,
32842
)
(
'itali
'
,
192
,
301230
,
59715625
)
(
'switzerland
'
,
177
,
41290
,
7301994
)
(
'luxembourg
'
,
173
,
2586
,
512000
)
(
'franc
'
,
111
,
547030
,
63601002
)
(
'austria
'
,
97
,
83858
,
8169929
)
(
'greec
'
,
81
,
131940
,
11606813
)
(
'ireland
'
,
65
,
70280
,
4581269
)
(
'sweden
'
,
20
,
449964
,
9515744
)
(
'finland
'
,
16
,
338424
,
5410233
)
(
'norway
'
,
13
,
385252
,
5033675
)
]
there
is
also
a
function
``
loadtxt
''
,
but
it
is
more
difficult
to
use
,
becaus
it
return
the
string
as
binari
string
!
To
overcom
thi
problem
,
we
can
use
loadtxt
with
a
convert
function
for
the
first
column
.
dt
=
np.dtype
(
[
(
'countri
'
,
np.unicod
,
20
)
,
(
'densiti
'
,
'i4
'
)
,
(
'area
'
,
'i4
'
)
,
(
'popul
'
,
'i4
'
)
]
)
x
=
np.loadtxt
(
``
population_table.csv
''
,
dtype=dt
,
converters=
{
0
:
lambda
x
:
x.decod
(
'utf-8
'
)
}
,
delimiter=
''
;
''
)
print
(
x
)
[
(
'netherland
'
,
393
,
41526
,
16928800
)
(
'belgium
'
,
337
,
30510
,
11007020
)
(
'unit
kingdom
'
,
256
,
243610
,
62262000
)
(
'germani
'
,
233
,
357021
,
81799600
)
(
'liechtenstein
'
,
205
,
160
,
32842
)
(
'itali
'
,
192
,
301230
,
59715625
)
(
'switzerland
'
,
177
,
41290
,
7301994
)
(
'luxembourg
'
,
173
,
2586
,
512000
)
(
'franc
'
,
111
,
547030
,
63601002
)
(
'austria
'
,
97
,
83858
,
8169929
)
(
'greec
'
,
81
,
131940
,
11606813
)
(
'ireland
'
,
65
,
70280
,
4581269
)
(
'sweden
'
,
20
,
449964
,
9515744
)
(
'finland
'
,
16
,
338424
,
5410233
)
(
'norway
'
,
13
,
385252
,
5033675
)
]
exercis
:
befor
you
go
on
,
you
may
take
time
to
do
some
exercis
to
deepen
the
understand
of
the
previous
learn
stuff
.
exercis
:
defin
a
structur
array
with
two
column
.
the
first
column
contain
the
product
ID
,
which
can
be
defin
as
an
int32
.
the
second
column
shall
contain
the
price
for
the
product
.
how
can
you
print
out
the
column
with
the
product
id
,
the
first
row
and
the
price
for
the
third
articl
of
thi
structur
array
?
exercis
:
figur
out
a
data
type
definit
for
time
record
with
entri
for
hour
,
minut
and
second
.
solut
:
solut
to
the
first
exercis
:
import
numpi
as
np
mytyp
=
[
(
'productid
'
,
np.int32
)
,
(
'price
'
,
np.float64
)
]
stock
=
np.array
(
[
(
34765
,
603.76
)
,
(
45765
,
439.93
)
,
(
99661
,
344.19
)
,
(
12129
,
129.39
)
]
,
dtype=mytyp
)
print
(
stock
[
1
]
)
print
(
stock
[
``
productid
''
]
)
print
(
stock
[
2
]
[
``
price
''
]
)
print
(
stock
)
(
45765
,
439.93
)
[
34765
45765
99661
12129
]
344.19
[
(
34765
,
603.76
)
(
45765
,
439.93
)
(
99661
,
344.19
)
(
12129
,
129.39
)
]
solut
to
the
second
exercis
:
time_typ
=
np.dtype
(
[
(
'
h
'
,
int
)
,
(
'min
'
,
int
)
,
(
'sec
'
,
int
)
]
)
time
=
np.array
(
[
(
11
,
38
,
5
)
,
(
14
,
56
,
0
)
,
(
3
,
9
,
1
)
]
,
dtype=time_typ
)
print
(
time
)
print
(
time
[
0
]
)
#
reset
the
first
time
record
:
time
[
0
]
=
(
11
,
42
,
17
)
print
(
time
[
0
]
)
[
(
11
,
38
,
5
)
(
14
,
56
,
0
)
(
3
,
9
,
1
)
]
(
11
,
38
,
5
)
(
11
,
42
,
17
)
A
more
complex
exampl
:
We
will
increas
the
complex
of
our
previou
exampl
by
ad
temperatur
to
the
record
.
time_typ
=
np.dtype
(
np.dtype
(
[
(
'time
'
,
[
(
'
h
'
,
int
)
,
(
'min
'
,
int
)
,
(
'sec
'
,
int
)
]
)
,
(
'temperatur
'
,
float
)
]
)
)
time
=
np.array
(
[
(
(
11
,
42
,
17
)
,
20.8
)
,
(
(
13
,
19
,
3
)
,
23.2
)
]
,
dtype=time_typ
)
print
(
time
)
print
(
time
[
'time
'
]
)
print
(
time
[
'time
'
]
[
'
h
'
]
)
print
(
time
[
'temperatur
'
]
)
[
(
(
11
,
42
,
17
)
,
20.8
)
(
(
13
,
19
,
3
)
,
23.2
)
]
[
(
11
,
42
,
17
)
(
13
,
19
,
3
)
]
[
11
13
]
[
20.8
23.2
]
exercis
thi
exercis
should
be
closer
to
real
life
exampl
.
usual
,
we
have
to
creat
or
get
the
data
for
our
structur
array
from
some
data
base
or
file
.
We
will
use
the
list
,
which
we
have
creat
in
our
chapter
on
file
i/o
``
file
manag
''
.
the
list
ha
been
save
with
the
aid
of
pickle.dump
in
the
file
cities_and_times.pkl
.
So
the
first
task
consist
in
unpickl
our
data
:
import
pickl
fh
=
open
(
``
cities_and_times.pkl
''
,
``
br
''
)
cities_and_tim
=
pickle.load
(
fh
)
print
(
cities_and_tim
[
:30
]
)
[
(
'amsterdam
'
,
'sun
'
,
(
8
,
52
)
)
,
(
'anchorag
'
,
'sat
'
,
(
23
,
52
)
)
,
(
'ankara
'
,
'sun
'
,
(
10
,
52
)
)
,
(
'athen
'
,
'sun
'
,
(
9
,
52
)
)
,
(
'atlanta
'
,
'sun
'
,
(
2
,
52
)
)
,
(
'auckland
'
,
'sun
'
,
(
20
,
52
)
)
,
(
'barcelona
'
,
'sun
'
,
(
8
,
52
)
)
,
(
'beirut
'
,
'sun
'
,
(
9
,
52
)
)
,
(
'berlin
'
,
'sun
'
,
(
8
,
52
)
)
,
(
'boston
'
,
'sun
'
,
(
2
,
52
)
)
,
(
'brasilia
'
,
'sun
'
,
(
5
,
52
)
)
,
(
'brussel
'
,
'sun
'
,
(
8
,
52
)
)
,
(
'bucharest
'
,
'sun
'
,
(
9
,
52
)
)
,
(
'budapest
'
,
'sun
'
,
(
8
,
52
)
)
,
(
'cairo
'
,
'sun
'
,
(
9
,
52
)
)
,
(
'calgari
'
,
'sun
'
,
(
1
,
52
)
)
,
(
'cape
town
'
,
'sun
'
,
(
9
,
52
)
)
,
(
'casablanca
'
,
'sun
'
,
(
7
,
52
)
)
,
(
'chicago
'
,
'sun
'
,
(
1
,
52
)
)
,
(
'columbu
'
,
'sun
'
,
(
2
,
52
)
)
,
(
'copenhagen
'
,
'sun
'
,
(
8
,
52
)
)
,
(
'dalla
'
,
'sun
'
,
(
1
,
52
)
)
,
(
'denver
'
,
'sun
'
,
(
1
,
52
)
)
,
(
'detroit
'
,
'sun
'
,
(
2
,
52
)
)
,
(
'dubai
'
,
'sun
'
,
(
11
,
52
)
)
,
(
'dublin
'
,
'sun
'
,
(
7
,
52
)
)
,
(
'edmonton
'
,
'sun
'
,
(
1
,
52
)
)
,
(
'frankfurt
'
,
'sun
'
,
(
8
,
52
)
)
,
(
'halifax
'
,
'sun
'
,
(
3
,
52
)
)
,
(
'helsinki
'
,
'sun
'
,
(
9
,
52
)
)
]
turn
our
data
into
a
structur
array
:
time_typ
=
np.dtype
(
[
(
'citi
'
,
'u30
'
)
,
(
'day
'
,
'u3
'
)
,
(
'time
'
,
[
(
'
h
'
,
int
)
,
(
'min
'
,
int
)
]
)
]
)
time
=
np.array
(
cities_and_tim
,
dtype=time_typ
)
print
(
time
[
'time
'
]
)
print
(
time
[
'citi
'
]
)
x
=
time
[
27
]
x
[
0
]
[
(
8
,
52
)
(
23
,
52
)
(
10
,
52
)
(
9
,
52
)
(
2
,
52
)
(
20
,
52
)
(
8
,
52
)
(
9
,
52
)
(
8
,
52
)
(
2
,
52
)
(
5
,
52
)
(
8
,
52
)
(
9
,
52
)
(
8
,
52
)
(
9
,
52
)
(
1
,
52
)
(
9
,
52
)
(
7
,
52
)
(
1
,
52
)
(
2
,
52
)
(
8
,
52
)
(
1
,
52
)
(
1
,
52
)
(
2
,
52
)
(
11
,
52
)
(
7
,
52
)
(
1
,
52
)
(
8
,
52
)
(
3
,
52
)
(
9
,
52
)
(
1
,
52
)
(
2
,
52
)
(
10
,
52
)
(
9
,
52
)
(
9
,
52
)
(
13
,
37
)
(
10
,
52
)
(
0
,
52
)
(
7
,
52
)
(
7
,
52
)
(
0
,
52
)
(
8
,
52
)
(
18
,
52
)
(
2
,
52
)
(
1
,
52
)
(
2
,
52
)
(
10
,
52
)
(
1
,
52
)
(
2
,
52
)
(
8
,
52
)
(
2
,
52
)
(
8
,
52
)
(
2
,
52
)
(
0
,
52
)
(
8
,
52
)
(
7
,
52
)
(
10
,
52
)
(
8
,
52
)
(
1
,
52
)
(
0
,
52
)
(
1
,
52
)
(
4
,
52
)
(
0
,
52
)
(
15
,
52
)
(
15
,
52
)
(
8
,
52
)
(
18
,
52
)
(
5
,
52
)
(
16
,
52
)
(
2
,
52
)
(
0
,
52
)
(
8
,
52
)
(
8
,
52
)
(
2
,
52
)
(
1
,
52
)
(
8
,
52
)
]
[
'amsterdam
'
'anchorag
'
'ankara
'
'athen
'
'atlanta
'
'auckland
'
'barcelona
'
'beirut
'
'berlin
'
'boston
'
'brasilia
'
'brussel
'
'bucharest
'
'budapest
'
'cairo
'
'calgari
'
'cape
town
'
'casablanca
'
'chicago
'
'columbu
'
'copenhagen
'
'dalla
'
'denver
'
'detroit
'
'dubai
'
'dublin
'
'edmonton
'
'frankfurt
'
'halifax
'
'helsinki
'
'houston
'
'indianapoli
'
'istanbul
'
'jerusalem
'
'johannesburg
'
'kathmandu
'
'kuwait
citi
'
'la
vega
'
'lisbon
'
'london
'
'lo
angel
'
'madrid
'
'melbourn
'
'miami
'
'minneapoli
'
'montreal
'
'moscow
'
'new
orlean
'
'new
york
'
'oslo
'
'ottawa
'
'pari
'
'philadelphia
'
'phoenix
'
'pragu
'
'reykjavik
'
'riyadh
'
'rome
'
'salt
lake
citi
'
'san
francisco
'
'san
salvador
'
'santiago
'
'seattl
'
'shanghai
'
'singapor
'
'stockholm
'
'sydney
'
'são
paulo
'
'tokyo
'
'toronto
'
'vancouv
'
'vienna
'
'warsaw
'
'washington
DC
'
'winnipeg
'
'zurich
'
]
the
previou
code
return
the
follow
:
'frankfurt
'
previou
chapter
:
creat
numpi
array
next
chapter
:
numer
oper
on
numpi
array
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

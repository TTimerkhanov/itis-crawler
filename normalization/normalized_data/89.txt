numer
&
scientif
comput
with
python
:
function
to
creat
numpi
array
numer
python
cours
numer
program
numpi
introductioncr
numpi
arraysdata
type
object
,
dtypenumer
oper
on
numpi
arrayschang
the
dimens
of
arrayspython
,
numpi
and
probabilityweight
choic
and
weight
samplescr
of
synthet
test
databoolean
mask
of
arraysmatrix
arithmeticread
and
write
ndarraysmatplotlib
introductionspin
and
tickslegend
and
annotationsmultipl
figur
and
axeshistogramscontour
plotspython
imag
process
tutorialimag
process
techniquespanda
tutorialpanda
dataframespanda
data
filesd
with
nanbin
datapanda
tutori
continu
:
multi-level
indexingdata
visual
with
panda
and
pythonpython
,
date
and
timepython
,
panda
and
timeserieslinear
combin
python
In
greek
mytholog
,
python
is
the
name
of
a
a
huge
serpent
and
sometim
a
dragon
.
python
had
been
kill
by
the
god
apollo
at
delphi
.
python
wa
creat
out
of
the
slime
and
mud
left
after
the
great
flood
.
He
wa
appoint
by
gaia
(
mother
earth
)
to
guard
the
oracl
of
delphi
,
known
as
pytho
.
the
program
languag
python
ha
not
been
creat
out
of
slime
and
mud
but
out
of
the
program
languag
abc
.
It
ha
been
devis
by
a
dutch
programm
,
name
guido
van
rossum
,
in
amsterdam
.
origin
of
python
guido
van
rossum
wrote
the
follow
about
the
origin
of
python
in
a
foreword
for
the
book
``
program
python
''
by
mark
lutz
in
1996
:
``
over
six
year
ago
,
in
decemb
1989
,
I
wa
look
for
a
``
hobbi
''
program
project
that
would
keep
me
occupi
dure
the
week
around
christma
.
My
offic
(
a
government-run
research
lab
in
amsterdam
)
would
be
close
,
but
I
had
a
home
comput
,
and
not
much
els
on
my
hand
.
I
decid
to
write
an
interpret
for
the
new
script
languag
I
had
been
think
about
late
:
a
descend
of
abc
that
would
appeal
to
unix/c
hacker
.
I
chose
python
as
a
work
titl
for
the
project
,
be
in
a
slightli
irrever
mood
(
and
a
big
fan
of
monti
python
's
fli
circu
)
.
''
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
funktionen
zur
erzeugung
von
numpi
arraysclassroom
train
cours
thi
websit
contain
a
free
and
extens
onlin
tutori
by
bernd
klein
,
use
materi
from
hi
classroom
python
train
cours
.
If
you
are
interest
in
an
instructor-l
classroom
train
cours
,
you
may
have
a
look
at
the
python
class
by
bernd
klein
at
bodenseo
.
©
kabliczech
-
fotolia.com
quot
of
the
day
:
''
I
think
it
is
inevit
that
peopl
program
poorli
.
train
will
not
substanti
help
matter
.
We
have
to
learn
to
live
with
it
.
''
(
alan
perli
)
If
you
have
the
choic
work
with
python
2
or
python
3
,
we
recomend
to
switch
to
python
3
!
you
can
read
our
python
tutori
to
see
what
the
differ
are
.
data
protect
declar
data
protect
declar
previou
chapter
:
numpi
introduct
next
chapter
:
data
type
object
,
dtype
numpi
tutori
:
creat
array
We
have
alreday
seen
in
the
previou
chapter
of
our
numpi
tutori
that
we
can
creat
numpi
array
from
list
and
tupl
.
We
want
to
introduc
now
further
function
for
creat
basic
array
.
there
are
function
provid
by
numpi
to
creat
array
with
evenli
space
valu
within
a
given
interv
.
one
'arang
'
use
a
given
distanc
and
the
other
one
'linspac
'
need
the
number
of
element
and
creat
the
distanc
automat
.
creation
of
array
with
evenli
space
valu
arangeth
syntax
of
arang
:
arang
(
[
start
,
]
stop
[
,
step
]
,
[
,
dtype=non
]
)
arang
return
evenli
space
valu
within
a
given
interv
.
the
valu
are
gener
within
the
half-open
interv
'
[
start
,
stop
)
'
If
the
function
is
use
with
integ
,
it
is
nearli
equival
to
the
python
built-in
function
rang
,
but
arang
return
an
ndarray
rather
than
a
list
iter
as
rang
doe
.
If
the
'start
'
paramet
is
not
given
,
it
will
be
set
to
0
.
the
end
of
the
interv
is
determin
by
the
paramet
'stop
'
.
usual
,
the
interv
will
not
includ
thi
valu
,
except
in
some
case
where
'step
'
is
not
an
integ
and
float
point
round-off
affect
the
length
of
output
ndarray
.
the
space
between
two
adjac
valu
of
the
output
array
is
set
with
the
option
paramet
'step
'
.
the
default
valu
for
'step
'
is
1
.
If
the
paramet
'step
'
is
given
,
the
'start
'
paramet
can
not
be
option
,
i.e
.
it
ha
to
be
given
as
well
.
the
type
of
the
output
array
can
be
specifi
with
the
paramet
'dtype
'
.
If
it
is
not
given
,
the
type
will
be
automat
infer
from
the
other
input
argument
.
import
numpi
as
np
a
=
np.arang
(
1
,
10
)
print
(
a
)
x
=
rang
(
1
,
10
)
print
(
x
)
#
x
is
an
iter
print
(
list
(
x
)
)
#
further
arang
exampl
:
x
=
np.arang
(
10.4
)
print
(
x
)
x
=
np.arang
(
0.5
,
10.4
,
0.8
)
print
(
x
)
x
=
np.arang
(
0.5
,
10.4
,
0.8
,
int
)
print
(
x
)
[
1
2
3
4
5
6
7
8
9
]
rang
(
1
,
10
)
[
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
]
[
0
.
1
.
2
.
3
.
4
.
5
.
6
.
7
.
8
.
9
.
10
.
]
[
0.5
1.3
2.1
2.9
3.7
4.5
5.3
6.1
6.9
7.7
8.5
9.3
10.1
]
[
0
1
2
3
4
5
6
7
8
9
10
11
12
]
linspaceth
syntax
of
linspac
:
linspac
(
start
,
stop
,
num=50
,
endpoint=tru
,
retstep=fals
)
linspac
return
an
ndarray
,
consist
of
'num
'
equal
space
sampl
in
the
close
interv
[
start
,
stop
]
or
the
half-open
interv
[
start
,
stop
)
.
If
a
close
or
a
half-open
interv
will
be
return
,
depend
on
whether
'endpoint
'
is
true
or
fals
.
the
paramet
'start
'
defin
the
start
valu
of
the
sequenc
which
will
be
creat
.
'stop
'
will
the
end
valu
of
the
sequenc
,
unless
'endpoint
'
is
set
to
fals
.
In
the
latter
case
,
the
result
sequenc
will
consist
of
all
but
the
last
of
'num
+
1
'
evenli
space
sampl
.
thi
mean
that
'stop
'
is
exclud
.
note
that
the
step
size
chang
when
'endpoint
'
is
fals
.
the
number
of
sampl
to
be
gener
can
be
set
with
'num
'
,
which
default
to
50
.
If
the
option
paramet
'endpoint
'
is
set
to
true
(
the
default
)
,
'stop
'
will
be
the
last
sampl
of
the
sequenc
.
otherwis
,
it
is
not
includ
.
import
numpi
as
np
#
50
valu
between
1
and
10
:
print
(
np.linspac
(
1
,
10
)
)
#
7
valu
between
1
and
10
:
print
(
np.linspac
(
1
,
10
,
7
)
)
#
exclud
the
endpoint
:
print
(
np.linspac
(
1
,
10
,
7
,
endpoint=fals
)
)
[
1
.
1.18367347
1.36734694
1.55102041
1.73469388
1.91836735
2.10204082
2.28571429
2.46938776
2.65306122
2.83673469
3.02040816
3.20408163
3.3877551
3.57142857
3.75510204
3.93877551
4.12244898
4.30612245
4.48979592
4.67346939
4.85714286
5.04081633
5.2244898
5.40816327
5.59183673
5.7755102
5.95918367
6.14285714
6.32653061
6.51020408
6.69387755
6.87755102
7.06122449
7.24489796
7.42857143
7.6122449
7.79591837
7.97959184
8.16326531
8.34693878
8.53061224
8.71428571
8.89795918
9.08163265
9.26530612
9.44897959
9.63265306
9.81632653
10
.
]
[
1
.
2.5
4
.
5.5
7
.
8.5
10
.
]
[
1
.
2.28571429
3.57142857
4.85714286
6.14285714
7.42857143
8.71428571
]
We
have
n't
discuss
one
interest
paramet
so
far
.
If
the
option
paramet
'retstep
'
is
set
,
the
function
will
also
return
the
valu
of
the
space
between
adjac
valu
.
So
,
the
function
will
return
a
tupl
(
'sampl
'
,
'step
'
)
:
import
numpi
as
np
sampl
,
space
=
np.linspac
(
1
,
10
,
retstep=tru
)
print
(
space
)
sampl
,
space
=
np.linspac
(
1
,
10
,
20
,
endpoint=tru
,
retstep=tru
)
print
(
space
)
sampl
,
space
=
np.linspac
(
1
,
10
,
20
,
endpoint=fals
,
retstep=tru
)
print
(
space
)
0.183673469388
0.473684210526
0.45
zero-dimension
array
in
numpi
It
's
possibl
to
creat
multidimension
array
in
numpi
.
scalar
are
zero
dimension
.
In
the
follow
exampl
,
we
will
creat
the
scalar
42
.
appli
the
ndim
method
to
our
scalar
,
we
get
the
dimens
of
the
array
.
We
can
also
see
that
the
type
is
a
``
numpy.ndarray
''
type
.
import
numpi
as
np
x
=
np.array
(
42
)
print
(
``
x
:
``
,
x
)
print
(
``
the
type
of
x
:
``
,
type
(
x
)
)
print
(
``
the
dimens
of
x
:
''
,
np.ndim
(
x
)
)
x
:
42
the
type
of
x
:
<
class
'numpy.ndarray
'
>
the
dimens
of
x
:
0
one-dimension
array
We
have
alreadi
encount
a
1-dimenion
array
-
better
known
to
some
as
vector
-
in
our
initi
exampl
.
what
we
have
not
mention
so
far
,
but
what
you
may
have
assum
,
is
the
fact
that
numpi
array
are
contain
of
item
of
the
same
type
,
e.g
.
onli
integ
.
the
homogen
type
of
the
array
can
be
determin
with
the
attribut
``
dtype
''
,
as
we
can
learn
from
the
follow
exampl
:
F
=
np.array
(
[
1
,
1
,
2
,
3
,
5
,
8
,
13
,
21
]
)
V
=
np.array
(
[
3.4
,
6.9
,
99.8
,
12.8
]
)
print
(
``
F
:
``
,
F
)
print
(
``
V
:
``
,
V
)
print
(
``
type
of
F
:
``
,
f.dtype
)
print
(
``
type
of
V
:
``
,
v.dtype
)
print
(
``
dimens
of
F
:
``
,
np.ndim
(
F
)
)
print
(
``
dimens
of
V
:
``
,
np.ndim
(
V
)
)
F
:
[
1
1
2
3
5
8
13
21
]
V
:
[
3.4
6.9
99.8
12.8
]
type
of
F
:
int64
type
of
V
:
float64
dimens
of
F
:
1
dimens
of
V
:
1
two-
and
multidimension
array
Of
cours
,
array
of
numpi
are
not
limit
to
one
dimens
.
they
are
of
arbitrari
dimens
.
We
creat
them
by
pass
nest
list
(
or
tupl
)
to
the
array
method
of
numpi
.
A
=
np.array
(
[
[
3.4
,
8.7
,
9.9
]
,
[
1.1
,
-7.8
,
-0.7
]
,
[
4.1
,
12.3
,
4.8
]
]
)
print
(
A
)
print
(
a.ndim
)
[
[
3.4
8.7
9.9
]
[
1.1
-7.8
-0.7
]
[
4.1
12.3
4.8
]
]
2
B
=
np.array
(
[
[
[
111
,
112
]
,
[
121
,
122
]
]
,
[
[
211
,
212
]
,
[
221
,
222
]
]
,
[
[
311
,
312
]
,
[
321
,
322
]
]
]
)
print
(
B
)
print
(
b.ndim
)
[
[
[
111
112
]
[
121
122
]
]
[
[
211
212
]
[
221
222
]
]
[
[
311
312
]
[
321
322
]
]
]
3
shape
of
an
array
the
function
``
shape
''
return
the
shape
of
an
array
.
the
shape
is
a
tupl
of
integ
.
these
number
denot
the
length
of
the
correspond
array
dimens
.
In
other
word
:
the
``
shape
''
of
an
array
is
a
tupl
with
the
number
of
element
per
axi
(
dimens
)
.
In
our
exampl
,
the
shape
is
equal
to
(
6
,
3
)
,
i.e
.
we
have
6
line
and
3
column
.
x
=
np.array
(
[
[
67
,
63
,
87
]
,
[
77
,
69
,
59
]
,
[
85
,
87
,
99
]
,
[
79
,
72
,
71
]
,
[
63
,
89
,
93
]
,
[
68
,
92
,
78
]
]
)
print
(
np.shape
(
x
)
)
(
6
,
3
)
there
is
also
an
equival
array
properti
:
print
(
x.shape
)
(
6
,
3
)
the
shape
of
an
array
tell
us
also
someth
about
the
order
in
which
the
indic
are
process
,
i.e
.
first
row
,
then
column
and
after
that
the
further
dimens
.
``
shape
''
can
also
be
use
to
chang
the
shape
of
an
array
.
x.shape
=
(
3
,
6
)
print
(
x
)
[
[
67
63
87
77
69
59
]
[
85
87
99
79
72
71
]
[
63
89
93
68
92
78
]
]
x.shape
=
(
2
,
9
)
print
(
x
)
[
[
67
63
87
77
69
59
85
87
99
]
[
79
72
71
63
89
93
68
92
78
]
]
you
might
have
guess
by
now
that
the
new
shape
must
correspond
to
the
number
of
element
of
the
array
,
i.e
.
the
total
size
of
the
new
array
must
be
the
same
as
the
old
one
.
We
will
rais
an
except
,
if
thi
is
not
the
case
.
let
's
look
at
some
further
exampl
.
the
shape
of
a
scalar
is
an
empti
tupl
:
x
=
np.array
(
11
)
print
(
np.shape
(
x
)
)
(
)
B
=
np.array
(
[
[
[
111
,
112
,
113
]
,
[
121
,
122
,
123
]
]
,
[
[
211
,
212
,
213
]
,
[
221
,
222
,
223
]
]
,
[
[
311
,
312
,
313
]
,
[
321
,
322
,
323
]
]
,
[
[
411
,
412
,
413
]
,
[
421
,
422
,
423
]
]
]
)
print
(
b.shape
)
(
4
,
2
,
3
)
index
and
slice
assign
to
and
access
the
element
of
an
array
is
similar
to
other
sequenti
data
type
of
python
,
i.e
.
list
and
tupl
.
We
have
also
mani
option
to
index
,
which
make
index
in
numpi
veri
power
and
similar
to
the
index
of
list
and
tupl
.
singl
index
behav
the
way
,
you
will
most
probabl
expect
it
:
F
=
np.array
(
[
1
,
1
,
2
,
3
,
5
,
8
,
13
,
21
]
)
#
print
the
first
element
of
F
print
(
F
[
0
]
)
#
print
the
last
element
of
F
print
(
F
[
-1
]
)
1
21
index
multidimension
array
:
A
=
np.array
(
[
[
3.4
,
8.7
,
9.9
]
,
[
1.1
,
-7.8
,
-0.7
]
,
[
4.1
,
12.3
,
4.8
]
]
)
print
(
A
[
1
]
[
0
]
)
1.1
We
access
an
element
in
the
second
row
,
i.e
.
the
row
with
the
index
1
,
and
the
first
column
(
index
0
)
.
We
access
it
the
same
way
,
we
would
have
done
with
an
element
of
a
nest
python
list
.
you
have
to
be
awar
of
the
fact
,
that
way
of
access
multi-dimension
array
can
be
highli
ineffici
.
the
reason
is
that
we
creat
an
intermedi
array
A
[
1
]
from
which
we
access
the
element
with
the
index
0
.
So
it
behav
similar
to
thi
:
tmp
=
A
[
1
]
print
(
tmp
)
print
(
tmp
[
0
]
)
[
1.1
-7.8
-0.7
]
1.1
there
is
anoth
way
to
access
element
of
multi-dimension
array
in
numpi
:
We
use
onli
one
pair
of
squar
bracket
and
all
the
indic
are
separ
by
comma
:
print
(
A
[
1
,
0
]
)
1.1
We
assum
that
you
are
familar
with
the
slice
of
list
and
tupl
.
the
syntax
is
the
same
in
numpi
for
one-dimension
array
,
but
it
can
be
appli
to
multipl
dimens
as
well
.
the
gener
syntax
for
a
one-dimension
array
A
look
like
thi
:
A
[
start
:
stop
:
step
]
We
illustr
the
oper
principl
of
``
slice
''
with
some
exampl
.
We
start
with
the
easiest
case
,
i.e
.
the
slice
of
a
one-dimension
array
:
S
=
np.array
(
[
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
]
)
print
(
S
[
2:5
]
)
print
(
S
[
:4
]
)
print
(
S
[
6
:
]
)
print
(
S
[
:
]
)
[
2
3
4
]
[
0
1
2
3
]
[
6
7
8
9
]
[
0
1
2
3
4
5
6
7
8
9
]
We
will
illustr
the
multidimension
slice
in
the
follow
exampl
.
the
rang
for
each
dimens
are
separ
by
comma
:
A
=
np.array
(
[
[
11
,
12
,
13
,
14
,
15
]
,
[
21
,
22
,
23
,
24
,
25
]
,
[
31
,
32
,
33
,
34
,
35
]
,
[
41
,
42
,
43
,
44
,
45
]
,
[
51
,
52
,
53
,
54
,
55
]
]
)
print
(
A
[
:3
,
2
:
]
)
[
[
13
14
15
]
[
23
24
25
]
[
33
34
35
]
]
print
(
A
[
3
:
,
:
]
)
[
[
41
42
43
44
45
]
[
51
52
53
54
55
]
]
print
(
A
[
:
,
4
:
]
)
[
[
15
]
[
25
]
[
35
]
[
45
]
[
55
]
]
the
follow
two
exampl
use
the
third
paramet
``
step
''
.
the
reshap
function
is
use
to
construct
the
two-dimension
array
.
We
will
explain
reshap
in
the
follow
subchapt
:
X
=
np.arang
(
28
)
.reshap
(
4
,
7
)
print
(
X
)
[
[
0
1
2
3
4
5
6
]
[
7
8
9
10
11
12
13
]
[
14
15
16
17
18
19
20
]
[
21
22
23
24
25
26
27
]
]
print
(
X
[
:
:2
,
:
:3
]
)
[
[
0
3
6
]
[
14
17
20
]
]
print
(
X
[
:
:
,
:
:3
]
)
[
[
0
3
6
]
[
7
10
13
]
[
14
17
20
]
[
21
24
27
]
]
If
the
number
of
object
in
the
select
tupl
is
less
than
the
dimens
N
,
then
:
is
assum
for
ani
subsequ
dimens
:
A
=
np.array
(
[
[
[
45
,
12
,
4
]
,
[
45
,
13
,
5
]
,
[
46
,
12
,
6
]
]
,
[
[
46
,
14
,
4
]
,
[
45
,
14
,
5
]
,
[
46
,
11
,
5
]
]
,
[
[
47
,
13
,
2
]
,
[
48
,
15
,
5
]
,
[
52
,
15
,
1
]
]
]
)
A
[
1:3
,
0:2
]
#
equival
to
A
[
1:3
,
0:2
,
:
]
the
abov
code
return
the
follow
output
:
array
(
[
[
[
46
,
14
,
4
]
,
[
45
,
14
,
5
]
]
,
[
[
47
,
13
,
2
]
,
[
48
,
15
,
5
]
]
]
)
attent
:
wherea
slice
on
list
and
tupl
creat
new
object
,
a
slice
oper
on
an
array
creat
a
view
on
the
origin
array
.
So
we
get
an
anoth
possibl
to
access
the
array
,
or
better
a
part
of
the
array
.
from
thi
follow
that
if
we
modifi
a
view
,
the
origin
array
will
be
modifi
as
well
.
A
=
np.array
(
[
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
]
)
S
=
A
[
2:6
]
S
[
0
]
=
22
S
[
1
]
=
23
print
(
A
)
[
0
1
22
23
4
5
6
7
8
9
]
do
the
similar
thing
with
list
,
we
can
see
that
we
get
a
copi
:
lst
=
[
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
]
lst2
=
lst
[
2:6
]
lst2
[
0
]
=
22
lst2
[
1
]
=
23
print
(
lst
)
[
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
]
If
you
want
to
check
,
if
two
array
name
share
the
same
memori
block
,
you
can
use
the
function
np.may_share_memori
.
np.may_share_memori
(
A
,
B
)
To
determin
if
two
array
A
and
B
can
share
memori
the
memory-bound
of
A
and
B
are
comput
.
the
function
return
true
,
if
they
overlap
and
fals
otherwis
.
the
function
may
give
fals
posit
,
i.e
.
if
it
return
true
it
just
mean
that
the
array
may
be
the
same
.
np.may_share_memori
(
A
,
S
)
after
have
execut
the
python
code
abov
we
receiv
the
follow
output
:
true
the
follow
code
show
a
case
,
in
which
the
use
of
may_share_memori
is
quit
use
:
A
=
np.arang
(
12
)
B
=
a.reshap
(
3
,
4
)
A
[
0
]
=
42
print
(
B
)
[
[
42
1
2
3
]
[
4
5
6
7
]
[
8
9
10
11
]
]
We
can
see
that
A
and
B
share
the
memori
in
some
way
.
the
array
attribut
``
data
''
is
an
object
pointer
to
the
start
of
an
array
's
data
.
but
we
saw
that
if
we
chang
an
element
of
one
array
the
other
one
is
chang
as
well
.
thi
fact
is
reflect
by
may_share_memori
:
np.may_share_memori
(
A
,
B
)
the
previou
python
code
return
the
follow
:
true
the
result
abov
is
``
fals
posit
''
exampl
for
may_share_memori
in
the
sens
that
somebodi
may
think
that
the
array
are
the
same
,
which
is
not
the
case
.
creat
array
with
one
,
zero
and
empti
there
are
two
way
of
initi
array
with
zero
or
one
.
the
method
one
(
t
)
take
a
tupl
t
with
the
shape
of
the
array
and
fill
the
array
accordingli
with
one
.
By
default
it
will
be
fill
with
one
of
type
float
.
If
you
need
integ
one
,
you
have
to
set
the
option
paramet
dtype
to
int
:
import
numpi
as
np
E
=
np.one
(
(
2,3
)
)
print
(
E
)
F
=
np.one
(
(
3,4
)
,
dtype=int
)
print
(
F
)
[
[
1
.
1
.
1
.
]
[
1
.
1
.
1
.
]
]
[
[
1
1
1
1
]
[
1
1
1
1
]
[
1
1
1
1
]
]
what
we
have
said
about
the
method
one
(
)
is
valid
for
the
method
zero
(
)
analog
,
as
we
can
see
in
the
follow
exampl
:
Z
=
np.zero
(
(
2,4
)
)
print
(
Z
)
[
[
0
.
0
.
0
.
0
.
]
[
0
.
0
.
0
.
0
.
]
]
there
is
anoth
interest
way
to
creat
an
array
with
one
or
with
zero
,
if
it
ha
to
have
the
same
shape
as
anoth
exist
array
'
a
'
.
numpi
suppli
for
thi
purpos
the
method
ones_lik
(
a
)
and
zeros_lik
(
a
)
.
x
=
np.array
(
[
2,5,18,14,4
]
)
E
=
np.ones_lik
(
x
)
print
(
E
)
Z
=
np.zeros_lik
(
x
)
print
(
Z
)
[
1
1
1
1
1
]
[
0
0
0
0
0
]
there
is
also
a
way
of
creat
an
array
with
the
empti
function
.
It
creat
and
return
a
refer
to
a
new
array
of
given
shape
and
type
,
without
initi
the
entri
.
sometim
the
entri
are
zero
,
but
you
should
n't
be
mislead
.
usual
,
they
are
arbitrari
valu
.
np.empti
(
(
2
,
4
)
)
thi
get
us
the
follow
output
:
array
(
[
[
0.
,
0.
,
0.
,
0
.
]
,
[
0.
,
0.
,
0.
,
0
.
]
]
)
copi
array
numpy.copi
(
)
copi
(
obj
,
order=
'
K
'
)
return
an
array
copi
of
the
given
object
'obj
'
.
paramet
mean
obj
array_lik
input
data
.
order
the
possibl
valu
are
{
'
C
'
,
'
F
'
,
'
A
'
,
'
K
'
}
.
thi
paramet
control
the
memori
layout
of
the
copi
.
'
C
'
mean
c-order
,
'
F
'
mean
fortran-ord
,
'
A
'
mean
'
F
'
if
the
object
'obj
'
is
fortran
contigu
,
'
C
'
otherwis
.
'
K
'
mean
match
the
layout
of
'obj
'
as
close
as
possibl
.
import
numpi
as
np
x
=
np.array
(
[
[
42,22,12
]
,
[
44,53,66
]
]
,
order=
'
F
'
)
y
=
x.copi
(
)
x
[
0,0
]
=
1001
print
(
x
)
print
(
y
)
[
[
1001
22
12
]
[
44
53
66
]
]
[
[
42
22
12
]
[
44
53
66
]
]
print
(
x.flag
[
'c_contigu
'
]
)
print
(
y.flag
[
'c_contigu
'
]
)
fals
true
ndarray.copi
(
)
there
is
also
a
ndarray
method
'copi
'
,
which
can
be
directli
appli
to
an
array
.
It
is
similiar
to
the
abov
function
,
but
the
default
valu
for
the
order
argument
are
differ
.
a.copi
(
order=
'
C
'
)
return
a
copi
of
the
array
'
a
'
.
paramet
mean
order
the
same
as
with
numpy.copi
,
but
'
C
'
is
the
default
valu
for
order
.
import
numpi
as
np
x
=
np.array
(
[
[
42,22,12
]
,
[
44,53,66
]
]
,
order=
'
F
'
)
y
=
x.copi
(
)
x
[
0,0
]
=
1001
print
(
x
)
print
(
y
)
print
(
x.flag
[
'c_contigu
'
]
)
print
(
y.flag
[
'c_contigu
'
]
)
[
[
1001
22
12
]
[
44
53
66
]
]
[
[
42
22
12
]
[
44
53
66
]
]
fals
true
ident
array
In
linear
algebra
,
the
ident
matrix
,
or
unit
matrix
,
of
size
n
is
the
n
×
n
squar
matrix
with
one
on
the
main
diagon
and
zero
elsewher
.
there
are
two
way
in
numpi
to
creat
ident
array
:
identi
eye
the
ident
function
We
can
creat
ident
array
with
the
function
ident
:
ident
(
n
,
dtype=non
)
the
paramet
:
paramet
mean
n
An
integ
number
defin
the
number
of
row
and
column
of
the
output
,
i.e
.
'
n
'
x
'
n
'
dtype
An
option
argument
,
defin
the
data-typ
of
the
output
.
the
default
is
'float
'
the
output
of
ident
is
an
'
n
'
x
'
n
'
array
with
it
main
diagon
set
to
one
,
and
all
other
element
are
0.
import
numpi
as
np
np.ident
(
4
)
We
receiv
the
follow
output
:
array
(
[
[
1.
,
0.
,
0.
,
0
.
]
,
[
0.
,
1.
,
0.
,
0
.
]
,
[
0.
,
0.
,
1.
,
0
.
]
,
[
0.
,
0.
,
0.
,
1
.
]
]
)
np.ident
(
4
,
dtype=int
)
#
equival
to
np.ident
(
3
,
int
)
the
previou
python
code
return
the
follow
result
:
array
(
[
[
1
,
0
,
0
,
0
]
,
[
0
,
1
,
0
,
0
]
,
[
0
,
0
,
1
,
0
]
,
[
0
,
0
,
0
,
1
]
]
)
the
eye
function
anoth
way
to
creat
ident
array
provid
the
function
eye
.
thi
function
creat
also
diagon
array
consist
sole
of
one
.
It
return
a
2-d
array
with
one
on
the
diagon
and
zero
elsewher
.
eye
(
N
,
m=none
,
k=0
,
dtype=float
)
paramet
mean
N
An
integ
number
defin
the
row
of
the
output
array
.
M
An
option
integ
for
set
the
number
of
column
in
the
output
.
If
it
is
none
,
it
default
to
'
N
'
.
k
defin
the
posit
of
the
diagon
.
the
default
is
0
.
0
refer
to
the
main
diagon
.
A
posit
valu
refer
to
an
upper
diagon
,
and
a
neg
valu
to
a
lower
diagon
.
dtype
option
data-typ
of
the
return
array
.
eye
return
an
ndarray
of
shape
(
N
,
M
)
.
all
element
of
thi
array
are
equal
to
zero
,
except
for
the
'
k'-th
diagon
,
whose
valu
are
equal
to
one
.
import
numpi
as
np
np.ey
(
5
,
8
,
k=1
,
dtype=int
)
thi
get
us
the
follow
result
:
array
(
[
[
0
,
1
,
0
,
0
,
0
,
0
,
0
,
0
]
,
[
0
,
0
,
1
,
0
,
0
,
0
,
0
,
0
]
,
[
0
,
0
,
0
,
1
,
0
,
0
,
0
,
0
]
,
[
0
,
0
,
0
,
0
,
1
,
0
,
0
,
0
]
,
[
0
,
0
,
0
,
0
,
0
,
1
,
0
,
0
]
]
)
the
principl
of
oper
of
the
paramet
'd
'
of
the
eye
function
is
illustr
in
the
follow
diagram
:
exercises:1
)
creat
an
arbitrari
one
dimension
array
call
``
v
''
.
2
)
creat
a
new
array
which
consist
of
the
odd
indic
of
previous
creat
array
``
v
''
.
3
)
creat
a
new
array
in
backward
order
from
v.
4
)
what
will
be
the
output
of
the
follow
code
:
a
=
np.array
(
[
1
,
2
,
3
,
4
,
5
]
)
b
=
a
[
1:4
]
b
[
0
]
=
200
print
(
a
[
1
]
)
5
)
creat
a
two
dimension
array
call
``
m
''
.
6
)
creat
a
new
array
from
m
,
in
which
the
element
of
each
row
are
in
revers
order
.
7
)
anoth
one
,
where
the
row
are
in
revers
order
.
8
)
creat
an
array
from
m
,
where
column
and
row
are
in
revers
order
.
9
)
cut
of
the
first
and
last
row
and
the
first
and
last
column
.
solut
to
the
exercis
:
1
)
import
numpi
as
np
a
=
np.array
(
[
3,8,12,18,7,11,30
]
)
2
)
odd_el
=
a
[
1
:
:2
]
3
)
reverse_ord
=
a
[
:
:-1
]
4
)
the
output
will
be
200
,
becaus
slice
are
view
in
numpi
and
not
copi
.
5
)
m
=
np.array
(
[
[
11
,
12
,
13
,
14
]
,
[
21
,
22
,
23
,
24
]
,
[
31
,
32
,
33
,
34
]
]
)
6
)
m
[
:
:
,
:
:
-1
]
7
)
m
[
:
:-1
]
8
)
m
[
:
:-1
,
:
:
-1
]
9
)
m
[
1
:
-1,1
:
-1
]
previou
chapter
:
numpi
introduct
next
chapter
:
data
type
object
,
dtype
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

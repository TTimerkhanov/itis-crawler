numer
&
scientif
comput
with
python
:
weight
choic
and
sampl
numer
python
cours
numer
program
numpi
introductioncr
numpi
arraysdata
type
object
,
dtypenumer
oper
on
numpi
arrayschang
the
dimens
of
arrayspython
,
numpi
and
probabilityweight
choic
and
weight
samplescr
of
synthet
test
databoolean
mask
of
arraysmatrix
arithmeticread
and
write
ndarraysmatplotlib
introductionspin
and
tickslegend
and
annotationsmultipl
figur
and
axeshistogramscontour
plotspython
imag
process
tutorialimag
process
techniquespanda
tutorialpanda
dataframespanda
data
filesd
with
nanbin
datapanda
tutori
continu
:
multi-level
indexingdata
visual
with
panda
and
pythonpython
,
date
and
timepython
,
panda
and
timeserieslinear
combin
probabl
probabl
is
the
measur
of
the
likelihood
that
an
event
will
occur
.
you
can
also
say
,
the
probabl
of
an
event
is
the
measur
of
the
chanc
that
the
event
will
occur
as
a
result
of
an
experi
.
the
probabl
that
a
an
event
will
occur
is
usual
express
as
a
number
between
0
and
1
.
sometim
percentag
valu
between
0
and
100
%
are
also
use
.
0
mean
that
the
event
can
not
occur
and
1
stand
for
the
certainti
that
the
event
will
(
alway
)
occur
.
the
exampl
,
you
will
find
in
nearli
everi
textbook
on
probabl
is
the
toss
of
a
fair
(
unbias
)
coin
.
the
probabl
of
``
head
''
is
the
same
as
the
probabl
of
``
tail
''
.
thi
mean
that
the
probabl
is
0.5
(
or
50
%
)
for
both
``
head
''
and
``
tail
''
.
the
probabl
of
an
event
A
is
the
number
of
way
event
A
can
occur
divid
by
the
total
number
of
possibl
outcom
.
thi
websit
is
creat
by
:
python
train
cours
in
toronto
,
canada
On
site
train
in
europ
,
canada
and
the
US
.
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
classroom
train
cours
thi
websit
contain
a
free
and
extens
onlin
tutori
by
bernd
klein
,
use
materi
from
hi
classroom
python
train
cours
.
If
you
are
interest
in
an
instructor-l
classroom
train
cours
,
you
may
have
a
look
at
the
python
class
by
bernd
klein
at
bodenseo
.
©
kabliczech
-
fotolia.com
quot
of
the
day
:
''
Do
n't
have
good
idea
if
you
are
n't
will
to
be
respons
for
them.
``
(
alan
perli
)
If
you
have
the
choic
work
with
python
2
or
python
3
,
we
recomend
to
switch
to
python
3
!
you
can
read
our
python
tutori
to
see
what
the
differ
are
.
data
protect
declar
data
protect
declar
previou
chapter
:
python
,
numpi
and
probabl
next
chapter
:
creation
of
synthet
test
data
weight
probabl
introduct
In
our
previou
chapter
we
had
a
look
at
the
follow
exampl
:
from
random
import
choic
print
(
choic
(
``
abcdefghij
''
)
)
profess
=
[
``
scientist
''
,
``
philosoph
''
,
``
engin
''
,
``
priest
''
]
print
(
choic
(
profess
)
)
print
(
choic
(
(
``
beginn
''
,
``
intermedi
''
,
``
advanc
''
)
)
)
i
philosoph
beginn
'choic
'
return
an
object
from
a
sequenc
.
the
chanc
for
the
element
of
the
sequenc
to
be
chosen
are
evenli
distribut
.
So
the
chanc
for
get
a
'scientist
'
as
a
return
valu
of
the
call
choic
(
profess
)
is
1/4
.
thi
is
out
of
touch
with
realiti
.
there
are
sure
more
scientist
and
engin
in
the
world
than
there
are
priest
and
philosoph
.
just
like
with
the
load
die
,
we
have
again
the
need
of
a
weighte-d
choic
.
We
will
devis
a
function
``
weighted_choic
''
,
which
return
a
random
element
from
a
sequenc
like
random.choic
,
but
the
element
of
the
sequenc
are
weight
.
random
intervalsbefor
we
can
start
with
the
design
of
the
weight
version
of
choic
,
we
will
defin
a
function
find_interv
(
x
,
partit
)
.
We
will
need
thi
function
in
weighted_choic
.
the
find_interv
function
take
two
argument
:
a
numer
valu
x
a
list
or
a
tupl
of
numer
valu
p0
,
p1
,
p2
,
...
pn
the
function
will
return
i
,
if
pi
<
x
<
pi+1
.
-1
will
be
return
,
if
x
is
less
than
p0
or
if
x
is
greater
or
equal
than
pn
def
find_interv
(
x
,
partit
)
:
``
''
''
find_interv
-
>
i
partit
is
a
sequenc
of
numer
valu
x
is
a
numer
valu
the
return
valu
``
i
''
will
be
the
index
for
which
appli
partit
[
i
]
<
x
<
partit
[
i+1
]
,
if
such
an
index
exist
.
-1
otherwis
``
''
''
for
i
in
rang
(
0
,
len
(
partit
)
)
:
if
x
<
partit
[
i
]
:
return
i-1
return
-1
I
=
[
0
,
3
,
5
,
7.8
,
9
,
12
,
13.8
,
16
]
for
x
in
[
-1.3
,
0
,
0.1
,
3.2
,
5
,
6.2
,
7.9
,
10.8
,
13.9
,
15
,
16
,
16.5
]
:
print
(
find_interv
(
x
,
I
)
,
end=
''
,
``
)
-1
,
0
,
0
,
1
,
2
,
2
,
3
,
4
,
6
,
6
,
-1
,
-1
,
weight
random
choic
We
can
now
defin
the
weight
choic
function
.
let
's
assum
that
you
have
three
weight
,
e.g
.
1/5
,
1/2
,
3/10
.
We
can
build
the
cumul
sum
of
the
weight
with
np.cumsum
(
weight
)
.
import
numpi
as
np
weight
=
[
0.2
,
0.5
,
0.3
]
cum_weight
=
[
0
]
+
list
(
np.cumsum
(
weight
)
)
print
(
cum_weight
)
[
0
,
0.20000000000000001
,
0.69999999999999996
,
1.0
]
If
we
creat
a
random
number
x
between
0
and
1
by
use
random.random
(
)
,
the
probabl
for
x
to
lie
within
the
interv
[
0
,
cum_weight
[
0
]
)
is
equal
to
1/5
.
the
probabl
for
x
to
lie
within
the
interv
[
cum_weight
[
0
]
,
cum_weight
[
1
]
)
is
equal
to
1/2
and
final
,
the
probabl
for
x
to
lie
within
the
interv
[
cum_weight
[
1
]
,
cum_weight
[
2
]
)
is
3/10
.
now
you
are
abl
to
understand
the
basic
idea
of
how
weighted_choic
oper
:
import
numpi
as
np
import
random
def
weighted_choic
(
sequenc
,
weight
,
secure=tru
)
:
``
''
''
weighted_choic
select
a
random
element
of
the
sequenc
accord
to
the
list
of
weight
``
''
''
if
secur
:
crypto
=
random.systemrandom
(
)
x
=
crypto.random
(
)
els
:
x
=
np.random.random
(
)
cum_weight
=
[
0
]
+
list
(
np.cumsum
(
weight
)
)
index
=
find_interv
(
x
,
cum_weight
)
return
sequenc
[
index
]
exampl
:
We
can
use
the
function
weighted_choic
for
the
follow
task
:
suppos
,
we
have
a
``
load
''
die
with
P
(
6
)
=3/12
and
P
(
1
)
=1/12
.
the
probabl
for
the
outcom
of
all
the
other
possibl
is
equal
like
,
i.e
.
P
(
2
)
=
P
(
3
)
=
P
(
4
)
=
P
(
5
)
=
p.
We
can
calcul
p
with
1
-
P
(
1
)
-
P
(
6
)
=
4
x
p
that
mean
p
=
1
/
6
how
can
we
simul
thi
die
with
our
weighted_choic
function
?
We
call
weighted_choic
with
'faces_of_di
'
and
the
'weight
'
list
.
each
call
correspond
to
a
throw
of
the
load
die
.
We
can
show
that
if
we
throw
the
die
a
larg
number
of
time
,
for
exampl
10,000
time
,
we
get
roughli
the
probabl
valu
of
the
weight
:
from
collect
import
counter
faces_of_di
=
[
1
,
2
,
3
,
4
,
5
,
6
]
weight
=
[
1/12
,
1/6
,
1/6
,
1/6
,
1/6
,
3/12
]
outcom
=
[
]
n
=
10000
for
_
in
rang
(
n
)
:
outcomes.append
(
weighted_choic
(
faces_of_di
,
weight
)
)
c
=
counter
(
outcom
)
for
key
in
c
:
c
[
key
]
=
c
[
key
]
/
n
print
(
sort
(
c.valu
(
)
)
)
[
0.0848
,
0.1663
,
0.168
,
0.1682
,
0.1688
,
0.2439
]
So
far
,
the
valu
of
the
partit
list
defin
the
sub-partit
,
in
which
we
expect
the
valu
x
to
be
.
If
the
valu
x
wa
less
than
p0
or
greater
or
equal
than
pn
,
we
return
-1
.
We
could
also
defin
our
first
sub-interv
to
be
the
interv
from
-∞
to
p0
,
and
we
could
return
0
in
thi
case
.
the
last
sub-interv
could
be
correspondingli
pn
to
∞
(
infin
)
.
We
will
extend
our
function
find_interv
with
thi
differ
way
of
interv
map
.
To
distinguish
between
these
two
case
,
we
will
introduc
an
addit
paramet
``
endpoint
''
.
``
true
''
correspond
to
our
first
approach
and
``
fals
''
to
the
previous
describ
``
infin
''
case
.
In
other
word
:
If
we
set
'endpoint
'
to
'fals
'
,
we
will
get
the
follow
behaviour
:
``
i
''
will
be
return
if
x
is
smaller
than
pi
len
(
partit
)
will
be
return
,
if
x
is
larger
or
equal
to
plen
(
partit
)
-1
We
demonstr
thi
in
the
follow
diagram
:
the
new
function
look
like
thi
:
def
find_interv
(
x
,
partit
,
endpoints=tru
)
:
``
''
''
find_interv
-
>
i
If
endpoint
is
true
,
``
i
''
will
be
the
index
for
which
appli
partit
[
i
]
<
x
<
partit
[
i+1
]
,
if
such
an
index
exist
.
-1
otherwis
If
endpoint
is
fals
,
``
i
''
will
be
the
smallest
index
for
which
appli
x
<
partit
[
i
]
.
If
no
such
index
exist
``
i
''
will
be
set
to
len
(
partit
)
``
''
''
for
i
in
rang
(
0
,
len
(
partit
)
)
:
if
x
<
partit
[
i
]
:
return
i-1
if
endpoint
els
i
return
-1
if
endpoint
els
len
(
partit
)
I
=
[
0
,
3
,
5
,
7.8
,
9
,
12
,
13.8
,
16
]
print
(
``
endpoint
are
includ
:
''
)
for
x
in
[
-1.3
,
0
,
0.1
,
3.2
,
5
,
6.2
,
7.9
,
10.8
,
13.9
,
15
,
16
,
16.5
]
:
print
(
find_interv
(
x
,
I
)
,
end=
''
,
``
)
print
(
``
\nendpoint
are
not
includ
:
''
)
for
x
in
[
-1.3
,
0
,
0.1
,
3.2
,
5
,
6.2
,
7.9
,
10.8
,
13.9
,
15
,
16
,
16.5
]
:
print
(
find_interv
(
x
,
I
,
endpoints=fals
)
,
end=
''
,
``
)
endpoint
are
includ
:
-1
,
0
,
0
,
1
,
2
,
2
,
3
,
4
,
6
,
6
,
-1
,
-1
,
endpoint
are
not
includ
:
0
,
1
,
1
,
2
,
3
,
3
,
4
,
5
,
7
,
7
,
8
,
8
,
weight
random
choic
with
numpyto
produc
a
weight
choic
of
an
array
like
object
,
we
can
also
use
the
choic
function
of
the
numpy.random
packag
.
thi
way
,
there
is
no
necess
to
creat
a
custom-mad
function
like
we
did
in
our
previou
chapter
:
from
numpy.random
import
choic
profess
=
[
``
scientist
''
,
``
philosoph
''
,
``
engin
''
,
``
priest
''
,
``
programm
''
]
probabl
=
[
0.2
,
0.05
,
0.3
,
0.15
,
0.3
]
choic
(
profess
,
p=probabl
)
the
code
abov
return
the
follow
:
'engin
'
let
's
experi
with
choic
:
from
collect
import
counter
c
=
counter
(
)
for
_
in
rang
(
1000
)
:
profess
=
choic
(
profess
,
p=probabl
)
c
[
profess
]
+=
1
print
(
c
)
s
=
sum
(
c.valu
(
)
)
for
el
in
c
:
c
[
el
]
/=
s
print
(
c
)
counter
(
{
'programm
'
:
306
,
'engin
'
:
305
,
'scientist
'
:
202
,
'priest
'
:
131
,
'philosoph
'
:
56
}
)
counter
(
{
'programm
'
:
0.306
,
'engin
'
:
0.305
,
'scientist
'
:
0.202
,
'priest
'
:
0.131
,
'philosoph
'
:
0.056
}
)
there
is
still
one
benifit
for
our
custom-mad
approach
for
the
weight
choic
:
We
use
the
cryptographic-secur
method
of
the
systemrandom
class
,
wherea
numpi
choic
is
determinist
and
therefor
not
secur
.
weight
samplein
the
previou
chapter
on
random
number
and
probabl
,
we
introduc
a
method
to
randomli
extract
a
popul
or
sampl
from
a
group
of
object
lik
list
or
tupl
.
everi
object
had
the
same
likelikhood
to
be
drawn
,
i.e
.
to
be
part
of
the
sampl
.
In
real
life
situat
there
will
be
of
cours
situat
in
which
everi
or
some
object
will
have
differ
probabl
.
We
defin
a
function
for
a
weight
sampl
in
the
follow
,
which
make
use
of
our
previous
defin
weighted_choic
function
:
def
weighted_sampl
(
popul
,
weight
,
k
)
:
``
''
''
thi
function
draw
a
random
sampl
of
length
k
from
the
sequenc
'popul
'
accord
to
the
list
of
weight
``
''
''
sampl
=
set
(
)
popul
=
list
(
popul
)
weight
=
list
(
weight
)
while
len
(
sampl
)
<
k
:
choic
=
weighted_choic
(
popul
,
weight
)
sample.add
(
choic
)
index
=
population.index
(
choic
)
weights.pop
(
index
)
population.remov
(
choic
)
weight
=
[
x
/
sum
(
weight
)
for
x
in
weight
]
return
list
(
sampl
)
def
weighted_sample_altern
(
popul
,
weight
,
k
)
:
``
''
''
altern
way
to
previou
implement
.
thi
function
draw
a
random
sampl
of
length
k
from
the
sequenc
'popul
'
accord
to
the
list
of
weight
``
''
''
sampl
=
set
(
)
popul
=
list
(
popul
)
weight
=
list
(
weight
)
while
len
(
sampl
)
<
k
:
choic
=
weighted_choic
(
popul
,
weight
)
if
choic
not
in
sampl
:
sample.add
(
choic
)
return
list
(
sampl
)
exampl
:
let
's
assum
we
have
eight
candi
,
colour
``
red
''
,
``
green
''
,
``
blue
''
,
``
yellow
''
,
``
black
''
,
``
white
''
,
``
pink
''
,
and
``
orang
''
.
our
friend
peter
will
have
the
``
weight
''
prefer
1/24
,
1/6
,
1/6
,
1/12
,
1/12
,
1/24
,
1/8
,
7/24
for
the
colour
.
He
is
allow
to
take
3
candi
:
ball
=
[
``
red
''
,
``
green
''
,
``
blue
''
,
``
yellow
''
,
``
black
''
,
``
white
''
,
``
pink
''
,
``
orang
''
]
weight
=
[
1/24
,
1/6
,
1/6
,
1/12
,
1/12
,
1/24
,
1/8
,
7/24
]
for
i
in
rang
(
10
)
:
print
(
weighted_sampl
(
ball
,
weight
,
3
)
)
[
'pink
'
,
'black
'
,
'white
'
]
[
'pink
'
,
'green
'
,
'orang
'
]
[
'pink
'
,
'green
'
,
'blue
'
]
[
'yellow
'
,
'red
'
,
'black
'
]
[
'yellow
'
,
'green
'
,
'black
'
]
[
'orang
'
,
'blue
'
,
'white
'
]
[
'pink
'
,
'black
'
,
'orang
'
]
[
'green
'
,
'blue
'
,
'orang
'
]
[
'yellow
'
,
'black
'
,
'orang
'
]
[
'pink
'
,
'orang
'
,
'white
'
]
let
's
approxim
the
likelihood
for
an
orang
candi
to
be
includ
in
the
sampl
:
n
=
100000
orange_count
=
0
orange_counter_altern
=
0
for
i
in
rang
(
n
)
:
if
``
orang
''
in
weighted_sampl
(
ball
,
weight
,
3
)
:
orange_count
+=
1
if
``
orang
''
in
weighted_sample_altern
(
ball
,
weight
,
3
)
:
orange_counter_altern
+=
1
print
(
orange_count
/
n
)
print
(
orange_counter_altern
/
n
)
0.71031
0.71084
cartesian
choiceth
function
cartesian_choic
is
name
after
the
cartesian
product
from
set
theori
cartesian
productth
cartesian
product
is
an
oper
which
return
a
set
from
multipl
set
.
the
result
set
from
the
cartesian
product
is
call
a
``
product
set
''
or
simpli
the
``
product
''
.
for
two
set
A
and
B
,
the
cartesian
product
A
×
B
is
the
set
of
all
order
pair
(
a
,
b
)
where
a
∈
A
and
b
∈
B
:
A
x
B
=
{
(
a
,
b
)
|
a
∈
A
and
b
∈
B
}
If
we
have
n
set
A1
,
A2
,
...
An
,
we
can
build
the
cartesian
product
correspondingli
:
A1
x
A2
x
...
x
An
=
{
(
a1
,
a2
,
...
an
)
|
a1
∈
A1
,
a2
∈
A2
,
...
an
∈
An
]
the
cartesian
product
of
n
set
is
sometim
call
an
n-fold
cartesian
product
.
cartesian
choic
:
cartesian_choicew
will
write
now
a
function
cartesian_choic
,
which
take
an
arbitrari
number
of
iter
as
argument
and
return
a
list
,
which
consist
of
random
choic
from
each
iter
in
the
respect
order
.
mathemat
,
we
can
see
the
result
of
the
function
cartesian_choic
as
an
element
of
the
cartesian
product
of
the
iter
which
have
been
pass
as
argument
.
import
random
def
cartesian_choic
(
*iter
)
:
``
''
''
A
list
with
random
choic
from
each
iter
of
iter
is
be
creat
in
respect
order
.
the
result
list
can
be
seen
as
an
element
of
the
cartesian
product
of
the
iter
``
''
''
re
=
[
]
for
popul
in
iter
:
res.append
(
random.choic
(
popul
)
)
return
re
cartesian_choic
(
[
``
the
''
,
``
A
''
]
,
[
``
red
''
,
``
green
''
,
``
blue
''
,
``
yellow
''
,
``
grey
''
]
,
[
``
car
''
,
``
hous
''
,
``
fish
''
,
``
light
''
]
,
[
``
smell
''
,
``
dream
''
,
``
blink
''
]
)
the
abov
python
code
return
the
follow
:
[
'
A
'
,
'red
'
,
'light
'
,
'smell
'
]
We
defin
now
a
weight
version
of
the
previous
defin
function
:
import
random
def
weighted_cartesian_choic
(
*iter
)
:
``
''
''
A
list
with
weight
random
choic
from
each
iter
of
iter
is
be
creat
in
respect
order
``
''
''
re
=
[
]
for
popul
,
weight
in
iter
:
lst
=
weighted_choic
(
popul
,
weight
)
res.append
(
lst
)
return
re
determin
=
(
[
``
the
''
,
``
A
''
,
``
each
''
,
``
everi
''
,
``
No
''
]
,
[
0.3
,
0.3
,
0.1
,
0.1
,
0.2
]
)
colour
=
(
[
``
red
''
,
``
green
''
,
``
blue
''
,
``
yellow
''
,
``
grey
''
]
,
[
0.1
,
0.3
,
0.3
,
0.2
,
0.2
]
)
noun
=
(
[
``
water
''
,
``
eleph
''
,
``
fish
''
,
``
light
''
,
``
program
languag
''
]
,
[
0.3
,
0.2
,
0.1
,
0.1
,
0.3
]
)
nouns2
=
(
[
``
of
happi
''
,
``
of
chocol
''
,
``
of
wisdom
''
,
``
of
challeng
''
,
``
of
air
''
]
,
[
0.5
,
0.2
,
0.1
,
0.1
,
0.1
]
)
verb_phras
=
(
[
``
smell
''
,
``
dream
''
,
``
think
''
,
``
is
made
of
''
]
,
[
0.4
,
0.3
,
0.3
]
)
print
(
``
It
may
or
may
not
be
true
:
''
)
for
i
in
rang
(
10
)
:
re
=
weighted_cartesian_choic
(
determin
,
colour
,
noun
,
verb_phras
,
nouns2
)
print
(
``
``
.join
(
re
)
+
``
.
''
)
It
may
or
may
not
be
true
:
A
green
eleph
dream
of
wisdom
.
No
grey
eleph
smell
of
happi
.
the
green
water
think
of
happi
.
A
blue
program
languag
smell
of
chocol
.
everi
yellow
fish
dream
of
happi
.
A
yellow
water
dream
of
happi
.
A
yellow
program
languag
think
of
chocol
.
each
yellow
water
dream
of
happi
.
each
yellow
water
dream
of
happi
.
the
green
program
languag
dream
of
happi
.
We
check
in
follow
version
,
if
the
``
probabl
''
are
all
right
:
import
random
def
weighted_cartesian_choic
(
*iter
)
:
``
''
''
A
list
with
weight
random
choic
from
each
iter
of
iter
is
be
creat
in
respect
order
``
''
''
re
=
[
]
for
popul
,
weight
in
iter
:
lst
=
weighted_choic
(
popul
,
weight
)
res.append
(
lst
)
return
re
determin
=
(
[
``
the
''
,
``
A
''
,
``
each
''
,
``
everi
''
,
``
No
''
]
,
[
0.3
,
0.3
,
0.1
,
0.1
,
0.2
]
)
colour
=
(
[
``
red
''
,
``
green
''
,
``
blue
''
,
``
yellow
''
,
``
grey
''
]
,
[
0.1
,
0.3
,
0.3
,
0.2
,
0.2
]
)
noun
=
(
[
``
water
''
,
``
eleph
''
,
``
fish
''
,
``
light
''
,
``
program
languag
''
]
,
[
0.3
,
0.2
,
0.1
,
0.1
,
0.3
]
)
nouns2
=
(
[
``
of
happi
''
,
``
of
chocol
''
,
``
of
wisdom
''
,
``
of
challeng
''
,
``
of
air
''
]
,
[
0.5
,
0.2
,
0.1
,
0.1
,
0.1
]
)
verb_phras
=
(
[
``
smell
''
,
``
dream
''
,
``
think
''
,
``
is
made
of
''
]
,
[
0.4
,
0.3
,
0.2
,
0.1
]
)
print
(
``
It
may
or
may
not
be
true
:
''
)
sentenc
=
[
]
for
i
in
rang
(
10000
)
:
re
=
weighted_cartesian_choic
(
determin
,
colour
,
noun
,
verb_phras
,
nouns2
)
sentences.append
(
``
``
.join
(
re
)
+
``
.
''
)
word
=
[
``
smell
''
,
``
dream
''
,
``
think
''
,
``
is
made
of
''
]
from
collect
import
counter
c
=
counter
(
)
for
sentenc
in
sentenc
:
for
word
in
word
:
if
word
in
sentenc
:
c
[
word
]
+=
1
wsum
=
sum
(
c.valu
(
)
)
for
key
in
c
:
print
(
key
,
c
[
key
]
/
wsum
)
It
may
or
may
not
be
true
:
think
0.2015
is
made
of
0.1039
smell
0.4016
dream
0.293
random
seed
A
random
seed
,
-
also
call
``
seed
state
''
,
or
just
``
seed
''
-
is
a
number
use
to
initi
a
pseudorandom
number
gener
.
when
we
call
random.random
(
)
we
expect
and
got
a
random
number
between
0
and
1.
random.random
(
)
calcul
a
new
random
number
by
use
the
previous
produc
random
number
.
what
about
the
first
time
we
use
random
in
our
program
?
ye
,
there
is
no
previous
creat
random
number
.
If
a
random
number
gener
is
call
for
the
first
time
,
it
will
have
to
creat
a
first
``
random
''
number
.
If
we
seed
a
pseudo-random
number
gener
,
we
provid
a
first
``
previou
''
valu
.
A
seed
valu
correspond
to
a
sequenc
of
gener
valu
for
a
given
random
number
gener
.
If
you
use
the
same
seed
valu
again
,
you
get
and
you
can
reli
on
get
the
same
sequenc
of
number
again
.
the
seed
number
itself
doe
n't
need
to
be
randomli
chosen
so
that
the
algorithm
creat
valu
which
follow
a
probabl
distribut
in
a
pseudorandom
manner
.
yet
,
the
seed
matter
in
term
of
secur
.
If
you
know
the
seed
,
you
could
for
exampl
gener
the
secret
encrypt
key
which
is
base
on
thi
seed
.
random
seed
are
in
mani
program
languag
gener
from
the
state
of
the
comput
system
,
which
is
in
lot
of
case
the
system
time
.
thi
is
true
for
python
as
well
.
help
on
random.se
say
that
if
you
call
the
function
with
none
or
no
argument
it
will
seed
``
from
current
time
or
from
an
oper
system
specif
random
sourc
if
avail
.
''
import
random
help
(
random.se
)
help
on
method
seed
in
modul
random
:
seed
(
a=non
,
version=2
)
method
of
random.random
instanc
initi
intern
state
from
hashabl
object
.
none
or
no
argument
seed
from
current
time
or
from
an
oper
system
specif
random
sourc
if
avail
.
for
version
2
(
the
default
)
,
all
of
the
bit
are
use
if
*a*
is
a
str
,
byte
,
or
bytearray
.
for
version
1
,
the
hash
(
)
of
*a*
is
use
instead
.
If
*a*
is
an
int
,
all
bit
are
use
.
the
seed
function
allow
you
to
get
a
determin
sequenc
of
random
number
.
you
can
repeat
thi
sequenc
,
whenev
you
need
it
again
,
e.g
.
for
debug
purpos
.
import
random
random.se
(
42
)
for
_
in
rang
(
10
)
:
print
(
random.randint
(
1
,
10
)
,
end=
''
,
``
)
print
(
``
\nlet
's
creat
the
same
random
number
again
:
''
)
random.se
(
42
)
for
_
in
rang
(
10
)
:
print
(
random.randint
(
1
,
10
)
,
end=
''
,
``
)
2
,
1
,
5
,
4
,
4
,
3
,
2
,
9
,
2
,
10
,
let
's
creat
the
same
random
number
again
:
2
,
1
,
5
,
4
,
4
,
3
,
2
,
9
,
2
,
10
,
random
number
in
python
with
gaussian
and
normalvari
distributionw
want
to
creat
now
1000
random
number
between
130
and
230
that
have
a
gaussian
distribut
with
the
mean
valu
mu
set
to
550
and
the
standard
deviat
sigma
is
set
to
30.
from
random
import
gauss
n
=
1000
valu
=
[
]
frequenc
=
{
}
while
len
(
valu
)
<
n
:
valu
=
gauss
(
180
,
30
)
if
130
<
valu
<
230
:
frequenc
[
int
(
valu
)
]
=
frequencies.get
(
int
(
valu
)
,
0
)
+
1
values.append
(
valu
)
print
(
valu
[
:10
]
)
[
173.49123947564414
,
183.47654360102564
,
186.96893210720162
,
214.90676059797428
,
199.69909520396007
,
183.31521532331496
,
157.85035192965537
,
149.56012897536849
,
187.39026585633607
,
219.33242481612143
]
the
follow
program
plot
the
random
valu
,
which
we
have
creat
befor
.
We
have
n't
cover
matplotlib
so
far
,
so
it
's
not
necessari
to
understand
the
code
:
%
matplotlib
inlin
import
matplotlib.pyplot
as
plt
freq
=
list
(
frequencies.item
(
)
)
freq.sort
(
)
plt.plot
(
*list
(
zip
(
*freq
)
)
)
thi
get
us
the
follow
output
:
[
<
matplotlib.lines.line2d
at
0x7f282554a828
>
]
We
do
the
same
now
with
normvari
instead
of
gauss
:
from
random
import
normalvari
n
=
1000
valu
=
[
]
frequenc
=
{
}
while
len
(
valu
)
<
n
:
valu
=
normalvari
(
180
,
30
)
if
130
<
valu
<
230
:
frequenc
[
int
(
valu
)
]
=
frequencies.get
(
int
(
valu
)
,
0
)
+
1
values.append
(
valu
)
freq
=
list
(
frequencies.item
(
)
)
freq.sort
(
)
plt.plot
(
*list
(
zip
(
*freq
)
)
)
the
python
code
abov
return
the
follow
:
[
<
matplotlib.lines.line2d
at
0x7f2824fef1d0
>
]
exercis
with
zero
and
one
It
might
be
a
good
idea
to
write
the
follow
function
as
an
exercis
yourself
.
the
function
should
be
call
with
a
paramet
p
,
which
is
a
probabilti
valu
between
0
and
1
.
the
function
return
a
1
with
a
probabl
of
p
,
i.e
.
one
in
p
percent
and
zero
in
(
1
-
p
)
percent
of
the
call
:
import
random
def
random_ones_and_zero
(
p
)
:
``
''
''
p
:
probabl
0
<
=
p
<
=
1
return
a
1
with
the
probabl
p
``
''
''
x
=
random.random
(
)
if
x
<
p
:
return
1
els
:
return
0
let
's
test
our
littl
function
:
n
=
1000000
sum
(
random_ones_and_zero
(
0.8
)
for
i
in
rang
(
n
)
)
/
n
thi
get
us
the
follow
:
0.800609
It
might
be
a
great
idea
to
implement
a
task
like
thi
with
a
gener
.
If
you
are
not
familar
with
the
way
of
work
of
a
python
gener
,
we
recommend
to
consult
our
chapter
on
gener
and
iter
of
our
python
tutori
.
import
random
def
random_ones_and_zero
(
p
)
:
while
true
:
x
=
random.random
(
)
yield
1
if
x
<
p
els
0
def
firstn
(
gener
,
n
)
:
for
i
in
rang
(
n
)
:
yield
next
(
gener
)
n
=
1000000
sum
(
x
for
x
in
firstn
(
random_ones_and_zero
(
0.8
)
,
n
)
)
/
n
We
receiv
the
follow
output
:
0.799762
our
gener
random_ones_and_zero
can
be
seen
as
a
sender
,
which
emit
one
and
zero
with
a
probabl
of
p
and
(
1-p
)
respect
.
We
will
write
now
anoth
gener
,
which
is
receiv
thi
bitstream
.
the
task
of
thi
new
gener
is
to
read
the
incom
bitstream
and
yield
anoth
bitstream
with
one
and
zero
with
a
probabl
of
0.5
without
know
or
use
the
probabl
p.
It
should
work
for
an
arbitrari
probabl
valu
p.1
def
ebitt
(
bitstream
)
:
while
true
:
bit1
=
next
(
bitstream
)
bit2
=
next
(
bitstream
)
if
bit1
+
bit2
==
1
:
bit3
=
next
(
bitstream
)
if
bit2
+
bit3
==
1
:
yield
1
els
:
yield
0
def
ebitter2
(
bitstream
)
:
bit1
=
next
(
bitstream
)
bit2
=
next
(
bitstream
)
bit3
=
next
(
bitstream
)
while
true
:
if
bit1
+
bit2
==
1
:
if
bit2
+
bit3
==
1
:
yield
1
els
:
yield
0
bit1
,
bit2
,
bit3
=
bit2
,
bit3
,
next
(
bitstream
)
n
=
1000000
sum
(
x
for
x
in
firstn
(
ebitt
(
random_ones_and_zero
(
0.8
)
)
,
n
)
)
/
n
We
receiv
the
follow
result
:
0.49975
n
=
1000000
sum
(
x
for
x
in
firstn
(
ebitter2
(
random_ones_and_zero
(
0.8
)
)
,
n
)
)
/
n
the
abov
python
code
return
the
follow
:
0.500011
underli
theori
:
our
first
gener
emit
a
bitstream
B0
,
B1
,
B2
,
...
We
check
now
an
arbitrari
pair
of
consecut
bit
Bi
,
bi+1
,
...
such
a
pair
can
have
the
valu
01
,
10
,
00
or
11
.
the
probabl
P
(
01
)
=
(
p-1
)
x
p
and
probabl
P
(
10
)
=
p
x
(
p-1
)
,
so
that
the
combin
probabilti
that
the
two
consecut
bit
are
either
01
or
10
(
or
the
sum
of
the
two
bit
is
1
)
is
2
x
(
p-1
)
x
p
now
we
look
at
anoth
bit
bi+2
.
what
is
the
probabl
that
both
Bi
+
bi+1
=
1
and
bi+1
+
bi+2
=
1
?
the
possibl
outcom
satisfi
these
condit
and
their
correspond
probabl
can
be
found
in
the
follow
tabl
:
probabl
Bi
bi+1
bi+2
p2
x
(
1-p
)
0
1
0
p
x
(
1
-
p
)
2
1
0
1
We
will
denot
the
outcom
sum
(
Bi
,
bi+1
)
=1
asx1
and
correspondingli
the
outcom
sum
(
bi+1
,
bi+2
)
=1
as
X2
So
,
the
joint
probabl
P
(
X1
,
X2
)
=
p2
x
(
1-p
)
+
p
x
(
1
-
p
)
2
which
can
be
rearrang
to
p
x
(
1-p
)
the
condit
probabl
of
X2
given
X1
:
P
(
X2
|
X1
)
=
P
(
X1
,
X2
)
/
P
(
X2
)
P
(
X2
|
X1
)
=
p
x
(
1-p
)
/
2
x
p
x
(
1-p
)
=
1
/
2
synthet
sale
figuresin
thi
subchapt
we
want
to
creat
a
data
file
with
sale
figur
.
imagin
that
we
have
a
chain
of
shop
in
variou
european
and
canadian
citi
:
frankfurt
,
munich
,
berlin
,
zurich
,
hamburg
,
london
,
toronto
,
strasbourg
,
luxembourg
,
amsterdam
,
rotterdam
,
the
hagu
We
start
with
an
array
'sale
'
of
sale
figur
for
the
year
1997
:
import
numpi
as
np
sale
=
np.array
(
[
1245.89
,
2220.00
,
1635.77
,
1936.25
,
1002.03
,
2099.13
,
723.99
,
990.37
,
541.44
,
1765.00
,
1802.84
,
1999.00
]
)
the
aim
is
to
creat
a
comma
separ
list
like
the
one
you
get
from
excel
.
the
file
should
contain
the
sale
figur
,
we
do
n't
know
,
for
all
the
shop
,
we
do
n't
have
,
span
the
year
from
1997
to
2016
.
We
will
add
random
valu
to
our
sale
figur
year
after
year
.
for
thi
purpos
we
construct
an
array
with
growthrat
.
the
growthrat
can
vari
between
a
minim
percent
valu
(
min_perc
)
and
maximum
percent
valu
(
max_perc
)
:
min_perc
=
0.98
#
correspond
to
-1.5
%
max_perc
=
1.06
#
6
%
growthrat
=
(
max_perc
-
min_perc
)
*
np.random.random_sampl
(
12
)
+
min_perc
print
(
growthrat
)
[
1.03476561
1.00885095
1.00614899
1.05164581
1.0307091
0.98822763
0.99366872
1.05810125
1.04798573
1.02784796
1.05035899
1.02262023
]
To
get
the
new
sale
figur
after
a
year
,
we
multipli
the
sale
array
``
sale
''
with
the
array
``
growthrat
''
:
sale
*
growthrat
after
have
execut
the
python
code
abov
we
receiv
the
follow
:
array
(
[
1289.20412146
,
2239.649113
,
1645.82833205
,
2036.24919608
,
1032.80143634
,
2074.41825668
,
719.40621318
,
1047.91173209
,
567.42139317
,
1814.15165757
,
1893.62920988
,
2044.21783979
]
)
To
get
a
more
sustain
sale
develop
,
we
chang
the
growthrat
onli
everi
four
year
.
thi
is
our
complet
program
,
which
save
the
data
in
a
file
call
sales_figures.csv
:
import
numpi
as
np
fh
=
open
(
``
sales_figures.csv
''
,
``
w
''
)
fh.write
(
``
year
,
frankfurt
,
munich
,
berlin
,
zurich
,
hamburg
,
london
,
toronto
,
strasbourg
,
luxembourg
,
amsterdam
,
rotterdam
,
the
hague\n
''
)
sale
=
np.array
(
[
1245.89
,
2220.00
,
1635.77
,
1936.25
,
1002.03
,
2099.13
,
723.99
,
990.37
,
541.44
,
1765.00
,
1802.84
,
1999.00
]
)
for
year
in
rang
(
1997
,
2016
)
:
line
=
str
(
year
)
+
``
,
``
+
``
,
``
.join
(
map
(
str
,
sale
)
)
fh.write
(
line
+
``
\n
''
)
if
year
%
4
==
0
:
min_perc
=
0.98
#
correspond
to
-1.5
%
max_perc
=
1.06
#
6
%
growthrat
=
(
max_perc
-
min_perc
)
*
np.random.random_sampl
(
12
)
+
min_perc
#
growthrat
=
1
+
(
np.random.rand
(
12
)
*
max_perc
-
negative_max
)
/
100
sale
=
np.around
(
sale
*
growthrat
,
2
)
fh.close
(
)
the
result
is
in
the
file
sales_figures.csv
.
We
will
use
thi
file
in
our
chapter
on
read
and
write
in
numpi
.
exercis
let
's
do
some
more
die
roll
.
prove
empir
-
by
write
a
simul
program
-
that
the
probabl
for
the
combin
event
``
an
even
number
is
roll
''
(
E
)
and
``
A
number
greater
than
2
is
roll
''
is
1/3
.
the
file
[
``
universities_uk.txt
''
]
(
universities_uk.txt
)
contain
a
list
of
univers
in
the
unit
kingdom
by
enrol
from
2013-2014
(
data
from
(
[
wikepedia
]
(
http
:
//en.wikipedia.org/wiki/list_of_universities_in_the_united_kingdom_by_enrol
#
cite_note-1
)
)
.
write
a
function
which
return
a
tupl
(
univers
,
enrol
,
total_number_of_stud
)
with
-
univers
:
list
of
univers
name
-
enrol
:
correspond
list
with
enrol
-
total_number_of_stud
:
over
all
univers
now
you
can
enrol
a
100,000
fiction
student
with
a
likelihood
correspond
to
the
real
enrol
.
let
me
take
you
back
in
time
and
space
in
our
next
exercis
.
We
will
travel
back
into
ancient
pythonia
(
πηθωνια
)
.
It
wa
the
time
when
king
pysseu
rule
as
the
benevol
dictat
for
live
.
It
wa
the
time
when
pysseu
sent
out
hi
messeng
throughout
the
world
to
announc
that
the
time
ha
come
for
hi
princ
anacondo
(
ανακονδος
)
,
cobrion
(
κομπριον
)
,
boato
(
μποατος
)
and
addokl
(
ανδοκλης
)
to
merri
.
So
,
they
organ
the
toughest
program
contest
amongst
the
fair
and
brave
amazon
,
better
known
as
pythonista
of
pythonia
.
final
,
onli
eleven
amazon
were
left
to
choos
from
:
1
)
the
ether
airla
(
αιρλα
)
2
)
barbara
(
βαρβάρα
)
,
the
one
from
a
foreign
countri
.
3
)
eo
(
ηως
)
,
look
divin
in
dawn
4
)
the
sweet
glykeria
(
γλυκερία
)
5
)
the
graceful
hanna
(
αννα
)
6
)
helen
(
ελενη
)
,
the
light
in
the
dark
7
)
the
good
angel
agathangelo
(
αγαθάγγελος
)
8
)
the
violet
tint
cloud
iokast
(
ιοκάστη
)
9
)
medousa
(
μέδουσα
)
,
the
guardian
10
)
the
self-control
sofronia
(
σωφρονία
)
11
)
andromeda
(
ανδρομεδα
)
,
the
one
who
think
man
or
a
warrior
.
On
the
day
they
arriv
the
chanc
to
be
drawn
in
the
lotteri
are
the
same
for
everi
amazon
,
but
pysseu
want
the
lotteri
to
be
postpon
to
some
day
in
the
futur
.
the
probabl
chang
everi
day
:
It
will
be
lower
by
1/13
for
the
first
seven
amazon
and
it
will
be
increas
by
1/12
for
the
last
four
amazon
.
how
long
will
the
king
have
to
wait
until
he
can
be
more
than
90
percent
sure
that
hi
princ
anacondo
,
cobrion
,
boato
and
addokl
will
be
marri
to
iokast
,
medousa
,
sofronia
and
andromeda
?
<
/li
>
<
/ol
>
solut
to
our
exercis
from
random
import
randint
outcom
=
[
randint
(
1
,
6
)
for
_
in
rang
(
10000
)
]
even_pip
=
[
x
for
x
in
outcom
if
x
%
2
==
0
]
greater_two
=
[
x
for
x
in
outcom
if
x
>
2
]
combin
=
[
x
for
x
in
outcom
if
x
%
2
==
0
and
x
>
2
]
print
(
len
(
even_pip
)
/
len
(
outcom
)
)
print
(
len
(
greater_two
)
/
len
(
outcom
)
)
print
(
len
(
combin
)
/
len
(
outcom
)
)
0.5061
0.6719
0.3402
At
first
we
will
write
the
function
``
process_datafil
''
to
process
our
data
file
:
def
process_datafil
(
filenam
)
:
``
''
''
process_datafil
-
>
(
univers
,
enrol
,
total_number_of_stud
)
univers
:
list
of
univers
name
enrol
:
correspond
list
with
enrol
total_number_of_stud
:
over
all
univers
``
''
''
univers
=
[
]
enrol
=
[
]
with
open
(
filenam
)
as
fh
:
total_number_of_stud
=
0
fh.readlin
(
)
#
get
rid
of
descript
first
line
for
line
in
fh
:
line
=
line.strip
(
)
*praefix
,
undergradu
,
postgradu
,
total
=
line.rsplit
(
)
univers
=
praefix
[
1
:
]
total
=
int
(
total.replac
(
``
,
''
,
``
''
)
)
enrollments.append
(
total
)
universities.append
(
``
``
.join
(
univers
)
)
total_number_of_stud
+=
total
return
(
univers
,
enrol
,
total_number_of_stud
)
let
's
start
our
function
and
check
the
result
:
univers
,
enrol
,
total_stud
=
process_datafil
(
``
universities_uk.txt
''
)
for
i
in
rang
(
14
)
:
print
(
univers
[
i
]
,
end=
''
:
``
)
print
(
enrol
[
i
]
)
print
(
``
total
number
of
student
onrol
in
the
UK
:
``
,
total_stud
)
open
univers
in
england
:
123490
univers
of
manchest
:
37925
univers
of
nottingham
:
33270
sheffield
hallam
univers
:
33100
univers
of
birmingham
:
32335
manchest
metropolitan
univers
:
32160
univers
of
leed
:
30975
cardiff
univers
:
30180
univers
of
south
wale
:
29195
univers
colleg
london
:
28430
king
's
colleg
london
:
27645
univers
of
edinburgh
:
27625
northumbria
univers
:
27565
univers
of
glasgow
:
27390
total
number
of
student
onrol
in
the
UK
:
2299380
We
want
to
enrol
now
a
virtual
student
randomli
to
one
of
the
univers
.
To
get
a
weight
list
suitabl
for
our
weighted_choic
function
,
we
have
to
normal
the
valu
in
the
list
enrol
:
normalized_enrol
=
[
student
/
total_stud
for
student
in
enrol
]
#
enrol
a
virtual
student
:
print
(
weighted_choic
(
univers
,
normalized_enrol
)
)
univers
of
dunde
We
have
been
ask
by
the
exercis
to
``
enrol
''
100,000
fiction
student
.
thi
can
be
easili
accomplish
with
a
loop
:
from
collect
import
counter
outcom
=
[
]
n
=
100000
for
i
in
rang
(
n
)
:
outcomes.append
(
weighted_choic
(
univers
,
normalized_enrol
)
)
c
=
counter
(
outcom
)
print
(
c.most_common
(
20
)
)
[
(
'open
univers
in
england
'
,
5529
)
,
(
'univers
of
manchest
'
,
1574
)
,
(
'univers
of
nottingham
'
,
1427
)
,
(
'univers
of
birmingham
'
,
1424
)
,
(
'sheffield
hallam
univers
'
,
1410
)
,
(
'manchest
metropolitan
univers
'
,
1408
)
,
(
'cardiff
univers
'
,
1334
)
,
(
'univers
of
leed
'
,
1312
)
,
(
'univers
of
south
wale
'
,
1264
)
,
(
'univers
of
plymouth
'
,
1218
)
,
(
'univers
colleg
london
'
,
1209
)
,
(
'coventri
univers
'
,
1209
)
,
(
'univers
of
the
west
of
england
'
,
1197
)
,
(
'univers
of
edinburgh
'
,
1196
)
,
(
``
king
's
colleg
london
''
,
1183
)
,
(
'univers
of
glasgow
'
,
1181
)
,
(
'univers
of
central
lancashir
'
,
1176
)
,
(
'nottingham
trent
univers
'
,
1174
)
,
(
'univers
of
sheffield
'
,
1160
)
,
(
'northumbria
univers
'
,
1154
)
]
<
/li
>
the
bunch
of
amazon
is
implement
as
a
list
,
while
we
choos
a
set
for
pysseuss
favorit
.
the
weight
at
the
begin
are
1/11
for
all
,
i.e
.
1/len
(
amazon
)
.
everi
loop
cycl
correspond
to
a
new
day
.
everi
time
we
start
a
new
loop
cycl
,
we
will
draw
``
n
''
sampl
of
pythonista
to
calcul
the
ratio
of
the
number
of
time
the
sampl
is
equal
to
the
king
's
favorit
divid
by
the
number
of
time
the
sampl
doe
n't
match
the
king
's
idea
of
daughter-in-law
.
thi
correspond
to
the
probabl
``
prob
''
.
We
stop
the
first
time
,
the
probabl
is
equal
or
larger
than
0.9
.
We
can
use
both
the
function
``
weighted_sam
''
and
``
weighted_sample_altern
''
to
do
the
draw
.
import
time
amazon
=
[
``
airla
''
,
``
barbara
''
,
``
eo
''
,
``
glykeria
''
,
``
hanna
''
,
``
helen
''
,
``
agathangelo
''
,
``
iokast
''
,
``
medousa
''
,
``
sofronia
''
,
``
andromeda
''
]
weight
=
[
1/len
(
amazon
)
for
_
in
rang
(
len
(
amazon
)
)
]
pytheusses_favorit
=
{
``
iokast
''
,
``
medousa
''
,
``
sofronia
''
,
``
andromeda
''
}
n
=
1000
counter
=
0
prob
=
1
/
330
day
=
0
factor1
=
1
/
13
factor2
=
1
/
12
start
=
time.clock
(
)
while
prob
<
0.9
:
for
i
in
rang
(
n
)
:
the_chosen_on
=
weighted_sample_altern
(
amazon
,
weight
,
4
)
if
set
(
the_chosen_on
)
==
pytheusses_favorit
:
counter
+=
1
prob
=
counter
/
n
counter
=
0
weight
[
:7
]
=
[
p
-
p*factor1
for
p
in
weight
[
:7
]
]
weight
[
7
:
]
=
[
p
+
p*factor2
for
p
in
weight
[
7
:
]
]
weight
=
[
x
/
sum
(
weight
)
for
x
in
weight
]
day
+=
1
print
(
time.clock
(
)
-
start
)
print
(
``
number
of
day
,
he
ha
to
wait
:
``
,
day
)
2.870792999999999
number
of
day
,
he
ha
to
wait
:
33
teh
valu
for
the
number
of
day
differ
,
if
n
is
not
larg
enough
.
the
follow
is
a
solut
without
round-off
error
.
We
will
use
fraction
from
the
modul
fraction
.
import
time
from
fraction
import
fraction
amazon
=
[
``
airla
''
,
``
barbara
''
,
``
eo
''
,
``
glykeria
''
,
``
hanna
''
,
``
helen
''
,
``
agathangelo
''
,
``
iokast
''
,
``
medousa
''
,
``
sofronia
''
,
``
andromeda
''
]
weight
=
[
fraction
(
1
,
11
)
for
_
in
rang
(
len
(
amazon
)
)
]
pytheusses_favorit
=
{
``
iokast
''
,
``
medousa
''
,
``
sofronia
''
,
``
andromeda
''
}
n
=
1000
counter
=
0
prob
=
fraction
(
1
,
330
)
day
=
0
factor1
=
fraction
(
1
,
13
)
factor2
=
fraction
(
1
,
12
)
start
=
time.clock
(
)
while
prob
<
0.9
:
#
print
(
prob
)
for
i
in
rang
(
n
)
:
the_chosen_on
=
weighted_sample_altern
(
amazon
,
weight
,
4
)
if
set
(
the_chosen_on
)
==
pytheusses_favorit
:
counter
+=
1
prob
=
fraction
(
counter
,
n
)
counter
=
0
weight
[
:7
]
=
[
p
-
p*factor1
for
p
in
weight
[
:7
]
]
weight
[
7
:
]
=
[
p
+
p*factor2
for
p
in
weight
[
7
:
]
]
weight
=
[
x
/
sum
(
weight
)
for
x
in
weight
]
day
+=
1
print
(
time.clock
(
)
-
start
)
print
(
``
number
of
day
,
he
ha
to
wait
:
``
,
day
)
35.920345
number
of
day
,
he
ha
to
wait
:
33
We
can
see
that
the
solut
with
fraction
is
beauti
but
veri
slow
.
wherea
the
greater
precis
doe
n't
play
a
role
in
our
case
.
So
far
,
we
have
n't
use
the
power
of
numpi
.
We
will
do
thi
in
the
next
implement
of
our
problem
:
import
time
import
numpi
as
np
amazon
=
[
``
airla
''
,
``
barbara
''
,
``
eo
''
,
``
glykeria
''
,
``
hanna
''
,
``
helen
''
,
``
agathangelo
''
,
``
iokast
''
,
``
medousa
''
,
``
sofronia
''
,
``
andromeda
''
]
weight
=
np.full
(
11
,
1/len
(
amazon
)
)
pytheusses_favorit
=
{
``
iokast
''
,
``
medousa
''
,
``
sofronia
''
,
``
andromeda
''
}
n
=
1000
counter
=
0
prob
=
1
/
330
day
=
0
factor1
=
1
/
13
factor2
=
1
/
12
start
=
time.clock
(
)
while
prob
<
0.9
:
for
i
in
rang
(
n
)
:
the_chosen_on
=
weighted_sample_altern
(
amazon
,
weight
,
4
)
if
set
(
the_chosen_on
)
==
pytheusses_favorit
:
counter
+=
1
prob
=
counter
/
n
counter
=
0
weight
[
:7
]
=
weight
[
:7
]
-
weight
[
:7
]
*
factor1
weight
[
7
:
]
=
weight
[
7
:
]
+
weight
[
7
:
]
*
factor2
weight
=
weight
/
np.sum
(
weight
)
#
print
(
weight
)
day
+=
1
print
(
time.clock
(
)
-
start
)
print
(
``
number
of
day
,
he
ha
to
wait
:
``
,
day
)
4.930090000000007
number
of
day
,
he
ha
to
wait
:
33
footnot
:
1
I
am
thank
to
dr.
hanno
baehr
who
introduc
me
to
the
problem
of
``
random
extract
''
when
particip
in
a
python
train
cours
in
nuremberg
in
januari
2014
.
hanno
outlin
some
bit
of
the
theoret
framework
.
dure
a
night
session
in
a
pub
call
``
zeit
&
raum
''
(
english
:
``
time
&
space
''
)
I
implement
a
correspond
python
program
to
back
the
theoret
solut
empir
.
previou
chapter
:
python
,
numpi
and
probabl
next
chapter
:
creation
of
synthet
test
data
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

python
tutori
:
magic
method
python
cours
python
3
tutori
the
origin
of
pythonstart
with
python
:
the
interact
shellexecut
a
scriptindentationdata
type
and
variablesoperatorssequenti
data
type
:
list
and
stringslist
manipulationsshallow
and
deep
copydictionariesset
and
frozen
setsan
extens
exampl
use
setsinput
via
the
keyboardcondit
statementsloop
,
while
loopfor
loopsdiffer
between
inter
und
iterablesoutput
with
printformat
output
with
string
modulo
and
the
format
methodfunctionsrecurs
and
recurs
functionsparamet
pass
in
functionsnamespacesglob
and
local
variablesdecoratorsmemo
with
decoratorsread
and
write
filesmodular
program
and
modulespackag
in
pythonregular
expressionsregular
express
,
advancedlambda
oper
,
filter
,
reduc
and
maplist
comprehensioniter
and
generatorsexcept
handlingtest
,
doctest
,
unittestsobject
orient
programmingclass
and
instanc
attributesproperti
vs.
getter
and
settersinheritancemultipl
inheritancemag
method
and
oper
overloadingoop
,
inherit
exampleslotsclass
and
class
creationroad
to
metaclassesmetaclassesmetaclass
use
case
:
count
function
callsabstract
class
some
magic
``
and
abov
all
,
watch
with
glitter
eye
the
whole
world
around
you
becaus
the
greatest
secret
are
alway
hidden
in
the
most
unlik
place
.
those
who
do
n't
believ
in
magic
will
never
find
it
.
''
(
roald
dahl
)
``
It
's
still
magic
even
if
you
know
how
it
's
done
.
''
(
terri
pratchett
,
A
hat
full
of
ski
)
japanes
food
and
oop
``
I
think
both
object-ori
program
and
japanes
food
are
signific
aesthet
and
stylist
achiev
-
they
're
both
about
take
simpl
meager
ingredi
and
make
someth
remark
.
``
,
sean
M.
burk
object-ori
program
``
certainli
not
everi
good
program
is
object-ori
,
and
not
everi
object-ori
program
is
good
.
''
(
bjarn
stroustrup
,
danish
comput
scientist
,
best
known
for
the
creation
and
the
develop
of
the
wide
use
c++
program
languag
.
)
``
object-ori
program
is
an
except
bad
idea
which
could
onli
have
origin
in
california
.
''
(
edsger
dijkstra
,
(
dutch
comput
scientist
,
1930-2002
)
dijkstra
also
said
:
``
...
what
societi
over­whel­mingli
ask
for
is
snake
oil
.
Of
cours
,
the
snake
oil
ha
the
most
impress
name
-
otherwis
you
would
be
sell
noth
-
like
``
structur
analysi
and
design
''
,
``
softwar
engin
''
,
``
matur
model
''
,
``
manag
inform
system
''
,
``
integr
project
support
environ
''
``
object
orient
''
and
``
busi
process
re-engin
''
thi
websit
is
support
by
:
linux
and
python
cours
and
seminar
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
magisch
methoden
und
operator-überladung
classroom
train
cours
the
goal
of
thi
websit
is
to
provid
educ
materi
,
allow
you
to
learn
python
on
your
own
.
nevertheless
,
it
is
faster
and
more
effici
to
attend
a
``
real
''
python
cours
in
a
classroom
,
with
an
experienc
trainer
.
So
whi
not
attend
one
of
the
live
python
cours
in
strasbourg
,
pari
,
luxembourg
,
amsterdam
,
zürich
/
zurich
,
vienna
/
wien
,
london
,
berlin
,
munich
,
hamburg
,
frankfurt
or
lake
constanc
by
bernd
klein
,
the
author
of
thi
tutori
?
onsit
train
cours
let
us
come
to
your
compani
,
organ
or
institut
and
train
your
employe
,
as
we
've
done
it
mani
time
in
amsterdam
(
the
netherland
)
,
berlin
(
germani
)
,
bern
(
switzerland
)
,
basel
(
switzerland
)
,
zurich
(
switzerland
)
,
locarno
(
switzerland
)
,
den
haag
(
the
hagu
)
,
hamburg
(
germani
)
,
frankfurt
(
germani
)
,
toronto
(
canada
)
,
edmonton
(
canada
)
,
munich
(
germani
)
and
mani
other
citi
.
We
do
train
cours
in
england
,
switzerland
,
liechtenstein
,
austria
,
germani
,
franc
,
belgium
,
the
netherland
,
luxembourg
,
poland
,
UK
,
itali
and
other
locat
in
europ
and
in
canada
.
thi
way
you
will
get
a
perfect
train
up
to
your
need
and
it
will
be
extrem
cost
effici
as
well
.
contact
us
so
we
can
defin
and
find
the
best
cours
curriculum
to
meet
your
need
,
and
schedul
cours
session
to
be
held
at
your
locat
.
skill
python
programm
you
are
look
for
experienc
python
develop
or
programm
?
We
can
help
you
,
pleas
contact
us
.
quot
of
the
day
:
''
comput
scienc
is
no
more
about
comput
than
astronomi
is
about
telescop
.
''
(
edsger
dijkstra
)
data
protect
declar
data
protect
declar
previou
chapter
:
multipl
inherit
next
chapter
:
oop
,
inherit
exampl
magic
method
and
oper
overload
introduct
the
so-cal
magic
method
have
noth
to
do
with
wizardri
.
you
have
alreadi
seen
them
in
previou
chapter
of
our
tutori
.
they
are
special
method
with
fix
name
.
they
are
the
method
with
thi
clumsi
syntax
,
i.e
.
the
doubl
underscor
at
the
begin
and
the
end
.
they
are
also
hard
to
talk
about
.
how
do
you
pronounc
or
say
a
method
name
like
__init__
?
``
underscor
underscor
init
underscor
underscor
''
sound
horribl
and
is
nearli
a
tongu
twister
.
``
doubl
underscor
init
doubl
underscor
''
is
a
lot
better
,
but
the
ideal
way
is
``
dunder
init
dunder
''
1
that
's
whi
magic
method
method
are
sometim
call
dunder
method
!
So
what
's
magic
about
the
__init__
method
?
the
answer
is
,
you
do
n't
have
to
invok
it
directli
.
the
invoc
is
realiz
behind
the
scene
.
when
you
creat
an
instanc
x
of
a
class
A
with
the
statement
``
x
=
A
(
)
''
,
python
will
do
the
necessari
call
to
__new__
and
__init__
.
nearli
at
the
end
of
thi
chapter
of
our
tutori
we
will
introduc
the
__call__
method
.
It
is
overlook
by
mani
beginn
and
even
advanc
programm
of
python
.
It
is
a
function
which
mani
program
languag
do
not
have
,
so
programm
are
gener
not
look
for
.
the
__call__
method
enabl
python
programm
to
write
class
where
the
instanc
behav
like
function
.
both
function
and
the
instanc
of
such
class
are
call
callabl
.
We
have
encount
the
concept
of
oper
overload
mani
time
in
the
cours
of
thi
tutori
.
We
had
use
the
plu
sign
to
add
numer
valu
,
to
concaten
string
or
to
combin
list
:
>
>
>
4
+
5
9
>
>
>
3.8
+
9
12.8
>
>
>
``
peter
''
+
``
``
+
``
pan
''
'peter
pan
'
>
>
>
[
3,6,8
]
+
[
7,11,13
]
[
3
,
6
,
8
,
7
,
11
,
13
]
>
>
>
It
's
even
possibl
to
overload
the
``
+
''
oper
as
well
as
all
the
other
oper
for
the
purpos
of
your
own
class
.
To
do
thi
,
you
need
to
understand
the
underli
mechan
.
there
is
a
special
(
or
a
``
magic
''
)
method
for
everi
oper
sign
.
the
magic
method
for
the
``
+
''
sign
is
the
__add__
method
.
for
``
-
''
it
is
``
__sub__
''
and
so
on
.
We
have
a
complet
list
of
all
the
magic
method
a
littl
bit
further
down
.
the
mechan
work
like
thi
:
If
we
have
an
express
``
x
+
y
''
and
x
is
an
instanc
of
class
K
,
then
python
will
check
the
class
definit
of
K.
If
K
ha
a
method
__add__
it
will
be
call
with
x.__add__
(
y
)
,
otherwis
we
will
get
an
error
messag
.
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
typeerror
:
unsupport
operand
type
(
s
)
for
+
:
'
K
'
and
'
K
'
overview
of
magic
method
binari
oper
oper
method
+
object.__add__
(
self
,
other
)
-
object.__sub__
(
self
,
other
)
*
object.__mul__
(
self
,
other
)
//
object.__floordiv__
(
self
,
other
)
/
object.__truediv__
(
self
,
other
)
%
object.__mod__
(
self
,
other
)
**
object.__pow__
(
self
,
other
[
,
modulo
]
)
<
<
object.__lshift__
(
self
,
other
)
>
>
object.__rshift__
(
self
,
other
)
&
object.__and__
(
self
,
other
)
^
object.__xor__
(
self
,
other
)
|
object.__or__
(
self
,
other
)
extend
assign
oper
method
+=
object.__iadd__
(
self
,
other
)
-=
object.__isub__
(
self
,
other
)
*=
object.__imul__
(
self
,
other
)
/=
object.__idiv__
(
self
,
other
)
//=
object.__ifloordiv__
(
self
,
other
)
%
=
object.__imod__
(
self
,
other
)
**=
object.__ipow__
(
self
,
other
[
,
modulo
]
)
<
<
=
object.__ilshift__
(
self
,
other
)
>
>
=
object.__irshift__
(
self
,
other
)
&
=
object.__iand__
(
self
,
other
)
^=
object.__ixor__
(
self
,
other
)
|=
object.__ior__
(
self
,
other
)
unari
oper
oper
method
-
object.__neg__
(
self
)
+
object.__pos__
(
self
)
ab
(
)
object.__abs__
(
self
)
~
object.__invert__
(
self
)
complex
(
)
object.__complex__
(
self
)
int
(
)
object.__int__
(
self
)
long
(
)
object.__long__
(
self
)
float
(
)
object.__float__
(
self
)
oct
(
)
object.__oct__
(
self
)
hex
(
)
object.__hex__
(
self
comparison
oper
oper
method
<
object.__lt__
(
self
,
other
)
<
=
object.__le__
(
self
,
other
)
==
object.__eq__
(
self
,
other
)
!
=
object.__ne__
(
self
,
other
)
>
=
object.__ge__
(
self
,
other
)
>
object.__gt__
(
self
,
other
)
exampl
class
:
length
We
will
demonstr
in
the
follow
length
class
,
how
you
can
overload
the
``
+
''
oper
for
your
own
class
.
To
do
thi
,
we
have
to
overload
the
__add__
method
.
our
class
contain
the
__str__
and
__repr__
method
as
well
.
the
instanc
of
the
class
length
contain
length
or
distanc
inform
.
the
attribut
of
an
instanc
are
self.valu
and
self.unit
.
thi
class
allow
us
to
calcul
express
with
mix
unit
like
thi
one
:
2.56
m
+
3
yd
+
7.8
in
+
7.03
cm
the
class
can
be
use
like
thi
:
>
>
>
from
unit_convers
import
length
>
>
>
L
=
length
>
>
>
print
(
L
(
2.56
,
''
m
''
)
+
L
(
3
,
''
yd
''
)
+
L
(
7.8
,
''
in
''
)
+
L
(
7.03
,
''
cm
''
)
)
5.57162
>
>
>
the
list
of
the
class
:
class
length
:
__metric
=
{
``
mm
''
:
0.001
,
``
cm
''
:
0.01
,
``
m
''
:
1
,
``
km
''
:
1000
,
``
in
''
:
0.0254
,
``
ft
''
:
0.3048
,
``
yd
''
:
0.9144
,
``
mi
''
:
1609.344
}
def
__init__
(
self
,
valu
,
unit
=
``
m
''
)
:
self.valu
=
valu
self.unit
=
unit
def
converse2metr
(
self
)
:
return
self.valu
*
length.__metr
[
self.unit
]
def
__add__
(
self
,
other
)
:
l
=
self.converse2metr
(
)
+
other.converse2metr
(
)
return
length
(
l
/
length.__metr
[
self.unit
]
,
self.unit
)
def
__str__
(
self
)
:
return
str
(
self.converse2metr
(
)
)
def
__repr__
(
self
)
:
return
``
length
(
``
+
str
(
self.valu
)
+
``
,
'
''
+
self.unit
+
``
'
)
''
if
__name__
==
``
__main__
''
:
x
=
length
(
4
)
print
(
x
)
y
=
eval
(
repr
(
x
)
)
z
=
length
(
4.5
,
``
yd
''
)
+
length
(
1
)
print
(
repr
(
z
)
)
print
(
z
)
If
we
start
thi
program
,
we
get
the
follow
output
:
4
length
(
5.593613298337708
,
'yd
'
)
5.1148
We
use
the
method__iadd__
to
implement
the
extend
assign
:
def
__iadd__
(
self
,
other
)
:
l
=
self.converse2metr
(
)
+
other.converse2metr
(
)
self.valu
=
l
/
length.__metr
[
self.unit
]
return
self
now
we
are
capabl
to
write
the
follow
assign
:
x
+=
length
(
1
)
x
+=
length
(
4
,
``
yd
''
)
We
have
ad
1
metr
in
the
exampl
abov
by
write
``
x
+=
length
(
1
)
)
''
.
most
certainli
,
you
will
agre
with
us
that
it
would
be
more
conveni
to
simpli
write
``
x
+=
1
''
instead
.
We
also
want
to
treat
express
like
``
length
(
5
,
''
yd
''
)
+
4.8
''
similarli
.
So
,
if
somebodi
use
a
type
int
or
float
,
our
class
take
it
automat
for
``
metr
''
and
convert
it
into
a
length
object
.
It
's
easi
to
adapt
our
__add__
and
``
__iadd__
''
method
for
thi
task
.
all
we
have
to
do
is
to
check
the
type
of
the
paramet
``
other
''
:
def
__add__
(
self
,
other
)
:
if
type
(
other
)
==
int
or
type
(
other
)
==
float
:
l
=
self.converse2metr
(
)
+
other
els
:
l
=
self.converse2metr
(
)
+
other.converse2metr
(
)
return
length
(
l
/
length.__metr
[
self.unit
]
,
self.unit
)
def
__iadd__
(
self
,
other
)
:
if
type
(
other
)
==
int
or
type
(
other
)
==
float
:
l
=
self.converse2metr
(
)
+
other
els
:
l
=
self.converse2metr
(
)
+
other.converse2metr
(
)
self.valu
=
l
/
length.__metr
[
self.unit
]
return
self
It
's
a
safe
bet
that
if
somebodi
work
for
a
while
with
ad
integ
and
float
from
the
right
sight
that
he
or
she
want
to
the
same
from
the
left
side
!
So
let
's
tri
it
out
:
>
>
>
from
unit_convers
import
length
>
>
>
x
=
length
(
3
,
``
yd
''
)
+
5
>
>
>
x
=
5
+
length
(
3
,
``
yd
''
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
typeerror
:
unsupport
operand
type
(
s
)
for
+
:
'int
'
and
'length
'
>
>
>
Of
cours
,
the
left
side
ha
to
be
of
type
``
length
''
,
becaus
otherwis
python
tri
to
appli
the
__add__
method
from
int
,
which
ca
n't
cope
with
length
object
as
second
argument
!
python
provid
a
solut
for
thi
problem
as
well
.
It
's
the
__radd__
method
.
It
work
like
thi
:
python
tri
to
evalu
the
express
``
5
+
length
(
3
,
'yd
'
)
''
.
first
it
call
int.__add__
(
5
,
length
(
3
,
'yd
'
)
)
,
which
will
rais
an
except
.
after
thi
it
will
tri
to
invok
length.__radd__
(
length
(
3
,
``
yd
''
)
,
5
)
.
It
's
easi
to
recogn
that
the
implement
of
__radd__
is
analogu
to
__add__
:
def
__radd__
(
self
,
other
)
:
if
type
(
other
)
==
int
or
type
(
other
)
==
float
:
l
=
self.converse2metr
(
)
+
otherlength.__radd__
(
length
(
3
,
``
yd
''
)
,
5
)
els
:
l
=
self.converse2metr
(
)
+
other.converse2metr
(
)
return
length
(
l
/
length.__metr
[
self.unit
]
,
self.unit
)
It
's
advis
to
make
use
of
the
__add__
method
in
the
__radd__
method
:
def
__radd__
(
self
,
other
)
:
return
length.__add__
(
self
,
other
)
the
follow
diagram
illustr
the
relationship
between
__add__
and
__radd__
:
the
__call__
method
the
__call__
method
can
be
use
to
turn
the
instanc
of
the
class
into
callabl
.
function
are
callabl
object
.
A
callabl
object
is
an
object
which
can
be
use
and
behav
like
a
function
but
might
not
be
a
function
.
By
use
the
__call__
method
it
is
possibl
to
defin
class
in
a
way
that
the
instanc
will
be
callabl
object
.
the
__call__
method
is
call
,
if
the
instanc
is
call
``
like
a
function
''
,
i.e
.
use
bracket
.
the
follow
exampl
defin
a
class
with
which
we
can
creat
abitrari
polynomi
function
:
class
polynomi
:
def
__init__
(
self
,
*coeffici
)
:
self.coeffici
=
coeffici
[
:
:-1
]
def
__call__
(
self
,
x
)
:
re
=
0
for
index
,
coeff
in
enumer
(
self.coeffici
)
:
re
+=
coeff
*
x**
index
return
re
#
a
constant
function
p1
=
polynomi
(
42
)
#
a
straight
line
p2
=
polynomi
(
0.75
,
2
)
#
a
third
degre
polynomi
p3
=
polynomi
(
1
,
-0.5
,
0.75
,
2
)
for
i
in
rang
(
1
,
10
)
:
print
(
i
,
p1
(
i
)
,
p2
(
i
)
,
p3
(
i
)
)
these
are
the
result
of
the
previou
function
:
1
42
2.75
3.25
2
42
3.5
9.5
3
42
4.25
26.75
4
42
5.0
61.0
5
42
5.75
118.25
6
42
6.5
204.5
7
42
7.25
325.75
8
42
8.0
488.0
9
42
8.75
697.25
you
will
find
further
interest
exampl
of
the
__call__
function
in
our
tutori
in
the
chapter
decor
and
memoiz
with
decor
.
you
may
also
consult
our
chapter
on
polynomi
standard
class
as
base
class
It
's
possibl
to
use
standard
class
-
like
int
,
float
,
dict
or
list
-
as
base
class
as
well
.
We
extend
the
list
class
by
ad
a
push
method
:
class
plist
(
list
)
:
def
__init__
(
self
,
l
)
:
list.__init__
(
self
,
l
)
def
push
(
self
,
item
)
:
self.append
(
item
)
if
__name__
==
``
__main__
''
:
x
=
plist
(
[
3,4
]
)
x.push
(
47
)
print
(
x
)
thi
mean
that
all
the
previous
introduc
binari
and
extend
assign
oper
exist
in
the
``
revers
''
version
as
well
:
__radd__
__rsub__
__rmul__
...
and
so
on
exercis
write
a
class
with
the
name
cci
,
similar
to
the
previous
defin
length
class
.
cci
should
contain
valu
in
variou
currenc
,
e.g
.
``
eur
''
,
``
gbp
''
or
``
usd
''
.
An
instanc
should
contain
the
amount
and
the
currenc
unit
.
the
class
,
you
are
go
to
design
as
an
excercis
,
might
be
best
describ
with
the
follow
exampl
session
:
>
>
>
from
currenc
import
cci
>
>
>
v1
=
cci
(
23.43
,
``
eur
''
)
>
>
>
v2
=
cci
(
19.97
,
``
usd
''
)
>
>
>
print
(
v1
+
v2
)
32.89
eur
>
>
>
print
(
v2
+
v1
)
31.07
usd
>
>
>
print
(
v1
+
3
)
#
an
int
or
a
float
is
consid
to
be
a
eur
valu
27.43
eur
>
>
>
print
(
3
+
v1
)
27.43
eur
>
>
>
solut
to
our
exercis
first
exercis
:
``
''
''
the
class
``
cci
''
can
be
use
to
defin
money
valu
in
variou
currenc
.
A
cci
instanc
ha
the
string
attribut
'unit
'
(
e.g
.
'chf
'
,
'cad
'
od
'eur
'
and
the
'valu
'
as
a
float
.
A
currenc
object
consist
of
a
valu
and
the
correspond
unit.
``
''
''
class
cci
:
currenc
=
{
'chf
'
:
1.0821202355817312
,
'cad
'
:
1.488609845538393
,
'gbp
'
:
0.8916546282920325
,
'jpi
'
:
114.38826536281809
,
'eur
'
:
1.0
,
'usd
'
:
1.11123458162018
}
def
__init__
(
self
,
valu
,
unit=
''
eur
''
)
:
self.valu
=
valu
self.unit
=
unit
def
__str__
(
self
)
:
return
``
{
0:5.2f
}
''
.format
(
self.valu
)
+
``
``
+
self.unit
def
changeto
(
self
,
new_unit
)
:
``
''
''
An
cci
object
is
transform
from
the
unit
``
self.unit
''
to
``
new_unit
''
``
''
''
self.valu
=
(
self.valu
/
ccy.curr
[
self.unit
]
*
ccy.curr
[
new_unit
]
)
self.unit
=
new_unit
def
__add__
(
self
,
other
)
:
``
''
''
defin
the
'+
'
oper
.
If
other
is
a
cci
object
the
currenc
valu
are
ad
and
the
result
will
be
the
unit
of
self
.
If
other
is
an
int
or
a
float
,
other
will
be
treat
as
a
euro
value.
``
''
''
if
type
(
other
)
==
int
or
type
(
other
)
==
float
:
x
=
(
other
*
ccy.curr
[
self.unit
]
)
els
:
x
=
(
other.valu
/
ccy.curr
[
other.unit
]
*
ccy.curr
[
self.unit
]
)
return
cci
(
x
+
self.valu
,
self.unit
)
def
__iadd__
(
self
,
other
)
:
``
''
''
similar
to
__add__
``
''
''
if
type
(
other
)
==
int
or
type
(
other
)
==
float
:
x
=
(
other
*
ccy.curr
[
self.unit
]
)
els
:
x
=
(
other.valu
/
ccy.curr
[
other.unit
]
*
ccy.curr
[
self.unit
]
)
self.valu
+=
x
return
self
def
__radd__
(
self
,
other
)
:
re
=
self
+
other
if
self.unit
!
=
``
eur
''
:
res.changeto
(
``
eur
''
)
return
re
#
__sub__
,
__isub__
and
__rsub__
can
be
defin
analogu
x
=
cci
(
10
,
''
usd
''
)
y
=
cci
(
11
)
z
=
cci
(
12.34
,
``
jpi
''
)
z
=
7.8
+
x
+
y
+
255
+
z
print
(
z
)
lst
=
[
cci
(
10
,
''
usd
''
)
,
cci
(
11
)
,
cci
(
12.34
,
``
jpi
''
)
,
cci
(
12.34
,
``
cad
''
)
]
z
=
sum
(
lst
)
print
(
z
)
the
program
return
:
282.91
eur
28.40
eur
anoth
interest
aspect
of
thi
currenc
convert
class
in
python
can
be
shown
,
if
we
add
multipl
.
you
will
easili
understand
that
it
make
no
sens
to
allow
express
like
``
12.4
€
*
3.4
$
''
(
or
in
praefix
notat
:
``
€
12.4
*
$
3.4
''
)
,
but
it
make
perfect
sens
to
evalu
``
3
*
4.54
€
''
.
you
can
find
the
new
currenc
convert
class
with
the
newli
ad
method
for
__mul__
,
__imul__
and
__rmul__
in
the
follow
list
:
``
''
''
the
class
``
cci
''
can
be
use
to
defin
money
valu
in
variou
currenc
.
A
cci
instanc
ha
the
string
attribut
'unit
'
(
e.g
.
'chf
'
,
'cad
'
od
'eur
'
and
the
'valu
'
as
a
float
.
A
currenc
object
consist
of
a
valu
and
the
correspond
unit.
``
''
''
class
cci
:
currenc
=
{
'chf
'
:
1.0821202355817312
,
'cad
'
:
1.488609845538393
,
'gbp
'
:
0.8916546282920325
,
'jpi
'
:
114.38826536281809
,
'eur
'
:
1.0
,
'usd
'
:
1.11123458162018
}
def
__init__
(
self
,
valu
,
unit=
''
eur
''
)
:
self.valu
=
valu
self.unit
=
unit
def
__str__
(
self
)
:
return
``
{
0:5.2f
}
''
.format
(
self.valu
)
+
``
``
+
self.unit
def
__repr__
(
self
)
:
return
'cci
(
'
+
str
(
self.valu
)
+
'
,
``
'
+
self.unit
+
'
''
)
'
def
changeto
(
self
,
new_unit
)
:
``
''
''
An
cci
object
is
transform
from
the
unit
``
self.unit
''
to
``
new_unit
''
``
''
''
self.valu
=
(
self.valu
/
ccy.curr
[
self.unit
]
*
ccy.curr
[
new_unit
]
)
self.unit
=
new_unit
def
__add__
(
self
,
other
)
:
``
''
''
defin
the
'+
'
oper
.
If
other
is
a
cci
object
the
currenc
valu
are
ad
and
the
result
will
be
the
unit
of
self
.
If
other
is
an
int
or
a
float
,
other
will
be
treat
as
a
euro
value.
``
''
''
if
type
(
other
)
==
int
or
type
(
other
)
==
float
:
x
=
(
other
*
ccy.curr
[
self.unit
]
)
els
:
x
=
(
other.valu
/
ccy.curr
[
other.unit
]
*
ccy.curr
[
self.unit
]
)
return
cci
(
x
+
self.valu
,
self.unit
)
def
__iadd__
(
self
,
other
)
:
``
''
''
similar
to
__add__
``
''
''
if
type
(
other
)
==
int
or
type
(
other
)
==
float
:
x
=
(
other
*
ccy.curr
[
self.unit
]
)
els
:
x
=
(
other.valu
/
ccy.curr
[
other.unit
]
*
ccy.curr
[
self.unit
]
)
self.valu
+=
x
return
self
def
__radd__
(
self
,
other
)
:
re
=
self
+
other
if
self.unit
!
=
``
eur
''
:
res.changeto
(
``
eur
''
)
return
re
#
__sub__
,
__isub__
and
__rsub__
can
be
defin
analogu
def
__mul__
(
self
,
other
)
:
``
''
''
multipl
is
onli
defin
as
a
scalar
multipl
,
i.e
.
a
money
valu
can
be
multipli
by
an
int
or
a
float
.
It
is
not
possibl
to
multipli
to
money
valu
``
''
''
if
type
(
other
)
==int
or
type
(
other
)
==float
:
return
cci
(
self.valu
*
other
,
self.unit
)
els
:
rais
typeerror
(
``
unsupport
operand
type
(
s
)
for
*
:
'cci
'
and
``
+
type
(
other
)
.__name__
)
def
__rmul__
(
self
,
other
)
:
return
self.__mul__
(
other
)
def
__imul__
(
self
,
other
)
:
if
type
(
other
)
==int
or
type
(
other
)
==float
:
self.valu
*=
other
return
self
els
:
rais
typeerror
(
``
unsupport
operand
type
(
s
)
for
*
:
'cci
'
and
``
+
type
(
other
)
.__name__
)
assum
that
you
have
save
the
class
under
the
name
currency_convert
,
you
can
use
it
in
the
follow
way
in
the
command
shell
:
>
>
>
from
currency_convert
import
cci
>
>
>
x
=
cci
(
10.00
,
``
eur
''
)
>
>
>
y
=
cci
(
10.00
,
``
gbp
''
)
>
>
>
x
+
y
cci
(
21.215104685942173
,
``
eur
''
)
>
>
>
print
(
x
+
y
)
21.22
eur
>
>
>
print
(
2*x
+
y*0.9
)
30.09
eur
>
>
>
We
can
further
improv
our
currenc
convert
class
by
use
a
function
get_curr
,
which
download
the
latest
exchang
rate
from
finance.yahoo.com
.
thi
function
return
an
exchang
rate
dictionari
in
our
previous
use
format
.
the
function
is
in
a
modul
call
exchange_rates.pi
thi
is
the
code
of
the
function
exchange_rates.pi
:
from
urllib.request
import
urlopen
from
bs4
import
beautifulsoup
def
get_currency_r
(
base=
''
usd
''
)
:
``
''
''
the
file
at
locat
url
is
read
in
and
the
exchang
rate
are
extract
``
''
''
url
=
``
http
:
//finance.yahoo.com/webservice/v1/symbols/allcurrencies/quot
''
data
=
urlopen
(
url
)
.read
(
)
data
=
data.decod
(
'utf-8
'
)
soup
=
beautifulsoup
(
data
,
'html.parser
'
)
data
=
soup.get_text
(
)
flag
=
fals
currenc
=
{
}
for
line
in
data.splitlin
(
)
:
if
flag
:
valu
=
float
(
line
)
flag
=
fals
currenc
[
currenc
]
=
valu
if
line.startswith
(
``
usd/
''
)
:
flag
=
true
currenc
=
line
[
4:7
]
currenc
[
``
usd
''
]
=
1
#
we
must
add
it
,
becaus
it
's
not
includ
in
file
if
base
!
=
``
usd
''
:
base_currency_r
=
currenc
[
base
]
for
currenc
in
currenc
:
currenc
[
currenc
]
/=
base_currency_r
return
currenc
We
can
import
thi
function
from
our
modul
.
(
you
have
to
save
it
somewhar
in
your
python
path
or
the
directori
where
your
program
run
)
:
from
exchange_r
import
get_currency_r
class
cci
:
currenc
=
get_curr
(
)
#
continu
with
the
code
from
the
previou
version
We
save
thi
version
as
currency_converter_web
.
>
>
>
from
currency_converter_web
import
cci
>
>
>
x
=
cci
(
1000
,
``
jpi
''
)
>
>
>
y
=
cci
(
10
,
``
chf
''
)
>
>
>
z
=
cci
(
15
,
``
cad
''
)
>
>
>
print
(
2*x
+
4.11*i
+
z
)
7722.98
jpi
>
>
>
footnot
1
as
suggest
by
mark
jackson
previou
chapter
:
multipl
inherit
next
chapter
:
oop
,
inherit
exampl
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

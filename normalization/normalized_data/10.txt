machin
learn
with
python
:
text
classif
in
python
python
machin
learn
tutori
machin
learn
machin
learn
terminologyk-nearest
neighbor
classifierneur
network
from
scratch
in
pythonneur
network
in
python
use
numypybackpropag
in
neural
networksconfus
matrixtrain
and
test
with
mnistdropout
neural
networksneur
network
with
scikitmachin
learn
with
scikit
and
pythonintroduct
naiv
bay
classifierna
bay
classifi
with
scikitintroduct
into
text
classif
use
naiv
bayespython
implement
of
text
classificationdecis
treesregress
treesrandom
forestsboost
algorithmprincip
compon
analysislinear
discrimin
analysisexpect
maxim
and
gaussian
mixtur
modelintroduct
into
tensorflow
text
process
and
python
what
is
text
process
?
gener
speak
it
mean
take
some
form
of
textual
inform
and
work
on
it
,
i.e
.
extract
,
chang
or
ad
inform
.
programm
and
system
administr
use
text
process
,
when
work
with
log
file
,
configur
file
,
access
file
and
so
on
.
python
is
well
suit
for
text
process
.
thi
websit
is
creat
by
:
python
train
cours
in
toronto
,
canada
On
site
train
in
europ
,
canada
and
the
US
.
We
also
like
to
thank
denis
mitchinson
for
provid
the
style
sheet
of
thi
websit
.
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
text-klassifik
in
pythonpython
cours
thi
exampl
is
taken
from
the
python
cours
``
python
text
process
cours
''
by
bodenseo
.
text
classif
though
the
autom
classif
(
categor
)
of
text
ha
been
flourish
in
the
last
decad
or
so
,
it
ha
a
histori
,
which
date
back
to
about
1960
.
the
incred
increas
in
onlin
document
,
which
ha
been
mostli
due
to
the
expand
internet
,
ha
renew
the
interst
in
autom
document
classif
and
data
mine
.
while
text
classif
in
the
begin
wa
base
mainli
on
heurist
method
,
i.e
.
appli
a
set
of
rule
base
on
expert
knowledg
,
nowaday
the
focu
ha
turn
to
fulli
automat
learn
and
even
cluster
method
.
from
:
text
classif
at
bernd
klein
.
data
protect
declar
data
protect
declar
previou
chapter
:
introduct
into
text
classif
use
naiv
bay
next
chapter
:
decis
tree
text
classif
in
python
introduct
In
the
previou
chapter
,
we
have
deduc
the
formula
for
calcul
the
probabl
that
a
document
d
belong
to
a
categori
or
class
c
,
denot
as
P
(
c|d
)
.
We
have
transform
the
standard
formular
for
P
(
c|d
)
,
as
it
is
use
in
mani
treatises1
,
into
a
numer
stabl
form
.
We
use
a
naiv
bay
classifi
for
our
implement
in
python
.
the
formal
introduct
into
the
naiv
bay
approach
can
be
found
in
our
previou
chapter
.
python
is
ideal
for
text
classif
,
becaus
of
it
's
strong
string
class
with
power
method
.
furthermor
the
regular
express
modul
re
of
python
provid
the
user
with
tool
,
which
are
way
beyond
other
program
languag
.
the
onli
downsid
might
be
that
thi
python
implement
is
not
tune
for
effici
.
the
python
implement
warn
:
the
implement
is
in
python
3
and
it
is
not
compat
to
python
2.x
!
document
represent
the
document
represent
,
which
is
base
on
the
bag
of
word
model
,
is
illustr
in
the
follow
diagram
:
import
need
our
implement
need
the
regular
express
modul
re
and
the
os
modul
:
import
re
,
os
bagofword
class
class
bagofword
(
object
)
:
``
''
''
implement
a
bag
of
word
,
word
correspond
with
their
frequenc
of
usag
in
a
``
document
''
for
usag
by
the
document
class
,
documentclass
class
and
the
pool
class
.
''
''
''
def
__init__
(
self
)
:
self.__number_of_word
=
0
self.__bag_of_word
=
{
}
def
__add__
(
self
,
other
)
:
``
''
''
overload
of
the
``
+
''
oper
to
join
two
bagofword
``
''
''
erg
=
bagofword
(
)
sum
=
erg.__bag_of_word
for
key
in
self.__bag_of_word
:
sum
[
key
]
=
self.__bag_of_word
[
key
]
if
key
in
other.__bag_of_word
:
sum
[
key
]
+=
other.__bag_of_word
[
key
]
for
key
in
other.__bag_of_word
:
if
key
not
in
sum
:
sum
[
key
]
=
other.__bag_of_word
[
key
]
return
erg
def
add_word
(
self
,
word
)
:
``
''
''
A
word
is
ad
in
the
dictionari
__bag_of_word
''
''
''
self.__number_of_word
+=
1
if
word
in
self.__bag_of_word
:
self.__bag_of_word
[
word
]
+=
1
els
:
self.__bag_of_word
[
word
]
=
1
def
len
(
self
)
:
``
''
''
return
the
number
of
differ
word
of
an
object
``
''
''
return
len
(
self.__bag_of_word
)
def
word
(
self
)
:
``
''
''
return
a
list
of
the
word
contain
in
the
object
``
''
''
return
self.__bag_of_words.key
(
)
def
bagofword
(
self
)
:
``
''
''
return
the
dictionari
,
contain
the
word
(
key
)
with
their
frequenc
(
valu
)
''
''
''
return
self.__bag_of_word
def
wordfreq
(
self
,
word
)
:
``
''
''
return
the
frequenc
of
a
word
``
''
''
if
word
in
self.__bag_of_word
:
return
self.__bag_of_word
[
word
]
els
:
return
0
the
document
class
class
document
(
object
)
:
``
''
''
use
both
for
learn
(
train
)
document
and
for
test
document
.
the
option
paramet
lear
ha
to
be
set
to
true
,
if
a
classif
should
be
train
.
If
it
is
a
test
document
learn
ha
to
be
set
to
false.
``
''
''
_vocabulari
=
bagofword
(
)
def
__init__
(
self
,
vocabulari
)
:
self.__nam
=
``
''
self.__document_class
=
none
self._words_and_freq
=
bagofword
(
)
document._vocabulari
=
vocabulari
def
read_docu
(
self
,
filenam
,
learn=fals
)
:
``
''
''
A
document
is
read
.
It
is
assum
that
the
document
is
either
encod
in
utf-8
or
in
iso-8859
...
(
latin-1
)
.
the
word
of
the
document
are
store
in
a
bag
of
word
,
i.e
.
self._words_and_freq
=
bagofword
(
)
``
''
''
tri
:
text
=
open
(
filenam
,
''
r
''
,
encoding='utf-8
'
)
.read
(
)
except
unicodedecodeerror
:
text
=
open
(
filenam
,
''
r
''
,
encoding='latin-1
'
)
.read
(
)
text
=
text.low
(
)
word
=
re.split
(
r
''
\W
''
,
text
)
self._number_of_word
=
0
for
word
in
word
:
self._words_and_freq.add_word
(
word
)
if
learn
:
document._vocabulary.add_word
(
word
)
def
__add__
(
self
,
other
)
:
``
''
''
overload
the
``
+
''
oper
.
ad
two
document
consist
in
ad
the
bagofword
of
the
document
``
''
''
re
=
document
(
document._vocabulari
)
res._words_and_freq
=
self._words_and_freq
+
other._words_and_freq
return
re
def
vocabulary_length
(
self
)
:
``
''
''
return
the
length
of
the
vocabulari
``
''
''
return
len
(
document._vocabulari
)
def
wordsandfreq
(
self
)
:
``
''
''
return
the
dictionari
,
contain
the
word
(
key
)
with
their
frequenc
(
valu
)
as
contain
in
the
bagofword
attribut
of
the
document
''
''
''
return
self._words_and_freq.bagofword
(
)
def
word
(
self
)
:
``
''
''
return
the
word
of
the
document
object
``
''
''
d
=
self._words_and_freq.bagofword
(
)
return
d.key
(
)
def
wordfreq
(
self
,
word
)
:
``
''
''
return
the
number
of
time
the
word
``
word
''
appear
in
the
document
``
''
''
bow
=
self._words_and_freq.bagofword
(
)
if
word
in
bow
:
return
bow
[
word
]
els
:
return
0
def
__and__
(
self
,
other
)
:
``
''
''
intersect
of
two
document
.
A
list
of
word
occur
in
both
document
is
return
``
''
''
intersect
=
[
]
words1
=
self.word
(
)
for
word
in
other.word
(
)
:
if
word
in
words1
:
intersect
+=
[
word
]
return
intersect
the
documentclass
class
the
class
documentclass
is
the
class
for
our
document
categori
.
It
's
inherit
from
our
document
class
.
class
documentclass
(
document
)
:
def
__init__
(
self
,
vocabulari
)
:
document.__init__
(
self
,
vocabulari
)
self._number_of_doc
=
0
def
probabl
(
self
,
word
)
:
``
''
''
return
the
probabilti
of
the
word
``
word
''
given
the
class
``
self
''
``
''
''
voc_len
=
document._vocabulary.len
(
)
sumn
=
0
for
i
in
rang
(
voc_len
)
:
sumn
=
documentclass._vocabulary.wordfreq
(
word
)
N
=
self._words_and_freq.wordfreq
(
word
)
erg
=
1
+
N
erg
/=
voc_len
+
sumn
return
erg
def
__add__
(
self
,
other
)
:
``
''
''
overload
the
``
+
''
oper
.
ad
two
documentclass
object
consist
in
ad
the
bagofword
of
the
documentclass
objectss
``
''
''
re
=
documentclass
(
self._vocabulari
)
res._words_and_freq
=
self._words_and_freq
+
other._words_and_freq
return
re
def
setnumberofdoc
(
self
,
number
)
:
self._number_of_doc
=
number
def
numberofdocu
(
self
)
:
return
self._number_of_doc
the
pool
class
the
pool
is
the
class
,
where
the
document
class
are
learnt
and
kept
:
class
pool
(
object
)
:
def
__init__
(
self
)
:
self.__document_class
=
{
}
self.__vocabulari
=
bagofword
(
)
def
sum_words_in_class
(
self
,
dclass
)
:
``
''
''
the
number
of
time
all
differ
word
of
a
dclass
appear
in
a
class
``
''
''
sum
=
0
for
word
in
self.__vocabulary.word
(
)
:
waf
=
self.__document_class
[
dclass
]
.wordsandfreq
(
)
if
word
in
waf
:
sum
+=
waf
[
word
]
return
sum
def
learn
(
self
,
directori
,
dclass_nam
)
:
``
''
''
directori
is
a
path
,
where
the
file
of
the
class
with
the
name
dclass_nam
can
be
found
``
''
''
x
=
documentclass
(
self.__vocabulari
)
dir
=
os.listdir
(
directori
)
for
file
in
dir
:
d
=
document
(
self.__vocabulari
)
print
(
directori
+
``
/
''
+
file
)
d.read_docu
(
directori
+
``
/
''
+
file
,
learn
=
true
)
x
=
x
+
d
self.__document_class
[
dclass_nam
]
=
x
x.setnumberofdoc
(
len
(
dir
)
)
def
probabl
(
self
,
doc
,
dclass
=
``
''
)
:
``
''
''
calcul
the
probabl
for
a
class
dclass
given
a
document
doc
''
''
''
if
dclass
:
sum_dclass
=
self.sum_words_in_class
(
dclass
)
prob
=
0
d
=
document
(
self.__vocabulari
)
d.read_docu
(
doc
)
for
j
in
self.__document_class
:
sum_j
=
self.sum_words_in_class
(
j
)
prod
=
1
for
i
in
d.word
(
)
:
wf_dclass
=
1
+
self.__document_class
[
dclass
]
.wordfreq
(
i
)
wf
=
1
+
self.__document_class
[
j
]
.wordfreq
(
i
)
r
=
wf
*
sum_dclass
/
(
wf_dclass
*
sum_j
)
prod
*=
r
prob
+=
prod
*
self.__document_class
[
j
]
.numberofdocu
(
)
/
self.__document_class
[
dclass
]
.numberofdocu
(
)
if
prob
!
=
0
:
return
1
/
prob
els
:
return
-1
els
:
prob_list
=
[
]
for
dclass
in
self.__document_class
:
prob
=
self.prob
(
doc
,
dclass
)
prob_list.append
(
[
dclass
,
prob
]
)
prob_list.sort
(
key
=
lambda
x
:
x
[
1
]
,
revers
=
true
)
return
prob_list
def
documentintersectionwithclass
(
self
,
doc_nam
)
:
re
=
[
doc_nam
]
for
dc
in
self.__document_class
:
d
=
document
(
self.__vocabulari
)
d.read_docu
(
doc_nam
,
learn=fals
)
o
=
self.__document_class
[
dc
]
&
d
intersection_ratio
=
len
(
o
)
/
len
(
d.word
(
)
)
re
+=
(
dc
,
intersection_ratio
)
return
re
use
the
classifi
To
be
abl
to
learn
and
test
a
classifi
,
wie
offer
a
``
learn
and
test
set
to
download
''
.
the
modul
naivebay
consist
of
the
code
we
have
provid
so
far
,
but
it
can
be
download
for
conveni
as
naivebayes.pi
the
learn
and
test
set
contain
(
old
)
joke
label
in
six
categori
:
``
clinton
''
,
``
lawyer
''
,
``
math
''
,
``
medic
''
,
``
music
''
,
``
sex
''
.
from
naivebay
import
pool
import
os
dclass
=
[
``
clinton
''
,
``
lawyer
''
,
``
math
''
,
``
medic
''
,
``
music
''
,
``
sex
''
]
base
=
``
learn/
''
p
=
pool
(
)
for
i
in
dclass
:
p.learn
(
base
+
i
,
i
)
base
=
``
test/
''
for
i
in
dclass
:
dir
=
os.listdir
(
base
+
i
)
for
file
in
dir
:
re
=
p.probabl
(
base
+
i
+
``
/
''
+
file
)
print
(
i
+
``
:
``
+
file
+
``
:
``
+
str
(
re
)
)
the
output
of
the
previou
program
is
contain
in
the
file
naivebayes_example_results.txt
footnot
:
1
pleas
see
our
``
further
read
''
section
of
our
previou
chapter
previou
chapter
:
introduct
into
text
classif
use
naiv
bay
next
chapter
:
decis
tree
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

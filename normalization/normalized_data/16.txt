python
tutori
:
multipl
inherit
python
cours
python
3
tutori
the
origin
of
pythonstart
with
python
:
the
interact
shellexecut
a
scriptindentationdata
type
and
variablesoperatorssequenti
data
type
:
list
and
stringslist
manipulationsshallow
and
deep
copydictionariesset
and
frozen
setsan
extens
exampl
use
setsinput
via
the
keyboardcondit
statementsloop
,
while
loopfor
loopsdiffer
between
inter
und
iterablesoutput
with
printformat
output
with
string
modulo
and
the
format
methodfunctionsrecurs
and
recurs
functionsparamet
pass
in
functionsnamespacesglob
and
local
variablesdecoratorsmemo
with
decoratorsread
and
write
filesmodular
program
and
modulespackag
in
pythonregular
expressionsregular
express
,
advancedlambda
oper
,
filter
,
reduc
and
maplist
comprehensioniter
and
generatorsexcept
handlingtest
,
doctest
,
unittestsobject
orient
programmingclass
and
instanc
attributesproperti
vs.
getter
and
settersinheritancemultipl
inheritancemag
method
and
oper
overloadingoop
,
inherit
exampleslotsclass
and
class
creationroad
to
metaclassesmetaclassesmetaclass
use
case
:
count
function
callsabstract
class
object-ori
program
``
certainli
not
everi
good
program
is
object-ori
,
and
not
everi
object-ori
program
is
good
.
''
(
bjarn
stroustrup
,
danish
comput
scientist
,
best
known
for
the
creation
and
the
develop
of
the
wide
use
c++
program
languag
.
)
``
object-ori
program
is
an
except
bad
idea
which
could
onli
have
origin
in
california
.
''
(
edsger
dijkstra
,
(
dutch
comput
scientist
,
1930-2002
)
dijkstra
also
said
:
``
...
what
societi
over足whel足mingli
ask
for
is
snake
oil
.
Of
cours
,
the
snake
oil
ha
the
most
impress
name
-
otherwis
you
would
be
sell
noth
-
like
``
structur
analysi
and
design
''
,
``
softwar
engin
''
,
``
matur
model
''
,
``
manag
inform
system
''
,
``
integr
project
support
environ
''
``
object
orient
''
and
``
busi
process
re-engin
''
japanes
food
and
oop
``
and
in
conclus
:
I
realli
like
japanes
food
and
object-ori
program
--
but
if
these
were
all
there
were
to
fine
food
and
proper
program
,
I
'd
give
it
all
up
and
go
flip
burger
.
``
,
sean
M.
burk
thi
websit
is
support
by
:
linux
and
python
cours
and
seminar
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
端bersetzung
:
mehrfachvererbung
classroom
train
cours
the
goal
of
thi
websit
is
to
provid
educ
materi
,
allow
you
to
learn
python
on
your
own
.
nevertheless
,
it
is
faster
and
more
effici
to
attend
a
``
real
''
python
cours
in
a
classroom
,
with
an
experienc
trainer
.
So
whi
not
attend
one
of
the
live
python
cours
in
strasbourg
,
pari
,
luxembourg
,
amsterdam
,
z端rich
/
zurich
,
vienna
/
wien
,
london
,
berlin
,
munich
,
hamburg
,
frankfurt
,
or
lake
constanc
by
bernd
klein
,
the
author
of
thi
tutori
?
onsit
train
cours
let
us
come
to
your
compani
or
institut
and
train
your
employe
,
as
we
've
done
it
mani
time
in
amsterdam
(
the
netherland
)
,
berlin
(
germani
)
,
bern
(
switzerland
)
,
basel
(
switzerland
)
,
zurich
(
switzerland
)
,
locarno
(
switzerland
)
,
den
haag
(
the
hagu
)
,
hamburg
(
germani
)
,
frankfurt
(
germani
)
,
toronto
(
canada
)
,
edmonton
(
canada
)
,
munich
(
germani
)
,
vienna
/
wien
(
austria
)
and
mani
other
citi
.
We
do
train
cours
in
england
,
switzerland
,
liechtenstein
,
austria
,
germani
,
franc
,
belgium
,
the
netherland
,
luxembourg
,
poland
,
UK
,
itali
and
other
locat
in
europ
and
in
canada
.
thi
way
you
will
get
a
perfect
train
up
to
your
need
and
it
will
be
extrem
cost
effici
as
well
.
contact
us
so
we
can
defin
and
find
the
best
cours
curriculum
to
meet
your
need
,
and
schedul
cours
session
to
be
held
at
your
locat
.
skill
python
programm
you
are
look
for
experienc
python
develop
or
programm
?
We
can
help
you
,
pleas
contact
us
.
quot
of
the
day
:
A
comput
would
deserv
to
be
call
intellig
if
it
could
deceiv
a
human
into
believ
that
it
wa
human
.
alan
ture
data
protect
declar
data
protect
declar
previou
chapter
:
inherit
next
chapter
:
magic
method
and
oper
overload
multipl
inherit
introduct
In
the
previou
chapter
of
our
tutori
,
we
have
cover
inherit
,
or
more
specif
``
singl
inherit
''
.
As
we
have
seen
,
a
class
inherit
in
thi
case
from
one
class
.
multipl
inherit
on
the
other
hand
is
a
featur
in
which
a
class
can
inherit
attribut
and
method
from
more
than
one
parent
class
.
the
critic
point
out
that
multipl
inherit
come
along
with
a
high
level
of
complex
and
ambigu
in
situat
such
as
the
diamond
problem
.
We
will
address
thi
problem
later
in
thi
chapter
.
the
widespread
prejudic
that
multipl
inherit
is
someth
``
danger
''
or
``
bad
''
is
mostli
nourish
by
program
languag
with
poorli
implement
multipl
inherit
mechan
and
abov
all
by
improp
usag
of
it
.
java
doe
n't
even
support
multipl
inherit
,
while
c++
support
it
.
python
ha
a
sophist
and
well-design
approach
to
multipl
inherit
.
A
class
definit
,
where
a
child
class
subclassnam
inherit
from
the
parent
class
baseclass1
,
baseclass2
,
baseclass3
,
and
so
on
,
look
like
thi
:
class
subclassnam
(
baseclass1
,
baseclass2
,
baseclass3
,
...
)
:
pass
It
's
clear
that
all
the
superclass
baseclass1
,
baseclass2
,
baseclass3
,
...
can
inherit
from
other
superclass
as
well
.
what
we
get
is
an
inherit
tree
.
exampl
:
calendarclock
We
want
to
introduc
the
principl
of
multipl
inherit
with
an
exampl
.
for
thi
purpos
,
we
will
implement
to
independ
class
:
a
``
clock
''
and
a
``
calendar
''
class
.
after
thi
,
we
will
introduc
a
class
``
calendarclock
''
,
which
is
,
as
the
name
impli
,
a
combin
of
``
clock
''
and
``
calendar
''
.
calendarclock
inherit
both
from
``
clock
''
and
``
calendar
''
.
the
class
clock
simul
the
tick-tack
of
a
clock
.
An
instanc
of
thi
class
contain
the
time
,
which
is
store
in
the
attribut
self.hour
,
self.minut
and
self.second
.
princip
,
we
could
have
written
the
__init__
method
and
the
set
method
like
thi
:
def
__init__
(
self
,
hours=0
,
minutes=0
,
seconds=0
)
:
self._hour
=
hour
self.__minut
=
minut
self.__second
=
second
def
set
(
self
,
hour
,
minut
,
seconds=0
)
:
self._hour
=
hour
self.__minut
=
minut
self.__second
=
second
We
decid
against
thi
implement
,
becaus
we
ad
addit
code
for
check
the
plausibl
of
the
time
data
into
the
set
method
.
We
call
the
set
method
from
the
__init__
method
as
well
,
becaus
we
want
to
circumv
redund
code
.
the
complet
clock
class
:
``
''
''
the
class
clock
is
use
to
simul
a
clock.
``
''
''
class
clock
(
object
)
:
def
__init__
(
self
,
hour
,
minut
,
second
)
:
``
''
''
the
paramat
hour
,
minut
and
second
have
to
be
integ
and
must
satisfi
the
follow
equat
:
0
<
=
h
<
24
0
<
=
m
<
60
0
<
=
s
<
60
``
''
''
self.set_clock
(
hour
,
minut
,
second
)
def
set_clock
(
self
,
hour
,
minut
,
second
)
:
``
''
''
the
paramet
hour
,
minut
and
second
have
to
be
integ
and
must
satisfi
the
follow
equat
:
0
<
=
h
<
24
0
<
=
m
<
60
0
<
=
s
<
60
``
''
''
if
type
(
hour
)
==
int
and
0
<
=
hour
and
hour
<
24
:
self._hour
=
hour
els
:
rais
typeerror
(
``
hour
have
to
be
integ
between
0
and
23
!
''
)
if
type
(
minut
)
==
int
and
0
<
=
minut
and
minut
<
60
:
self.__minut
=
minut
els
:
rais
typeerror
(
``
minut
have
to
be
integ
between
0
and
59
!
''
)
if
type
(
second
)
==
int
and
0
<
=
second
and
second
<
60
:
self.__second
=
second
els
:
rais
typeerror
(
``
second
have
to
be
integ
between
0
and
59
!
''
)
def
__str__
(
self
)
:
return
``
{
0:02d
}
:
{
1:02d
}
:
{
2:02d
}
''
.format
(
self._hour
,
self.__minut
,
self.__second
)
def
tick
(
self
)
:
``
''
''
thi
method
let
the
clock
``
tick
''
,
thi
mean
that
the
intern
time
will
be
advanc
by
one
second
.
exampl
:
>
>
>
x
=
clock
(
12,59,59
)
>
>
>
print
(
x
)
12:59:59
>
>
>
x.tick
(
)
>
>
>
print
(
x
)
13:00:00
>
>
>
x.tick
(
)
>
>
>
print
(
x
)
13:00:01
``
''
''
if
self.__second
==
59
:
self.__second
=
0
if
self.__minut
==
59
:
self.__minut
=
0
if
self._hour
==
23
:
self._hour
=
0
els
:
self._hour
+=
1
els
:
self.__minut
+=
1
els
:
self.__second
+=
1
if
__name__
==
``
__main__
''
:
x
=
clock
(
23,59,59
)
print
(
x
)
x.tick
(
)
print
(
x
)
y
=
str
(
x
)
print
(
type
(
y
)
)
If
you
call
thi
modul
standalon
,
you
get
the
follow
output
:
$
python3
clock.pi
23:59:59
00:00:00
<
class
'str
'
>
let
's
check
our
except
handl
by
input
float
and
string
as
input
.
We
also
check
,
what
happen
,
if
we
exceed
the
limit
of
the
expect
valu
:
>
>
>
from
clock
import
clock
>
>
>
x
=
clock
(
7.7,45,17
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
file
``
clock.pi
''
,
line
16
,
in
__init__
self.set_clock
(
hour
,
minut
,
second
)
file
``
clock.pi
''
,
line
30
,
in
set_clock
rais
typeerror
(
``
hour
have
to
be
integ
between
0
and
23
!
''
)
typeerror
:
hour
have
to
be
integ
between
0
and
23
!
>
>
>
x
=
clock
(
24,45,17
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
file
``
clock.pi
''
,
line
16
,
in
__init__
self.set_clock
(
hour
,
minut
,
second
)
file
``
clock.pi
''
,
line
30
,
in
set_clock
rais
typeerror
(
``
hour
have
to
be
integ
between
0
and
23
!
''
)
typeerror
:
hour
have
to
be
integ
between
0
and
23
!
>
>
>
x
=
clock
(
23,60,17
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
file
``
clock.pi
''
,
line
16
,
in
__init__
self.set_clock
(
hour
,
minut
,
second
)
file
``
clock.pi
''
,
line
34
,
in
set_clock
rais
typeerror
(
``
minut
have
to
be
integ
between
0
and
59
!
''
)
typeerror
:
minut
have
to
be
integ
between
0
and
59
!
>
>
>
x
=
clock
(
``
23
''
,
''
60
''
,
''
17
''
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
file
``
clock.pi
''
,
line
16
,
in
__init__
self.set_clock
(
hour
,
minut
,
second
)
file
``
clock.pi
''
,
line
30
,
in
set_clock
rais
typeerror
(
``
hour
have
to
be
integ
between
0
and
23
!
''
)
typeerror
:
hour
have
to
be
integ
between
0
and
23
!
>
>
>
>
>
>
x
=
clock
(
23,17
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
typeerror
:
__init__
(
)
take
exactli
4
argument
(
3
given
)
>
>
>
We
will
now
creat
a
class
``
calendar
''
,
which
ha
lot
of
similar
to
the
previous
defin
clock
class
.
instead
of
``
tick
''
we
have
an
``
advanc
''
method
,
which
advanc
the
date
by
one
day
,
whenev
it
is
call
.
ad
a
day
to
a
date
is
quit
tricki
.
We
have
to
check
,
if
the
date
is
the
last
day
in
a
month
and
the
number
of
day
in
the
month
vari
.
As
if
thi
is
n't
bad
enough
,
we
have
februari
and
the
leap
year
problem
.
the
rule
for
calcul
a
leap
year
are
the
follow
:
If
a
year
is
divis
by
400
,
it
is
a
leap
year
.
If
a
year
is
not
divis
by
400
but
by
100
,
it
is
not
a
leap
year
.
A
year
number
which
is
divis
by
4
but
not
by
100
,
it
is
a
leap
year
.
all
other
year
number
are
common
year
,
i.e
.
no
leap
year
.
As
a
littl
use
gimmick
,
we
ad
a
possibl
to
output
a
date
either
in
british
or
in
american
(
canadian
)
style.
``
''
''
the
class
calendar
implement
a
calendar.
``
''
''
class
calendar
(
object
)
:
month
=
(
31,28,31,30,31,30,31,31,30,31,30,31
)
date_styl
=
``
british
''
@
staticmethod
def
leapyear
(
year
)
:
``
''
''
the
method
leapyear
return
true
if
the
paramet
year
is
a
leap
year
,
fals
otherwis
``
''
''
if
not
year
%
4
==
0
:
return
fals
elif
not
year
%
100
==
0
:
return
true
elif
not
year
%
400
==
0
:
return
fals
els
:
return
true
def
__init__
(
self
,
d
,
m
,
y
)
:
``
''
''
d
,
m
,
y
have
to
be
integ
valu
and
year
ha
to
be
a
four
digit
year
number
``
''
''
self.set_calendar
(
d
,
m
,
y
)
def
set_calendar
(
self
,
d
,
m
,
y
)
:
``
''
''
d
,
m
,
y
have
to
be
integ
valu
and
year
ha
to
be
a
four
digit
year
number
``
''
''
if
type
(
d
)
==
int
and
type
(
m
)
==
int
and
type
(
y
)
==
int
:
self.__day
=
d
self.__month
=
m
self.__year
=
y
els
:
rais
typeerror
(
``
d
,
m
,
y
have
to
be
integ
!
''
)
def
__str__
(
self
)
:
if
calendar.date_styl
==
``
british
''
:
return
``
{
0:02d
}
/
{
1:02d
}
/
{
2:4d
}
''
.format
(
self.__day
,
self.__month
,
self.__year
)
els
:
#
assum
american
style
return
``
{
0:02d
}
/
{
1:02d
}
/
{
2:4d
}
''
.format
(
self.__month
,
self.__day
,
self.__year
)
def
advanc
(
self
)
:
``
''
''
thi
method
advanc
to
the
next
date.
``
''
''
max_day
=
calendar.month
[
self.__months-1
]
if
self.__month
==
2
and
calendar.leapyear
(
self.__year
)
:
max_day
+=
1
if
self.__day
==
max_day
:
self.__days=
1
if
self.__month
==
12
:
self.__month
=
1
self.__year
+=
1
els
:
self.__month
+=
1
els
:
self.__day
+=
1
if
__name__
==
``
__main__
''
:
x
=
calendar
(
31,12,2012
)
print
(
x
,
end=
''
``
)
x.advanc
(
)
print
(
``
after
appli
advanc
:
``
,
x
)
print
(
``
2012
wa
a
leapyear
:
''
)
x
=
calendar
(
28,2,2012
)
print
(
x
,
end=
''
``
)
x.advanc
(
)
print
(
``
after
appli
advanc
:
``
,
x
)
x
=
calendar
(
28,2,2013
)
print
(
x
,
end=
''
``
)
x.advanc
(
)
print
(
``
after
appli
advanc
:
``
,
x
)
print
(
``
1900
no
leapyear
:
number
divis
by
100
but
not
by
400
:
``
)
x
=
calendar
(
28,2,1900
)
print
(
x
,
end=
''
``
)
x.advanc
(
)
print
(
``
after
appli
advanc
:
``
,
x
)
print
(
``
2000
wa
a
leapyear
,
becaus
number
divisib
by
400
:
``
)
x
=
calendar
(
28,2,2000
)
print
(
x
,
end=
''
``
)
x.advanc
(
)
print
(
``
after
appli
advanc
:
``
,
x
)
print
(
``
switch
to
american
date
style
:
``
)
calendar.date_styl
=
``
american
''
print
(
``
after
appli
advanc
:
``
,
x
)
start
thi
script
provid
us
with
the
follow
result
:
$
python3
calendar.pi
31.12.2012
after
appli
advanc
:
01.01.2013
2012
wa
a
leapyear
:
28.02.2012
after
appli
advanc
:
29.02.2012
28.02.2013
after
appli
advanc
:
01.03.2013
1900
no
leapyear
:
number
divis
by
100
but
not
by
400
:
28.02.1900
after
appli
advanc
:
01.03.1900
2000
wa
a
leapyear
,
becaus
number
divisib
by
400
:
28.02.2000
after
appli
advanc
:
29.02.2000
switch
to
american
date
style
:
after
appli
advanc
:
02/29/2000
At
last
,
we
will
come
to
our
multipl
inherit
exampl
.
We
are
now
capabl
of
implement
the
origin
intend
class
calendarclock
,
which
will
inherit
from
both
clock
and
calendar
.
the
method
``
tick
''
of
clock
will
have
to
be
overridden
.
howev
,
the
new
tick
method
of
calendarclock
ha
to
call
the
tick
method
of
clock
:
clock.tick
(
self
)
``
''
''
modul
,
which
implement
the
class
calendarclock.
``
''
''
from
clock
import
clock
from
calendar
import
calendar
class
calendarclock
(
clock
,
calendar
)
:
``
''
''
the
class
calendarclock
implement
a
clock
with
integr
calendar
.
It
's
a
case
of
multipl
inherit
,
as
it
inherit
both
from
clock
and
calendar
``
''
''
def
__init__
(
self
,
day
,
month
,
year
,
hour
,
minut
,
second
)
:
clock.__init__
(
self
,
hour
,
minut
,
second
)
calendar.__init__
(
self
,
day
,
month
,
year
)
def
tick
(
self
)
:
``
''
''
advanc
the
clock
by
one
second
``
''
''
previous_hour
=
self._hour
clock.tick
(
self
)
if
(
self._hour
<
previous_hour
)
:
self.adv
(
)
def
__str__
(
self
)
:
return
calendar.__str__
(
self
)
+
``
,
``
+
clock.__str__
(
self
)
if
__name__
==
``
__main__
''
:
x
=
calendarclock
(
31,12,2013,23,59,59
)
print
(
``
one
tick
from
``
,
x
,
end=
''
``
)
x.tick
(
)
print
(
``
to
``
,
x
)
x
=
calendarclock
(
28,2,1900,23,59,59
)
print
(
``
one
tick
from
``
,
x
,
end=
''
``
)
x.tick
(
)
print
(
``
to
``
,
x
)
x
=
calendarclock
(
28,2,2000,23,59,59
)
print
(
``
one
tick
from
``
,
x
,
end=
''
``
)
x.tick
(
)
print
(
``
to
``
,
x
)
x
=
calendarclock
(
7,2,2013,13,55,40
)
print
(
``
one
tick
from
``
,
x
,
end=
''
``
)
x.tick
(
)
print
(
``
to
``
,
x
)
the
output
of
the
program
hope
further
clarifi
what
's
go
on
in
thi
class
:
$
python3
calendar_clock.pi
one
tick
from
31/12/2013
,
23:59:59
to
01/01/2014
,
00:00:00
one
tick
from
28/02/1900
,
23:59:59
to
01/03/1900
,
00:00:00
one
tick
from
28/02/2000
,
23:59:59
to
29/02/2000
,
00:00:00
one
tick
from
07/02/2013
,
13:55:40
to
07/02/2013
,
13:55:41
the
diamond
problem
or
the
,
,deadli
diamond
of
death
''
the
``
diamond
problem
''
(
sometim
refer
to
as
the
``
deadli
diamond
of
death
''
)
is
the
gener
use
term
for
an
ambigu
that
aris
when
two
class
B
and
C
inherit
from
a
superclass
A
,
and
anoth
class
D
inherit
from
both
B
and
C.
If
there
is
a
method
``
m
''
in
A
that
B
or
C
(
or
even
both
of
them
)
)
ha
overridden
,
and
furthermor
,
if
doe
not
overrid
thi
method
,
then
the
question
is
which
version
of
the
method
doe
D
inherit
?
It
could
be
the
one
from
A
,
B
or
C
let
's
look
at
python
.
the
first
diamond
problem
configur
is
like
thi
:
both
B
and
C
overrid
the
method
m
of
A
:
class
A
:
def
m
(
self
)
:
print
(
``
m
of
A
call
''
)
class
B
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
B
call
''
)
class
C
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
C
call
''
)
class
D
(
B
,
C
)
:
pass
If
you
call
the
method
m
on
an
instanc
x
of
D
,
i.e
.
x.m
(
)
,
we
will
get
the
output
``
m
of
B
call
''
.
If
we
transpos
the
order
of
the
class
in
the
class
header
of
D
in
``
class
D
(
C
,
B
)
:
''
,
we
will
get
the
output
``
m
of
C
call
''
.
the
case
in
which
m
will
be
overridden
onli
in
one
of
the
class
B
or
C
,
e.g
.
in
C
:
class
A
:
def
m
(
self
)
:
print
(
``
m
of
A
call
''
)
class
B
(
A
)
:
pass
class
C
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
C
call
''
)
class
D
(
B
,
C
)
:
pass
x
=
D
(
)
x.m
(
)
principi
,
two
possibl
are
imagin
:
``
m
of
C
''
or
``
m
of
A
''
could
be
use
We
call
thi
script
with
python2.7
(
python
)
and
with
python3
(
python3
)
to
see
what
's
happen
:
$
python
diamond1.pi
m
of
A
call
$
python3
diamond1.pi
m
of
C
call
onli
for
those
who
are
interest
in
python
version2
:
To
have
the
same
inherit
behaviour
in
python2
as
in
python3
,
everi
class
ha
to
inherit
from
the
class
``
object
''
.
our
class
A
doe
n't
inherit
from
object
,
so
we
get
a
so-cal
old-styl
class
,
if
we
call
the
script
with
python2
.
multipl
inherit
with
old-styl
class
is
govern
by
two
rule
:
depth-first
and
then
left-to-right
.
If
you
chang
the
header
line
of
A
into
``
class
A
(
object
)
:
''
,
we
will
have
the
same
behaviour
in
both
python
version
.
super
and
mro
We
have
seen
in
our
previou
implement
of
the
diamond
problem
,
how
python
``
solv
''
the
problem
,
i.e
.
in
which
order
the
base
class
are
brows
through
.
the
order
is
defin
by
the
so-cal
``
method
resolut
order
''
or
in
short
mro.1\
We
will
extend
our
previou
exampl
,
so
that
everi
class
defin
it
own
method
m
:
class
A
:
def
m
(
self
)
:
print
(
``
m
of
A
call
''
)
class
B
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
B
call
''
)
class
C
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
C
call
''
)
class
D
(
B
,
C
)
:
def
m
(
self
)
:
print
(
``
m
of
D
call
''
)
let
's
appli
the
method
m
on
an
instanc
of
D.
We
can
see
that
onli
the
code
of
the
method
m
of
D
will
be
execut
.
We
can
also
explicitli
call
the
method
m
of
the
other
class
via
the
class
name
,
as
we
demonstr
in
the
follow
interact
python
session
:
>
>
>
from
super1
import
A
,
B
,
C
,
D
>
>
>
x
=
D
(
)
>
>
>
b.m
(
x
)
m
of
B
call
>
>
>
c.m
(
x
)
m
of
C
call
>
>
>
a.m
(
x
)
m
of
A
call
now
let
's
assum
that
the
method
m
of
D
should
execut
the
code
of
m
of
B
,
C
and
A
as
well
,
when
it
is
call
.
We
could
implement
it
like
thi
:
class
D
(
B
,
C
)
:
def
m
(
self
)
:
print
(
``
m
of
D
call
''
)
b.m
(
self
)
c.m
(
self
)
a.m
(
self
)
the
output
is
what
we
have
been
look
for
:
>
>
>
from
mro
import
D
>
>
>
x
=
D
(
)
>
>
>
x.m
(
)
m
of
D
call
m
of
B
call
m
of
C
call
m
of
A
call
but
it
turn
out
onc
more
that
thing
are
more
complic
than
it
seem
.
how
can
we
cope
with
the
situat
,
if
both
m
of
B
and
m
of
C
will
have
to
call
m
of
A
as
well
.
In
thi
case
,
we
have
to
take
away
the
call
a.m
(
self
)
from
m
in
D.
the
code
might
look
like
thi
,
but
there
is
still
a
bug
lurk
in
it
:
class
A
:
def
m
(
self
)
:
print
(
``
m
of
A
call
''
)
class
B
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
B
call
''
)
a.m
(
self
)
class
C
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
C
call
''
)
a.m
(
self
)
class
D
(
B
,
C
)
:
def
m
(
self
)
:
print
(
``
m
of
D
call
''
)
b.m
(
self
)
c.m
(
self
)
the
bug
is
that
the
method
m
of
A
will
be
call
twice
:
>
>
>
from
super3
import
D
>
>
>
x
=
D
(
)
>
>
>
x.m
(
)
m
of
D
call
m
of
B
call
m
of
A
call
m
of
C
call
m
of
A
call
one
way
to
solv
thi
problem
-
admittedli
not
a
python
one
-
consist
in
split
the
method
m
of
B
and
C
in
two
method
.
the
first
method
,
call
_m
consist
of
the
specif
code
for
B
and
C
and
the
other
method
is
still
call
m
,
but
consist
now
of
a
call
``
self._m
(
)
''
and
a
call
``
a.m
(
self
)
''
.
the
code
of
the
method
m
of
D
consist
now
of
the
specif
code
of
D
'print
(
``
m
of
D
call
''
)
'
,
and
the
call
b._m
(
self
)
,
c._m
(
self
)
and
a.m
(
self
)
:
class
A
:
def
m
(
self
)
:
print
(
``
m
of
A
call
''
)
class
B
(
A
)
:
def
_m
(
self
)
:
print
(
``
m
of
B
call
''
)
def
m
(
self
)
:
self._m
(
)
a.m
(
self
)
class
C
(
A
)
:
def
_m
(
self
)
:
print
(
``
m
of
C
call
''
)
def
m
(
self
)
:
self._m
(
)
a.m
(
self
)
class
D
(
B
,
C
)
:
def
m
(
self
)
:
print
(
``
m
of
D
call
''
)
b._m
(
self
)
c._m
(
self
)
a.m
(
self
)
our
problem
is
solv
,
but
-
as
we
have
alreadi
mention
-
not
in
a
python
way
:
>
>
>
from
super4
import
D
>
>
>
x
=
D
(
)
>
>
>
x.m
(
)
m
of
D
call
m
of
B
call
m
of
C
call
m
of
A
call
the
optim
way
to
solv
the
problem
,
which
is
the
``
super
''
python
way
,
consist
in
call
the
super
function
:
class
A
:
def
m
(
self
)
:
print
(
``
m
of
A
call
''
)
class
B
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
B
call
''
)
super
(
)
.m
(
)
class
C
(
A
)
:
def
m
(
self
)
:
print
(
``
m
of
C
call
''
)
super
(
)
.m
(
)
class
D
(
B
,
C
)
:
def
m
(
self
)
:
print
(
``
m
of
D
call
''
)
super
(
)
.m
(
)
It
also
solv
our
problem
,
but
in
a
beauti
design
as
well
:
>
>
>
from
super5
import
D
>
>
>
x
=
D
(
)
>
>
>
x.m
(
)
m
of
D
call
m
of
B
call
m
of
C
call
m
of
A
call
the
super
function
is
often
use
when
instanc
are
initi
with
the
__init__
method
:
class
A
:
def
__init__
(
self
)
:
print
(
``
a.__init__
''
)
class
B
(
A
)
:
def
__init__
(
self
)
:
print
(
``
b.__init__
''
)
super
(
)
.__init__
(
)
class
C
(
A
)
:
def
__init__
(
self
)
:
print
(
``
c.__init__
''
)
super
(
)
.__init__
(
)
class
D
(
B
,
C
)
:
def
__init__
(
self
)
:
print
(
``
d.__init__
''
)
super
(
)
.__init__
(
)
We
demonstr
the
way
of
work
in
the
follow
interact
session
:
>
>
>
from
super_init
import
A
,
B
,
C
,
D
>
>
>
d
=
D
(
)
d.__init__
b.__init__
c.__init__
a.__init__
>
>
>
c
=
C
(
)
c.__init__
a.__init__
>
>
>
b
=
B
(
)
b.__init__
a.__init__
>
>
>
a
=
A
(
)
a.__init__
the
question
aris
how
the
super
function
make
it
decis
.
how
doe
it
decid
which
class
ha
to
be
use
?
As
we
have
alreadi
mention
,
it
use
the
so-cal
method
resolut
order
(
mro
)
.
It
is
base
on
the
``
C3
superclass
linearis
''
algorithm
.
thi
is
call
a
linearis
,
becaus
the
tree
structur
is
broken
down
into
a
linear
order
.
the
mro
method
can
be
use
to
creat
thi
list
:
>
>
>
from
super_init
import
A
,
B
,
C
,
D
>
>
>
d.mro
(
)
[
<
class
'super_init.d
'
>
,
<
class
'super_init.b
'
>
,
<
class
'super_init.c
'
>
,
<
class
'super_init.a
'
>
,
<
class
'object
'
>
]
>
>
>
b.mro
(
)
[
<
class
'super_init.b
'
>
,
<
class
'super_init.a
'
>
,
<
class
'object
'
>
]
>
>
>
a.mro
(
)
[
<
class
'super_init.a
'
>
,
<
class
'object
'
>
]
polymorph
polymorph
is
constru
from
two
greek
word
.
``
poli
''
stand
for
``
much
''
or
``
mani
''
and
``
morph
''
mean
shape
or
form
.
polymorph
is
the
state
or
condit
of
be
polymorph
,
or
if
we
use
the
translat
of
the
compon
``
the
abil
to
be
in
mani
shape
or
form
.
polymorph
is
a
term
use
in
mani
scientif
area
.
In
crystallographi
it
defin
the
state
,
if
someth
crystal
into
two
or
more
chemic
ident
but
crystallograph
distinct
form
.
biologist
know
polymorph
as
the
exist
of
an
organ
in
sever
form
or
colour
varieti
.
the
roman
even
had
a
god
,
call
morpheu
,
who
is
abl
to
take
ani
human
form
:
morheu
appear
in
ovid
's
metamorphos
and
is
the
son
of
somnu
,
the
god
of
sleep
.
you
can
admir
morpheu
and
iri
in
the
pictur
on
the
right
side
.
So
,
befor
we
fall
to
sleep
,
we
get
back
to
python
and
to
what
polymorph
mean
in
the
program
languag
context
.
polymorph
in
comput
scienc
is
the
abil
to
present
the
same
interfac
for
differ
underli
form
.
We
can
have
in
some
program
languag
polymorph
function
or
method
,
for
exampl
.
polymorph
function
or
method
can
be
appli
to
argument
of
differ
type
,
and
they
can
behav
differ
depend
on
the
type
of
the
argument
to
which
they
are
appli
.
We
can
also
defin
the
same
function
name
with
a
vari
number
of
paramet
.
let
's
have
a
look
at
the
follow
python
function
:
def
f
(
x
,
y
)
:
print
(
``
valu
:
``
,
x
,
y
)
f
(
42
,
43
)
f
(
42
,
43.7
)
f
(
42.3
,
43
)
f
(
42.0
,
43.9
)
We
can
call
thi
function
with
variou
type
,
as
demonstr
in
the
exampl
.
In
type
program
languag
like
java
or
c++
,
we
would
have
to
overload
f
to
implement
the
variou
type
combin
.
our
exampl
could
be
implement
like
thi
in
c++
:
#
includ
<
iostream
>
use
namespac
std
;
void
f
(
int
x
,
int
y
)
{
cout
<
<
``
valu
:
``
<
<
x
<
<
``
,
``
<
<
x
<
<
endl
;
}
void
f
(
int
x
,
doubl
y
)
{
cout
<
<
``
valu
:
``
<
<
x
<
<
``
,
``
<
<
x
<
<
endl
;
}
void
f
(
doubl
x
,
int
y
)
{
cout
<
<
``
valu
:
``
<
<
x
<
<
``
,
``
<
<
x
<
<
endl
;
}
void
f
(
doubl
x
,
doubl
y
)
{
cout
<
<
``
valu
:
``
<
<
x
<
<
``
,
``
<
<
x
<
<
endl
;
}
int
main
(
)
{
f
(
42
,
43
)
;
f
(
42
,
43.7
)
;
f
(
42.3,43
)
;
f
(
42.0
,
43.9
)
;
}
python
is
implicitli
polymorph
.
We
can
appli
our
previous
defin
function
f
even
to
list
,
string
or
other
type
,
which
can
be
print
:
>
>
>
def
f
(
x
,
y
)
:
...
print
(
``
valu
:
``
,
x
,
y
)
...
>
>
>
f
(
[
3,5,6
]
,
(
3,5
)
)
valu
:
[
3
,
5
,
6
]
(
3
,
5
)
>
>
>
f
(
``
A
string
''
,
(
``
A
tupl
''
,
``
with
string
''
)
)
valu
:
A
string
(
'
A
tupl
'
,
'with
string
'
)
>
>
>
f
(
{
2,3,9
}
,
{
``
a
''
:3.4
,
''
b
''
:7.8
,
``
c
''
:9.04
}
)
valu
:
{
9
,
2
,
3
}
{
'
a
'
:
3.4
,
'
c
'
:
9.04
,
'
b
'
:
7.8
}
>
>
>
footnot
1
python
ha
use
sinc
2.3
the
,
,c3
superclass
linearis
''
-algorithm
to
determin
the
mro
.
--
>
previou
chapter
:
inherit
next
chapter
:
magic
method
and
oper
overload
息
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

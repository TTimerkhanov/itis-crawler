python
advanc
:
mastermind
/
bull
and
cow
python
advanc
cours
topic
advanc
topic
introduct
into
the
sy
modulepython
and
the
shellfork
and
fork
in
pythonintroduct
into
threadspip
,
pipe
and
``
99
bottl
of
beer
''
python
network
scannergraph
theori
and
graph
in
pythongraph
:
pygraphgraphsa
python
class
for
polynomi
functionscurri
in
pythonfinit
state
machin
in
pythontur
machin
in
pythonlevenshtein
distanceexampl
for
recurs
program
:
tower
of
hanoimastermind
/
bull
and
cowscreat
dynam
websit
with
wsgidynam
websit
with
mod_pythondynam
websit
with
pylonspython
,
sql
,
mysql
and
sqlitepython
score
bull
and
cow
bull
and
cow
--
also
known
as
cow
and
bull
or
pig
and
bull
or
bull
and
cleot
--
is
an
old
code-break
paper
and
pencil
game
for
two
player
thi
websit
is
creat
by
:
python
train
cours
in
toronto
,
canada
On
site
train
in
europ
,
canada
and
the
US
.
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
classroom
train
cours
thi
websit
contain
a
free
and
extens
onlin
tutori
by
bernd
klein
,
use
materi
from
hi
classroom
python
train
cours
.
If
you
are
interest
in
an
instructor-l
classroom
train
cours
,
you
may
have
a
look
at
the
python
class
by
bernd
klein
at
bodenseo
.
©
kabliczech
-
fotolia.com
quot
of
the
day
:
''
It
scarc
need
mention
that
,
when
you
have
a
decor
insid
a
decor
,
it
's
an
interior
decor
.
''
(
neal
morison
)
If
you
have
the
choic
work
with
python
2
or
python
3
,
we
recomend
to
switch
to
python
3
!
you
can
read
our
python
tutori
to
see
what
the
differ
are
.
data
protect
declar
data
protect
declar
previou
chapter
:
exampl
for
recurs
program
:
tower
of
hanoi
next
chapter
:
creat
dynam
websit
with
wsgi
mastermind
/
bull
and
cow
introduct
In
thi
chapter
of
our
advanc
python
topic
we
present
an
implement
of
the
game
bull
and
cow
.
thi
game
,
which
is
also
known
as
``
cow
and
bull
''
or
``
pig
and
bull
''
,
is
an
old
code-break
game
play
by
two
player
.
the
game
goe
back
to
the
19th
centuri
and
can
be
play
with
paper
and
pencil
.
bull
and
cow
--
also
known
as
cow
and
bull
or
pig
and
bull
or
bull
and
cleot
--
wa
the
inspir
sourc
of
mastermind
,
a
game
invent
in
1970
by
mordecai
meirowitz
.
the
game
is
play
by
two
player
.
mastermind
and
``
bull
and
cow
''
are
veri
similar
and
the
underli
idea
is
essenti
the
same
,
but
mastermind
is
sold
in
a
box
with
a
decod
board
and
peg
for
the
code
and
the
feedback
peg
.
mastermind
use
colour
as
the
underli
code
inform
,
while
bull
and
cow
use
digit
.
rule
of
the
game
bull
and
cow
We
start
with
the
rule
of
``
bull
and
cow
''
:
It
's
a
pencil
and
paper
game
play
by
two
player
.
the
two
player
write
a
4-digit
number
on
a
sheet
of
paper
.
the
digit
must
be
all
differ
,
but
there
is
a
version
,
where
digit
can
be
use
more
than
onc
.
each
player
ha
to
find
out
the
oppon
's
secret
code
.
To
thi
purpos
,
the
player
-
in
turn
-
tri
to
guess
the
oppon
's
number
.
the
oppon
ha
to
score
the
guess
:
A
``
bull
''
is
a
digit
which
is
locat
at
the
right
posit
.
If
,
for
exampl
,
the
hidden
code
is
``
4
3
2
5
''
and
the
guess
is
``
4
3
1
2
''
,
then
we
have
the
two
bull
``
4
''
and
``
3
''
in
the
guess
``
4
3
1
2
''
.
A
``
cow
''
on
the
other
hand
is
a
correct
number
,
which
is
on
the
wrong
posit
.
the
``
2
''
of
the
previou
exampl
is
a
cow
.
the
first
player
to
reveal
the
other
's
secret
number
is
the
winner
of
the
game
.
the
secret
number
for
bull
and
cow
are
usual
4-digit-numb
,
but
the
game
can
be
play
with
3
to
6
digit
number
.
there
are
lot
of
comput
implement
of
``
bull
and
cow
''
.
the
first
one
wa
a
program
call
moo
,
written
in
pl/i
.
mastermind
mastermind
obey
essenti
the
same
rule
as
``
bull
and
cow
''
,
but
colour
are
use
instead
of
digit
.
mastermind
is
a
commerci
board
game
,
which
is
play
on
a
decod
board
with
a
shield
on
one
side
hide
a
row
of
four
larg
hole
to
put
in
colour
peg
,
i.e
.
the
secret
code
,
which
ha
to
be
found
out
by
the
oppon
.
there
are
8
to
12
row
of
four
hole
for
the
guess
,
which
are
open
to
the
view
.
besid
of
each
row
,
there
is
a
set
of
four
small
hole
for
the
black
and
white
score
peg
.
the
implement
the
follow
program
is
a
python
implement
(
python3
)
,
which
is
capabl
of
break
a
colour
code
of
four
posit
and
six
colour
,
but
these
number
are
scalabl
.
the
colour
code
is
not
allow
to
contain
multipl
occurr
of
colour
.
We
need
the
function
all_colour
from
the
follow
combinator
modul
,
which
can
be
save
as
combinatorics.pi
:
import
random
def
fac
(
n
)
:
if
n
==
0
:
return
1
els
:
return
(
fac
(
n-1
)
*
n
)
def
permut
(
item
)
:
n
=
len
(
item
)
if
n==0
:
yield
[
]
els
:
for
i
in
rang
(
len
(
item
)
)
:
for
cc
in
permut
(
item
[
:
i
]
+item
[
i+1
:
]
)
:
yield
[
item
[
i
]
]
+cc
def
k_permut
(
item
,
n
)
:
if
n==0
:
yield
[
]
els
:
for
i
in
rang
(
len
(
item
)
)
:
for
ss
in
k_permut
(
item
,
n-1
)
:
if
(
not
item
[
i
]
in
ss
)
:
yield
[
item
[
i
]
]
+ss
def
random_permut
(
list
)
:
length
=
len
(
list
)
;
max
=
fac
(
length
)
;
index
=
random.randrang
(
0
,
max
)
i
=
0
for
p
in
permut
(
list
)
:
if
i
==
index
:
return
p
i
+=
1
def
all_colour
(
colour
,
posit
)
:
colour
=
random_permut
(
colour
)
for
s
in
k_permut
(
colour
,
posit
)
:
yield
(
s
)
If
you
want
to
know
more
about
permut
,
you
may
confer
to
our
chapter
about
``
gener
and
iter
''
.
the
function
all_colour
is
essenti
like
k_permut
,
but
it
start
the
sequenc
of
permut
with
a
random
permut
,
becaus
we
want
to
make
sure
that
the
comput
start
each
new
game
with
a
complet
new
guess
.
the
colour
,
which
are
use
for
the
guess
,
are
defin
in
a
list
assign
to
the
variabl
``
colour
''
.
It
's
possibl
to
put
in
differ
element
into
thi
list
,
e.g
.
colour
=
[
``
a
''
,
''
b
''
,
''
c
''
,
''
d
''
,
''
e
''
,
''
f
''
]
or
someth
like
the
follow
assign
,
which
doe
n't
make
a
lot
of
sens
in
term
of
colour
:
colour
=
[
``
pari
blue
''
,
``
london
green
''
,
``
berlin
black
''
,
``
vienna
yellow
''
,
``
frankfurt
red
''
,
``
hamburg
brown
''
]
the
list
``
guess
''
ha
to
be
empti
.
all
the
guess
with
the
score
from
the
human
player
will
be
save
in
thi
list
.
It
might
look
like
thi
in
a
game
:
[
(
[
'pink
'
,
'green
'
,
'blue
'
,
'orang
'
]
,
(
1
,
1
)
)
,
(
[
'pink
'
,
'blue
'
,
'red
'
,
'yellow
'
]
,
(
1
,
2
)
)
,
(
[
'pink
'
,
'orang
'
,
'yellow
'
,
'red
'
]
,
(
0
,
2
)
)
]
We
can
see
that
guess
is
a
list
of
tupl
.
each
tupl
contain
a
list
of
colours1
and
a
2-tupl
with
the
score
from
the
human
player
,
e.g
.
(
1
,
2
)
with
1
the
number
of
``
bull
''
or
``
black
''
in
the
mastermind
lingo
and
the
2
is
the
number
of
``
cow
''
(
or
``
white
''
in
the
mastermind
jargon
)
in
[
'pink
'
,
'blue
'
,
'red
'
,
'yellow
'
]
We
use
the
gener
all_colour
(
)
to
creat
the
first
guess
:
permutation_iter
=
all_colour
(
colour
,
number_of_posit
)
current_colour_choic
=
next
(
permutation_iter
)
the
follow
while
loop
present
the
guess
to
the
human
player
,
evalu
the
answer
and
produc
a
new
guess
.
the
while
loop
end
,
if
either
the
number
of
``
black
''
(
``
cow
''
)
(
new_guess
[
1
]
[
0
]
)
is
equal
to
number_of_posit
or
if
new_guess
[
1
]
[
0
]
==
-1
,
which
mean
that
the
answer
were
inconsist
.
We
have
a
closer
look
at
the
function
new_evalu
.
At
first
,
it
call
the
function
get_evalu
(
)
which
return
the
``
bull
''
and
``
cow
''
or
term
of
our
program
the
valu
for
rightly_posit
and
permut
.
def
get_evalu
(
)
:
``
''
''
ask
the
human
player
for
an
evalu
``
''
''
show_current_guess
(
new_guess
[
0
]
)
rightly_posit
=
int
(
input
(
``
black
:
``
)
)
permut
=
int
(
input
(
``
white
:
``
)
)
return
(
rightly_posit
,
permut
)
the
game
is
over
,
if
the
number
of
rightli
posit
colour
,
as
return
by
the
function
get_evalu
(
)
,
is
equal
to
the
number_of_posit
,
i.e
.
4
:
if
rightly_posit
==
number_of_posit
:
return
(
current_colour_choic
,
(
rightly_posit
,
permut
)
)
In
the
next
if
statement
,
we
check
,
if
the
human
answer
make
sens
.
there
are
combin
of
white
and
black
,
which
do
n't
make
sens
,
for
exampl
three
black
and
one
white
do
n't
make
sens
,
as
you
can
easili
understand
.
the
function
answer_correct
(
)
is
use
to
check
,
if
the
input
make
sens
:
def
answer_ok
(
a
)
:
(
rightly_posit
,
permut
)
=
a
if
(
rightly_posit
+
permut
>
number_of_posit
)
\
or
(
rightly_posit
+
permut
<
len
(
colour
)
-
number_of_posit
)
:
return
fals
if
rightly_posit
==
3
and
permut
==
1
:
return
fals
return
true
the
function
answer_ok
(
)
should
be
self-explanatori
.
If
answer_ok
return
fals
,
new_evalu
will
be
left
with
the
return
valu
-1
for
the
black
,
which
in
turn
will
end
the
while
loop
in
the
main
program
:
if
not
answer_ok
(
(
rightly_posit
,
permut
)
)
:
print
(
``
input
error
:
sorri
,
the
input
make
no
sens
''
)
return
(
current_colour_choic
,
(
-1
,
permut
)
)
If
the
check
wa
true
,
the
guess
will
be
append
to
the
previou
guess
and
will
be
shown
to
the
user
:
guesses.append
(
(
current_colour_choic
,
(
rightly_posit
,
permut
)
)
)
view_guess
(
)
after
thi
step
,
a
new
guess
will
be
creat
.
If
a
new
guess
could
be
creat
,
it
will
be
shown
,
togeth
with
the
black
and
white
valu
from
the
previou
guess
,
which
are
check
in
the
while
loop
.
If
a
new
guess
can
not
be
creat
,
a
-1
will
be
return
for
the
black
:
current_colour_choic
=
create_new_guess
(
)
if
not
current_colour_choic
:
return
(
current_colour_choic
,
(
-1
,
permut
)
)
return
(
current_colour_choic
,
(
rightly_posit
,
permut
)
)
the
follow
code
is
the
complet
program
,
which
you
can
save
and
start
,
but
do
n't
forget
to
use
python3
:
import
random
from
combinator
import
all_colour
def
inconsist
(
p
,
guess
)
:
``
''
''
the
function
check
,
if
a
permut
p
,
i.e
.
a
list
of
colour
like
p
=
[
'pink
'
,
'yellow
'
,
'green
'
,
'red
'
]
is
consist
with
the
previou
colour
.
each
previou
colour
permuat
guess
[
0
]
compar
(
check
(
)
)
with
p
ha
to
return
the
same
amount
of
black
(
rightli
posit
colour
)
and
white
(
right
colour
at
wrong
posit
)
as
the
correspond
evalu
(
guess
[
1
]
in
the
list
guess
)
``
''
''
for
guess
in
guess
:
re
=
check
(
guess
[
0
]
,
p
)
(
rightly_posit
,
permut
)
=
guess
[
1
]
if
re
!
=
[
rightly_posit
,
permut
]
:
return
true
#
inconsist
return
fals
#
i.e
.
consist
def
answer_ok
(
a
)
:
``
''
''
check
of
an
evalu
given
by
the
human
player
make
sens
.
3
black
and
1
white
make
no
sens
for
example.
``
''
''
(
rightly_posit
,
permut
)
=
a
if
(
rightly_posit
+
permut
>
number_of_posit
)
\
or
(
rightly_posit
+
permut
<
len
(
colour
)
-
number_of_posit
)
:
return
fals
if
rightly_posit
==
3
and
permut
==
1
:
return
fals
return
true
def
get_evalu
(
)
:
``
''
''
ask
the
human
player
for
an
evalu
``
''
''
show_current_guess
(
new_guess
[
0
]
)
rightly_posit
=
int
(
input
(
``
black
:
``
)
)
permut
=
int
(
input
(
``
white
:
``
)
)
return
(
rightly_posit
,
permut
)
def
new_evalu
(
current_colour_choic
)
:
``
''
''
thi
funtion
get
an
evalu
of
the
current
guess
,
check
the
consist
of
thi
evalu
,
add
the
guess
togeth
with
the
evalu
to
the
list
of
guess
,
show
the
previou
guess
and
creat
a
new
guess
``
''
''
rightly_posit
,
permut
=
get_evalu
(
)
if
rightly_posit
==
number_of_posit
:
return
(
current_colour_choic
,
(
rightly_posit
,
permut
)
)
if
not
answer_ok
(
(
rightly_posit
,
permut
)
)
:
print
(
``
input
error
:
sorri
,
the
input
make
no
sens
''
)
return
(
current_colour_choic
,
(
-1
,
permut
)
)
guesses.append
(
(
current_colour_choic
,
(
rightly_posit
,
permut
)
)
)
view_guess
(
)
current_colour_choic
=
create_new_guess
(
)
if
not
current_colour_choic
:
return
(
current_colour_choic
,
(
-1
,
permut
)
)
return
(
current_colour_choic
,
(
rightly_posit
,
permut
)
)
def
check
(
p1
,
p2
)
:
``
''
''
check
(
)
calcul
the
number
of
bull
(
black
)
and
cow
(
white
)
of
two
permut
``
''
''
black
=
0
white
=
0
for
i
in
rang
(
len
(
p1
)
)
:
if
p1
[
i
]
==
p2
[
i
]
:
black
+=
1
els
:
if
p1
[
i
]
in
p2
:
white
+=
1
return
[
black
,
white
]
def
create_new_guess
(
)
:
``
''
''
a
new
guess
is
creat
,
which
is
consist
to
the
previou
guess
``
''
''
next_choic
=
next
(
permutation_iter
)
while
inconsist
(
next_choic
,
guess
)
:
tri
:
next_choic
=
next
(
permutation_iter
)
except
stopiter
:
print
(
``
error
:
your
answer
were
inconsist
!
''
)
return
(
)
return
next_choic
def
show_current_guess
(
new_guess
)
:
``
''
''
the
current
guess
is
print
to
stdout
``
''
''
print
(
``
new
guess
:
``
,
end=
''
``
)
for
c
in
new_guess
:
print
(
c
,
end=
''
``
)
print
(
)
def
view_guess
(
)
:
``
''
''
the
list
of
all
guess
with
the
correspond
evalu
is
print
``
''
''
print
(
``
previou
guess
:
''
)
for
guess
in
guess
:
guessed_colour
=
guess
[
0
]
for
c
in
guessed_colour
:
print
(
c
,
end=
''
``
)
for
i
in
guess
[
1
]
:
print
(
``
%
i
``
%
i
,
end=
''
``
)
print
(
)
if
__name__
==
``
__main__
''
:
colour
=
[
``
red
''
,
''
green
''
,
''
blue
''
,
''
yellow
''
,
''
orang
''
,
''
pink
''
]
guess
=
[
]
number_of_posit
=
4
permutation_iter
=
all_colour
(
colour
,
number_of_posit
)
current_colour_choic
=
next
(
permutation_iter
)
new_guess
=
(
current_colour_choic
,
(
0,0
)
)
while
(
new_guess
[
1
]
[
0
]
==
-1
)
or
(
new_guess
[
1
]
[
0
]
!
=
number_of_posit
)
:
new_guess
=
new_evalu
(
new_guess
[
0
]
)
gui
for
mastermind
you
can
find
an
implement
of
the
previou
program
with
a
graphic
user
interfac
use
tkinter
in
our
tkinter
tutori
.
footnot
:
1
the
colour
guess
do
n't
have
to
be
list
,
we
could
have
use
tupl
to
repres
the
colour
guess
as
well
.
previou
chapter
:
exampl
for
recurs
program
:
tower
of
hanoi
next
chapter
:
creat
dynam
websit
with
wsgi
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

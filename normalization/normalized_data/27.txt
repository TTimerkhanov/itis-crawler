python
tutori
:
class
vs
.
instanc
attribut
python
cours
python
3
tutori
the
origin
of
pythonstart
with
python
:
the
interact
shellexecut
a
scriptindentationdata
type
and
variablesoperatorssequenti
data
type
:
list
and
stringslist
manipulationsshallow
and
deep
copydictionariesset
and
frozen
setsan
extens
exampl
use
setsinput
via
the
keyboardcondit
statementsloop
,
while
loopfor
loopsdiffer
between
inter
und
iterablesoutput
with
printformat
output
with
string
modulo
and
the
format
methodfunctionsrecurs
and
recurs
functionsparamet
pass
in
functionsnamespacesglob
and
local
variablesdecoratorsmemo
with
decoratorsread
and
write
filesmodular
program
and
modulespackag
in
pythonregular
expressionsregular
express
,
advancedlambda
oper
,
filter
,
reduc
and
maplist
comprehensioniter
and
generatorsexcept
handlingtest
,
doctest
,
unittestsobject
orient
programmingclass
and
instanc
attributesproperti
vs.
getter
and
settersinheritancemultipl
inheritancemag
method
and
oper
overloadingoop
,
inherit
exampleslotsclass
and
class
creationroad
to
metaclassesmetaclassesmetaclass
use
case
:
count
function
callsabstract
class
object-ori
program
``
certainli
not
everi
good
program
is
object-ori
,
and
not
everi
object-ori
program
is
good
.
''
(
bjarn
stroustrup
,
danish
comput
scientist
,
best
known
for
the
creation
and
the
develop
of
the
wide
use
c++
program
languag
.
)
``
object-ori
program
is
an
except
bad
idea
which
could
onli
have
origin
in
california
.
''
(
edsger
dijkstra
,
(
dutch
comput
scientist
,
1930-2002
)
dijkstra
also
said
:
``
...
what
societi
over足whel足mingli
ask
for
is
snake
oil
.
Of
cours
,
the
snake
oil
ha
the
most
impress
name
-
otherwis
you
would
be
sell
noth
-
like
``
structur
analysi
and
design
''
,
``
softwar
engin
''
,
``
matur
model
''
,
``
manag
inform
system
''
,
``
integr
project
support
environ
''
``
object-orient
''
and
``
busi
process
re-engin
''
thi
websit
is
support
by
:
linux
and
python
cours
and
seminar
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
端bersetzung
:
klassen-
und
instanzattribut
classroom
train
cours
the
goal
of
thi
websit
is
to
provid
educ
materi
,
allow
you
to
learn
python
on
your
own
.
nevertheless
,
it
is
faster
and
more
effici
to
attend
a
``
real
''
python
cours
in
a
classroom
,
with
an
experienc
trainer
.
So
whi
not
attend
one
of
the
live
python
cours
in
strasbourg
,
pari
,
luxembourg
,
amsterdam
,
z端rich
/
zurich
,
vienna
/
wien
,
london
,
berlin
,
munich
,
hamburg
,
frankfurt
or
lake
constanc
by
bernd
klein
,
the
author
of
thi
tutori
?
onsit
train
cours
let
us
come
to
your
compani
,
organ
or
institut
and
train
your
employe
,
as
we
've
done
it
mani
time
in
amsterdam
(
the
netherland
)
,
berlin
(
germani
)
,
bern
(
switzerland
)
,
basel
(
switzerland
)
,
zurich
(
switzerland
)
,
locarno
(
switzerland
)
,
den
haag
(
the
hagu
)
,
hamburg
(
germani
)
,
frankfurt
(
germani
)
,
toronto
(
canada
)
,
edmonton
(
canada
)
,
munich
(
germani
)
and
mani
other
citi
.
We
do
train
cours
in
england
,
switzerland
,
liechtenstein
,
austria
,
germani
,
franc
,
belgium
,
the
netherland
,
luxembourg
,
poland
,
UK
,
itali
and
other
locat
in
europ
and
in
canada
.
thi
way
you
will
get
a
perfect
train
up
to
your
need
and
it
will
be
extrem
cost
effici
as
well
.
contact
us
so
we
can
defin
and
find
the
best
cours
curriculum
to
meet
your
need
,
and
schedul
cours
session
to
be
held
at
your
locat
.
skill
python
programm
you
are
look
for
experienc
python
develop
or
programm
?
We
can
help
you
,
pleas
contact
us
.
quot
of
the
day
:
man
is
the
best
comput
we
can
put
aboard
a
spacecraft
...
and
the
onli
one
that
can
be
mass
produc
with
unskil
labor
.
(
wernher
von
braun
)
data
protect
declar
data
protect
declar
previou
chapter
:
object
orient
program
next
chapter
:
properti
vs.
getter
and
setter
class
and
instanc
attribut
class
attribut
instanc
attribut
are
own
by
the
specif
instanc
of
a
class
.
thi
mean
for
two
differ
instanc
the
instanc
attribut
are
usual
differ
.
you
should
by
now
be
familiar
with
thi
concept
which
we
introduc
the
previou
chapter
.
We
can
also
defin
attribut
at
the
class
level
.
class
attribut
are
attribut
which
are
own
by
the
class
itself
.
they
will
be
share
by
all
the
instanc
of
the
class
.
therefor
they
have
the
same
valu
for
everi
instanc
.
We
defin
class
attribut
outsid
of
all
the
method
,
usual
they
are
place
at
the
top
,
right
below
the
class
header
.
We
can
see
in
the
follow
interact
python
session
that
the
class
attribut
``
a
''
is
the
same
for
all
instanc
,
in
our
exampl
``
x
''
and
``
y
''
.
besid
thi
,
we
see
that
we
can
access
a
class
attribut
via
an
instanc
or
via
the
class
name
:
>
>
>
class
A
:
...
a
=
``
I
am
a
class
attribut
!
''
...
>
>
>
x
=
A
(
)
>
>
>
y
=
A
(
)
>
>
>
x.a
'
I
am
a
class
attribut
!
'
>
>
>
y.a
'
I
am
a
class
attribut
!
'
>
>
>
a.a
'
I
am
a
class
attribut
!
'
>
>
>
but
be
care
,
if
you
want
to
chang
a
class
attribut
,
you
have
to
do
it
with
the
notat
classname.attributenam
.
otherwis
,
you
will
creat
a
new
instanc
variabl
.
We
demonstr
thi
in
the
follow
exampl
:
>
>
>
class
A
:
...
a
=
``
I
am
a
class
attribut
!
''
...
>
>
>
x
=
A
(
)
>
>
>
y
=
A
(
)
>
>
>
x.a
=
``
thi
creat
a
new
instanc
attribut
for
x
!
''
>
>
>
y.a
'
I
am
a
class
attribut
!
'
>
>
>
a.a
'
I
am
a
class
attribut
!
'
>
>
>
a.a
=
``
thi
is
chang
the
class
attribut
'
a
'
!
''
>
>
>
a.a
``
thi
is
chang
the
class
attribut
'
a
'
!
''
>
>
>
y.a
``
thi
is
chang
the
class
attribut
'
a
'
!
''
>
>
>
#
but
x.a
is
still
the
previous
creat
instanc
variabl
:
...
>
>
>
x.a
'thi
creat
a
new
instanc
attribut
for
x
!
'
>
>
>
python
's
class
attribut
and
object
attribut
are
store
in
separ
dictionari
,
as
we
can
see
here
:
>
>
>
x.__dict__
{
'
a
'
:
'thi
creat
a
new
instanc
attribut
for
x
!
'
}
>
>
>
y.__dict__
{
}
>
>
>
a.__dict__
dict_proxi
(
{
'
a
'
:
``
thi
is
chang
the
class
attribut
'
a
'
!
``
,
'__dict__
'
:
<
attribut
'__dict__
'
of
'
A
'
object
>
,
'__module__
'
:
'__main__
'
,
'__weakref__
'
:
<
attribut
'__weakref__
'
of
'
A
'
object
>
,
'__doc__
'
:
none
}
)
>
>
>
x.__class__.__dict__
dict_proxi
(
{
'
a
'
:
``
thi
is
chang
the
class
attribut
'
a
'
!
``
,
'__dict__
'
:
<
attribut
'__dict__
'
of
'
A
'
object
>
,
'__module__
'
:
'__main__
'
,
'__weakref__
'
:
<
attribut
'__weakref__
'
of
'
A
'
object
>
,
'__doc__
'
:
none
}
)
>
>
>
exampl
with
class
attribut
isaac
asimov
devis
and
introduc
the
so-cal
``
three
law
of
robot
''
in
1942
.
the
appear
in
hi
stori
``
runaround
''
.
hi
three
law
have
been
pick
up
by
mani
scienc
fiction
writer
.
As
we
have
start
manufactur
robot
in
python
,
it
's
high
time
to
make
sure
that
they
obey
asimov
three
law
.
As
they
are
the
same
for
everi
instanc
,
i.e
.
robot
,
we
will
creat
a
class
attribut
three_law
.
thi
attribut
is
a
tupl
with
the
three
law
.
class
robot
:
three_law
=
(
``
''
''
A
robot
may
not
injur
a
human
be
or
,
through
inact
,
allow
a
human
be
to
come
to
harm
.
``
``
''
,
``
''
''
A
robot
must
obey
the
order
given
to
it
by
human
be
,
except
where
such
order
would
conflict
with
the
first
law.
,
''
''
''
,
``
''
''
A
robot
must
protect
it
own
exist
as
long
as
such
protect
doe
not
conflict
with
the
first
or
second
law
.
''
''
''
)
def
__init__
(
self
,
name
,
build_year
)
:
self.nam
=
name
self.build_year
=
build_year
#
other
method
as
usual
As
we
mention
befor
,
we
can
access
a
class
attribut
via
instanc
or
via
the
class
name
.
you
can
see
in
the
follow
that
we
need
no
instanc
:
>
>
>
from
robot_asimov
import
robot
>
>
>
for
number
,
text
in
enumer
(
robot.three_law
)
:
...
print
(
str
(
number+1
)
+
``
:
\n
''
+
text
)
...
1
:
A
robot
may
not
injur
a
human
be
or
,
through
inact
,
allow
a
human
be
to
come
to
harm
.
2
:
A
robot
must
obey
the
order
given
to
it
by
human
be
,
except
where
such
order
would
conflict
with
the
first
law.
,
3
:
A
robot
must
protect
it
own
exist
as
long
as
such
protect
doe
not
conflict
with
the
first
or
second
law
.
>
>
>
We
demonstr
in
the
follow
exampl
,
how
you
can
count
instanc
with
class
attribut
.
all
we
have
to
do
is
to
creat
a
class
attribut
,
which
we
call
``
counter
''
in
our
exampl
to
increment
thi
attribut
by
1
everi
time
a
new
instanc
will
be
creat
to
decrement
the
attribut
by
1
everi
time
an
instanc
will
be
destroy
class
C
:
counter
=
0
def
__init__
(
self
)
:
type
(
self
)
.counter
+=
1
def
__del__
(
self
)
:
type
(
self
)
.counter
-=
1
if
__name__
==
``
__main__
''
:
x
=
C
(
)
print
(
``
number
of
instanc
:
:
``
+
str
(
c.counter
)
)
y
=
C
(
)
print
(
``
number
of
instanc
:
:
``
+
str
(
c.counter
)
)
del
x
print
(
``
number
of
instanc
:
:
``
+
str
(
c.counter
)
)
del
y
print
(
``
number
of
instanc
:
:
``
+
str
(
c.counter
)
)
principi
,
we
could
have
written
c.counter
instead
of
type
(
self
)
.counter
,
becaus
type
(
self
)
will
be
evalu
to
``
C
''
anyway
.
but
we
will
see
later
,
that
type
(
self
)
make
sens
,
if
we
use
such
a
class
as
a
superclass
.
If
we
start
the
previou
program
,
we
will
get
the
follow
result
:
$
python3
counting_instances.pi
number
of
instanc
:
:
1
number
of
instanc
:
:
2
number
of
instanc
:
:
1
number
of
instanc
:
:
0
static
method
We
use
class
attribut
as
public
attribut
in
the
previou
section
.
Of
cours
,
we
can
make
public
attribut
privat
as
well
.
We
can
do
thi
by
ad
the
doubl
underscor
again
.
If
we
do
so
,
we
need
a
possibl
to
access
and
chang
these
privat
class
attribut
.
We
could
use
instanc
method
for
thi
purpos
:
class
robot
:
__counter
=
0
def
__init__
(
self
)
:
type
(
self
)
.__counter
+=
1
def
robotinst
(
self
)
:
return
robot.__count
if
__name__
==
``
__main__
''
:
x
=
robot
(
)
print
(
x.robotinst
(
)
)
y
=
robot
(
)
print
(
x.robotinst
(
)
)
thi
is
not
a
good
idea
for
two
reason
:
first
of
all
,
becaus
the
number
of
robot
ha
noth
to
do
with
a
singl
robot
instanc
and
secondli
becaus
we
ca
n't
inquir
the
number
of
robot
befor
we
have
n't
creat
an
instanc
.
If
we
tri
to
invok
the
method
with
the
class
name
robot.robotinst
(
)
,
we
get
an
error
messag
,
becaus
it
need
an
instanc
as
an
argument
:
>
>
>
robot.robotinst
(
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
typeerror
:
robotinst
(
)
take
exactli
1
argument
(
0
given
)
the
next
idea
,
which
still
doe
n't
solv
our
problem
,
consist
in
omit
the
paramet
``
self
''
:
class
robot
:
__counter
=
0
def
__init__
(
self
)
:
type
(
self
)
.__counter
+=
1
def
robotinst
(
)
:
return
robot.__count
now
it
's
possibl
to
access
the
method
via
the
class
name
,
but
we
ca
n't
call
it
via
an
instanc
:
>
>
>
from
static_methods2
import
robot
>
>
>
robot.robotinst
(
)
0
>
>
>
x
=
robot
(
)
>
>
>
x.robotinst
(
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
typeerror
:
robotinst
(
)
take
no
argument
(
1
given
)
>
>
>
the
call
``
x.robotinst
(
)
''
is
treat
as
an
instanc
method
call
and
an
instanc
method
need
a
refer
to
the
instanc
as
the
first
paramet
.
So
,
what
do
we
want
?
We
want
a
method
,
which
we
can
call
via
the
class
name
or
via
the
instanc
name
without
the
necess
of
pass
a
refer
to
an
instanc
to
it
.
the
solut
consist
in
static
method
,
which
do
n't
need
a
refer
to
an
instanc
.
It
's
easi
to
turn
a
method
into
a
static
method
.
all
we
have
to
do
is
to
add
a
line
with
``
@
staticmethod
''
directli
in
front
of
the
method
header
.
It
's
the
decor
syntax
.
you
can
see
in
the
follow
exampl
that
we
can
now
use
our
method
robotinst
the
way
we
want
:
class
robot
:
__counter
=
0
def
__init__
(
self
)
:
type
(
self
)
.__counter
+=
1
@
staticmethod
def
robotinst
(
)
:
return
robot.__count
if
__name__
==
``
__main__
''
:
print
(
robot.robotinst
(
)
)
x
=
robot
(
)
print
(
x.robotinst
(
)
)
y
=
robot
(
)
print
(
x.robotinst
(
)
)
print
(
robot.robotinst
(
)
)
We
will
get
the
follow
output
:
0
1
2
2
class
method
static
method
should
n't
be
confus
with
class
method
.
like
static
method
class
method
are
not
bound
to
instanc
,
but
unlik
static
method
class
method
are
bound
to
a
class
.
the
first
paramet
of
a
class
method
is
a
refer
to
a
class
,
i.e
.
a
class
object
.
they
can
be
call
via
an
instanc
or
the
class
name
.
class
robot
:
__counter
=
0
def
__init__
(
self
)
:
type
(
self
)
.__counter
+=
1
@
classmethod
def
robotinst
(
cl
)
:
return
cl
,
robot.__count
if
__name__
==
``
__main__
''
:
print
(
robot.robotinst
(
)
)
x
=
robot
(
)
print
(
x.robotinst
(
)
)
y
=
robot
(
)
print
(
x.robotinst
(
)
)
print
(
robot.robotinst
(
)
)
the
output
look
like
thi
:
$
python3
static_methods4.pi
<
class
'__main__.robot
'
>
,
0
)
<
class
'__main__.robot
'
>
,
1
)
<
class
'__main__.robot
'
>
,
2
)
<
class
'__main__.robot
'
>
,
2
)
the
use
case
of
class
method
:
the
are
use
in
the
definit
of
the
so-cal
factori
method
,
which
we
will
not
cover
here
.
they
are
often
use
,
where
we
have
static
method
,
which
have
to
call
other
static
method
.
To
do
thi
,
we
would
have
to
hard
code
the
class
name
,
if
we
had
to
use
static
method
.
thi
is
a
problem
,
if
we
are
in
a
use
case
,
where
we
have
inherit
class
.
the
follow
program
contain
a
fraction
class
,
which
is
still
not
complet
.
If
you
work
with
fraction
,
you
need
to
be
capabl
of
reduc
fraction
,
e.g
.
the
fraction
8/24
can
be
reduc
to
1/3
.
We
can
reduc
a
fraction
to
lowest
term
by
divid
both
the
numer
and
denomin
by
the
greatest
common
divisor
(
gcd
)
.
We
have
defin
a
static
gcd
function
to
calcul
the
greatest
common
divisor
of
two
number
.
the
greatest
common
divisor
(
gcd
)
of
two
or
more
integ
(
at
least
one
of
which
is
not
zero
)
,
is
the
largest
posit
integ
that
divid
the
number
without
a
remaind
.
for
exampl
,
the
'gcd
of
8
and
24
is
8
.
the
static
method
``
gcd
''
is
call
by
our
class
method
``
reduc
''
with
``
cls.gcd
(
n1
,
n2
)
''
.
``
cl
''
is
a
refer
to
``
fraction
''
.
class
fraction
(
object
)
:
def
__init__
(
self
,
n
,
d
)
:
self.numer
,
self.denomin
=
fraction.reduc
(
n
,
d
)
@
staticmethod
def
gcd
(
a
,
b
)
:
while
b
!
=
0
:
a
,
b
=
b
,
a
%
b
return
a
@
classmethod
def
reduc
(
cl
,
n1
,
n2
)
:
g
=
cls.gcd
(
n1
,
n2
)
return
(
n1
//
g
,
n2
//
g
)
def
__str__
(
self
)
:
return
str
(
self.numer
)
+'/'+str
(
self.denomin
)
use
thi
class
:
>
>
>
from
fraction1
import
fraction
>
>
>
x
=
fraction
(
8,24
)
>
>
>
print
(
x
)
1/3
>
>
>
We
will
demonstr
in
our
last
exampl
the
use
of
class
method
in
inherit
.
We
defin
a
class
``
pet
''
with
a
method
``
about
''
.
thi
class
will
be
inherit
in
a
subclass
``
dog
''
and
``
cat
''
.
the
method
``
about
''
will
be
inherit
as
well
.
We
will
defin
the
method
``
about
''
as
a
``
staticmethod
''
in
our
first
implement
to
show
the
disadvantag
of
thi
approach
:
class
pet
:
name
=
``
pet
anim
''
@
staticmethod
def
about
(
)
:
print
(
``
thi
class
is
about
{
}
!
``
.format
(
pets.nam
)
)
class
dog
(
pet
)
:
name
=
``
'man
's
best
friend
'
(
frederick
II
)
''
class
cat
(
pet
)
:
name
=
``
cat
''
p
=
pet
(
)
p.about
(
)
d
=
dog
(
)
d.about
(
)
c
=
cat
(
)
c.about
(
)
We
get
the
follow
output
:
thi
class
is
about
pet
anim
!
thi
class
is
about
pet
anim
!
thi
class
is
about
pet
anim
!
especi
,
in
the
case
of
c.about
(
)
and
d.about
(
)
,
we
would
have
prefer
a
more
specif
phrase
!
the
``
problem
''
is
that
the
method
``
about
''
doe
n't
know
that
it
ha
been
call
by
an
instanc
of
the
dog
or
cat
class
.
We
decor
it
now
with
a
classmethod
decor
instead
of
a
staticmethod
decor
:
class
pet
:
name
=
``
pet
anim
''
@
classmethod
def
about
(
cl
)
:
print
(
``
thi
class
is
about
{
}
!
``
.format
(
cls.name
)
)
class
dog
(
pet
)
:
name
=
``
'man
's
best
friend
'
(
frederick
II
)
''
class
cat
(
pet
)
:
name
=
``
cat
''
p
=
pet
(
)
p.about
(
)
d
=
dog
(
)
d.about
(
)
c
=
cat
(
)
c.about
(
)
the
output
is
now
like
we
want
it
to
be
:
thi
class
is
about
pet
anim
!
thi
class
is
about
'man
's
best
friend
'
(
frederick
II
)
!
thi
class
is
about
cat
!
previou
chapter
:
object
orient
program
next
chapter
:
properti
vs.
getter
and
setter
息
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

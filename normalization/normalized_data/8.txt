python
advanc
:
tower
of
hanoi
python
advanc
cours
topic
advanc
topic
introduct
into
the
sy
modulepython
and
the
shellfork
and
fork
in
pythonintroduct
into
threadspip
,
pipe
and
``
99
bottl
of
beer
''
python
network
scannergraph
theori
and
graph
in
pythongraph
:
pygraphgraphsa
python
class
for
polynomi
functionscurri
in
pythonfinit
state
machin
in
pythontur
machin
in
pythonlevenshtein
distanceexampl
for
recurs
program
:
tower
of
hanoimastermind
/
bull
and
cowscreat
dynam
websit
with
wsgidynam
websit
with
mod_pythondynam
websit
with
pylonspython
,
sql
,
mysql
and
sqlitepython
score
recurs
``
the
power
of
recurs
evid
lie
in
the
possibl
of
defin
an
infinit
set
of
object
by
a
finit
statement
.
In
the
same
manner
,
an
infinit
number
of
comput
can
be
describ
by
a
finit
recurs
program
,
even
if
thi
program
contain
no
explicit
repetit
.
''
niklau
wirth
in
``
algorithm
+
data
structur
''
,
1976
``
bewar
of
bug
in
the
abov
code
;
I
have
onli
prove
it
correct
,
not
tri
it.
``
donald
knuth
in
a
memo
subtitl
``
An
instruct
use
of
recurs
''
thi
websit
is
creat
by
:
python
train
cours
in
toronto
,
canada
On
site
train
in
europ
,
canada
and
the
US
.
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
türme
von
hanoi
in
pythonpython
train
cours
If
you
want
to
learn
python
fast
and
effici
,
you
should
consid
a
python
train
cours
at
bodenseo
.
there
are
also
special
seminar
for
advanc
student
like
the
python
&
xml
train
cours
.
If
you
want
to
acquir
special
knowledg
in
text
process
and
text
classif
,
then
``
python
text
process
cours
''
will
be
the
right
one
for
you
.
all
the
python
seminar
are
avail
in
german
as
well
:
python-kurs
''
you
can
also
book
bernd
klein
for
on-sit
train
cours
python
and
recurs
In
program
languag
like
lisp
or
prolog
,
recurs
is
essenti
.
It
is
hardli
possibl
to
write
a
program
without
use
recurs
.
python
fulli
support
the
implement
of
recurs
function
,
but
on
the
other
hand
,
there
are
power
and
easi
to
be
use
loop
,
which
is
one
of
the
reason
,
whi
recurs
are
not
as
often
use
in
python
as
they
are
in
lisp
or
prolog
.
data
protect
declar
data
protect
declar
previou
chapter
:
levenshtein
distanc
next
chapter
:
mastermind
/
bull
and
cow
tower
of
hanoi
introduct
whi
do
we
present
a
python
implement
of
the
``
tower
of
hanoi
''
?
the
hello-world
of
recurs
is
the
factori
.
thi
mean
,
you
will
hardli
find
ani
book
or
tutori
about
program
languag
which
doe
n't
deal
with
the
first
and
introductori
exampl
about
recurs
function
.
anoth
one
is
the
calcul
of
the
n-th
fibonacci
number
.
both
are
well
suit
for
a
tutori
becaus
of
their
simplic
but
they
can
be
easili
written
in
an
iter
way
as
well
.
If
you
have
problem
in
understand
recurs
,
we
recommend
that
you
go
through
the
chapter
``
recurs
function
''
of
our
tutori
.
that
's
differ
with
the
``
tower
of
hanoi
''
.
A
recurs
solut
almost
forc
itself
on
the
programm
,
while
the
iter
solut
of
the
game
is
hard
to
find
and
to
grasp
.
So
,
with
the
tower
of
hanoi
we
present
a
recurs
python
program
,
which
is
hard
to
program
in
an
iter
way
.
origin
there
is
an
old
legend
about
a
templ
or
monasteri
,
which
contain
three
pole
.
one
of
them
fill
with
64
gold
disk
.
the
disk
are
of
differ
size
,
and
they
are
put
on
top
of
each
other
,
accord
to
their
size
,
i.e
.
each
disk
on
the
pole
a
littl
smaller
than
the
one
beneath
it
.
the
priest
,
if
the
legend
is
about
a
templ
,
or
the
monk
,
if
it
is
about
a
monasteri
,
have
to
move
thi
stack
from
one
of
the
three
pole
to
anoth
one
.
but
one
rule
ha
to
be
appli
:
a
larg
disk
can
never
be
place
on
top
of
a
smaller
one
.
when
they
would
have
finish
their
work
,
the
legend
tell
,
the
templ
would
crumbl
into
dust
,
and
the
world
would
end
.
but
do
n't
be
afraid
,
it
's
not
veri
like
that
they
will
finish
their
work
soon
,
becaus
264
-
1
move
are
necessari
,
i.e
.
18,446,744,073,709,551,615
to
move
the
tower
accord
to
the
rule
.
but
there
is
-
most
probabl
-
no
ancient
legend
.
the
legend
and
the
game
``
tower
of
hanoi
''
had
been
conceiv
by
the
french
mathematician
edouard
luca
in
1883
.
rule
of
the
game
the
rule
of
the
game
are
veri
simpl
,
but
the
solut
is
not
so
obviou
.
the
game
``
tower
of
hanoi
''
use
three
rod
.
A
number
of
disk
is
stack
in
decreas
order
from
the
bottom
to
the
top
of
one
rod
,
i.e
.
the
largest
disk
at
the
bottom
and
the
smallest
one
on
top
.
the
disk
build
a
conic
tower
.
the
aim
of
the
game
is
to
move
the
tower
of
disk
from
one
rod
to
anoth
rod
.
the
follow
rule
have
to
be
obey
:
onli
one
disk
may
be
move
at
a
time
.
onli
the
most
upper
disk
from
one
of
the
rod
can
be
move
in
a
move
It
can
be
put
on
anoth
rod
,
if
thi
rod
is
empti
or
if
the
most
upper
disk
of
thi
rod
is
larger
than
the
one
which
is
move
.
number
of
move
the
number
of
move
necessari
to
move
a
tower
with
n
disk
can
be
calcul
as
:
2n
-
1
play
around
to
find
a
solut
from
the
formula
abov
,
we
know
that
we
need
7
move
to
move
a
tower
of
size
3
from
the
most
left
rod
(
let
's
call
it
sourc
to
the
most
right
tower
(
target
)
.
the
pole
in
the
middl
(
we
will
call
it
aux
)
is
need
as
an
auxiliari
stack
to
deposit
disk
temporarili
.
befor
we
examin
the
case
with
3
disk
,
as
it
is
depict
in
the
imag
on
the
right
side
,
we
will
have
a
look
at
tower
of
size
1
(
i.e
.
just
one
disk
)
and
size
2
.
the
solut
for
a
tower
with
just
one
disk
is
straightforward
:
We
will
move
the
one
disk
on
the
sourc
tower
to
the
target
tower
and
we
are
finish
.
let
's
look
now
at
a
tower
with
size
2
,
i.e
.
two
disk
.
there
are
two
possibl
to
move
the
first
disk
,
the
disk
on
top
of
the
stack
of
sourc
:
We
can
move
thi
disk
either
to
target
or
to
aux
.
So
let
's
start
by
move
the
smallest
disk
from
sourc
to
target
.
now
there
are
two
choic
:
We
can
move
thi
disk
again
,
either
back
to
the
sourc
peg
,
which
obvious
doe
n't
make
sens
,
or
we
could
move
it
to
aux
,
which
doe
n't
make
sens
either
,
becaus
we
could
have
move
there
as
our
first
step
.
So
the
onli
move
which
make
sens
is
move
the
other
disk
,
i.e
.
the
largest
disk
,
to
peg
aux
.
now
,
we
have
to
move
the
smallest
disk
again
,
becaus
we
do
n't
want
to
move
the
largest
disk
back
to
sourc
again
.
We
can
move
the
smallest
disk
to
aux
.
now
we
can
see
that
we
have
move
the
tower
of
size
2
to
the
peg
aux
,
but
the
target
had
been
peg
target
.
We
have
alreadi
use
the
maxim
number
of
move
,
i.e
.
22
-
1
=
3
move
the
smallest
disk
from
peg
sourc
to
target
as
our
first
step
ha
not
shown
to
be
success
.
So
,
we
will
move
thi
disk
to
peg
aux
in
our
first
step
.
after
thi
we
move
the
second
disk
to
target
.
after
thi
we
move
the
smallest
disk
from
aux
to
target
and
we
have
finish
our
task
!
We
have
seen
in
the
case
n=1
and
n=2
that
it
depend
on
the
first
move
,
if
we
will
be
abl
to
success
and
with
the
minim
number
of
move
solv
the
riddl
.
We
know
from
our
formula
that
the
minim
number
of
move
necessari
to
move
a
tower
of
size
3
from
the
sourc
peg
to
the
target
peg
is
7
(
23
-
1
)
you
can
see
in
the
solut
,
which
we
present
in
our
imag
that
the
first
disk
ha
to
be
move
from
the
peg
sourc
to
the
peg
target
.
If
your
first
step
consist
of
move
the
smallest
disk
to
aux
,
you
will
not
be
capabl
of
finish
the
task
with
less
than
9
move
.
let
's
number
the
disk
as
D1
(
smallest
)
,
D2
and
D3
(
largest
)
and
name
the
peg
as
S
(
sourc
peg
)
,
A
(
aux
)
,
T
(
target
)
.
We
can
see
that
we
move
in
three
move
the
tower
of
size
2
(
the
disk
D1
and
D2
)
to
A
.
now
we
can
move
D3
to
T
,
where
it
is
final
posit
.
the
last
three
move
move
the
tower
consist
of
d2d1
from
peg
A
to
T
to
place
them
on
top
of
D3
.
there
is
a
gener
rule
for
move
a
tower
of
size
n
(
n
>
1
)
from
the
peg
S
to
the
peg
T
:
move
a
tower
of
n
-
1
disc
dn-1
...
D1
from
S
to
A
.
disk
Dn
is
left
alon
on
peg
S
move
disk
Dn
to
T
move
the
tower
of
n
-
1
disc
dn-1
...
D1
on
A
to
T
,
i.e
.
thi
tower
will
be
put
on
top
of
disk
Dn
the
algorithm
,
which
we
have
just
defin
,
is
a
recurs
algorithm
to
move
a
tower
of
size
n.
It
actual
is
the
one
,
which
we
will
use
in
our
python
implement
to
solv
the
tower
of
hanoi
.
step
2
is
a
simpl
move
of
a
disk
.
but
to
accomplish
the
step
1
and
3
,
we
appli
the
same
algorithm
again
on
a
tower
of
n-1
.
the
calcul
will
finish
with
a
finit
number
of
step
,
becaus
veri
time
the
recurs
will
be
start
with
a
tower
which
is
1
smaller
than
the
one
in
the
call
function
.
So
final
we
will
end
up
with
a
tower
of
size
n
=
1
,
i.e
.
a
simpl
move
.
recurs
python
program
the
follow
python
script
contain
a
recurs
function
``
hanoi
''
,
which
implement
a
recurs
solut
for
tower
of
hanoi
:
def
hanoi
(
n
,
sourc
,
helper
,
target
)
:
if
n
>
0
:
#
move
tower
of
size
n
-
1
to
helper
:
hanoi
(
n
-
1
,
sourc
,
target
,
helper
)
#
move
disk
from
sourc
peg
to
target
peg
if
sourc
:
target.append
(
source.pop
(
)
)
#
move
tower
of
size
n-1
from
helper
to
target
hanoi
(
n
-
1
,
helper
,
sourc
,
target
)
sourc
=
[
4,3,2,1
]
target
=
[
]
helper
=
[
]
hanoi
(
len
(
sourc
)
,
sourc
,
helper
,
target
)
print
sourc
,
helper
,
target
thi
function
is
implement
,
what
we
have
explain
in
the
previou
subchapt
.
first
we
move
a
tower
of
size
n-1
from
the
peg
sourc
to
the
helper
peg
.
We
do
thi
by
call
hanoi
(
n
-
1
,
sourc
,
target
,
helper
)
after
thi
,
there
will
be
the
largest
disk
left
on
the
peg
sourc
.
We
move
it
to
the
empti
peg
target
by
the
statement
if
sourc
:
target.append
(
source.pop
(
)
)
after
thi
,
we
have
to
move
the
tower
from
``
helper
''
to
``
target
''
,
i.e
.
on
top
of
the
largest
disk
:
hanoi
(
n
-
1
,
helper
,
sourc
,
target
)
If
you
want
to
check
,
what
's
go
on
,
while
the
recurs
is
run
,
we
suggest
the
follow
python
programm
.
We
have
slightli
chang
the
data
structur
.
instead
of
pass
just
the
stack
of
disk
to
the
function
,
we
pass
tupl
to
the
function
.
each
tupl
consist
of
the
stack
and
the
function
of
the
stack
:
def
hanoi
(
n
,
sourc
,
helper
,
target
)
:
print
``
hanoi
(
``
,
n
,
sourc
,
helper
,
target
,
``
call
''
if
n
>
0
:
#
move
tower
of
size
n
-
1
to
helper
:
hanoi
(
n
-
1
,
sourc
,
target
,
helper
)
#
move
disk
from
sourc
peg
to
target
peg
if
sourc
[
0
]
:
disk
=
sourc
[
0
]
.pop
(
)
print
``
move
``
+
str
(
disk
)
+
``
from
``
+
sourc
[
1
]
+
``
to
``
+
target
[
1
]
target
[
0
]
.append
(
disk
)
#
move
tower
of
size
n-1
from
helper
to
target
hanoi
(
n
-
1
,
helper
,
sourc
,
target
)
sourc
=
(
[
4,3,2,1
]
,
``
sourc
''
)
target
=
(
[
]
,
``
target
''
)
helper
=
(
[
]
,
``
helper
''
)
hanoi
(
len
(
sourc
[
0
]
)
,
sourc
,
helper
,
target
)
print
sourc
,
helper
,
target
previou
chapter
:
levenshtein
distanc
next
chapter
:
mastermind
/
bull
and
cow
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

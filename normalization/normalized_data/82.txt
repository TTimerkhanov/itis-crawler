numer
&
scientif
comput
with
python
:
oper
and
oper
in
numpi
and
'core
'
python
numer
python
cours
numer
program
numpi
introductioncr
numpi
arraysdata
type
object
,
dtypenumer
oper
on
numpi
arrayschang
the
dimens
of
arrayspython
,
numpi
and
probabilityweight
choic
and
weight
samplescr
of
synthet
test
databoolean
mask
of
arraysmatrix
arithmeticread
and
write
ndarraysmatplotlib
introductionspin
and
tickslegend
and
annotationsmultipl
figur
and
axeshistogramscontour
plotspython
imag
process
tutorialimag
process
techniquespanda
tutorialpanda
dataframespanda
data
filesd
with
nanbin
datapanda
tutori
continu
:
multi-level
indexingdata
visual
with
panda
and
pythonpython
,
date
and
timepython
,
panda
and
timeserieslinear
combin
python
In
greek
mytholog
,
python
is
the
name
of
a
a
huge
serpent
and
sometim
a
dragon
.
python
had
been
kill
by
the
god
apollo
at
delphi
.
python
wa
creat
out
of
the
slime
and
mud
left
after
the
great
flood
.
He
wa
appoint
by
gaia
(
mother
earth
)
to
guard
the
oracl
of
delphi
,
known
as
pytho
.
the
program
languag
python
ha
not
been
creat
out
of
slime
and
mud
but
out
of
the
program
languag
abc
.
It
ha
been
devis
by
a
dutch
programm
,
name
guido
van
rossum
,
in
amsterdam
.
origin
of
python
guido
van
rossum
wrote
the
follow
about
the
origin
of
python
in
a
foreword
for
the
book
``
program
python
''
by
mark
lutz
in
1996
:
``
over
six
year
ago
,
in
decemb
1989
,
I
wa
look
for
a
``
hobbi
''
program
project
that
would
keep
me
occupi
dure
the
week
around
christma
.
My
offic
(
a
government-run
research
lab
in
amsterdam
)
would
be
close
,
but
I
had
a
home
comput
,
and
not
much
els
on
my
hand
.
I
decid
to
write
an
interpret
for
the
new
script
languag
I
had
been
think
about
late
:
a
descend
of
abc
that
would
appeal
to
unix/c
hacker
.
I
chose
python
as
a
work
titl
for
the
project
,
be
in
a
slightli
irrever
mood
(
and
a
big
fan
of
monti
python
's
fli
circu
)
.
''
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
numerisch
operationen
auf
arraysclassroom
train
cours
thi
websit
contain
a
free
and
extens
onlin
tutori
by
bernd
klein
,
use
materi
from
hi
classroom
python
train
cours
.
If
you
are
interest
in
an
instructor-l
classroom
train
cours
,
you
may
have
a
look
at
the
python
class
by
bernd
klein
at
bodenseo
.
©
kabliczech
-
fotolia.com
quot
of
the
day
:
''
At
least
for
the
peopl
who
send
me
mail
about
a
new
languag
that
they
're
design
,
the
gener
advic
is
:
do
it
to
learn
about
how
to
write
a
compiler.
``
(
denni
ritchi
)
If
you
have
the
choic
work
with
python
2
or
python
3
,
we
recomend
to
switch
to
python
3
!
you
can
read
our
python
tutori
to
see
what
the
differ
are
.
data
protect
declar
data
protect
declar
previou
chapter
:
data
type
object
,
dtype
next
chapter
:
chang
the
dimens
of
array
numer
oper
on
numpi
array
We
have
seen
lot
of
oper
in
our
python
tutori
.
Of
cours
,
we
have
also
seen
mani
case
of
oper
overload
,
e.g
.
``
+
''
for
the
addit
of
numer
valu
and
the
concaten
of
string
.
42
+
5
``
python
is
one
of
the
best
``
+
``
or
mayb
the
best
program
languag
!
''
We
will
learn
in
thi
introduct
that
the
oper
sign
are
overload
in
numpi
as
well
,
so
that
they
can
be
use
in
a
``
natur
''
way
.
We
can
,
for
exampl
,
add
a
scalar
to
an
ndarray
,
i.e
.
the
scalar
will
be
ad
to
everi
compon
.
the
same
is
possibl
for
subtract
,
divis
,
multipl
and
even
for
appli
function
,
like
sine
,
cosin
and
so
on
,
to
an
array
.
It
is
also
extrem
easi
to
use
all
these
oper
on
two
array
as
well
.
use
scalarslet
's
start
with
ad
scalar
to
array
:
import
numpi
as
np
lst
=
[
2,3
,
7.9
,
3.3
,
6.9
,
0.11
,
10.3
,
12.9
]
v
=
np.array
(
lst
)
v
=
v
+
2
print
(
v
)
[
4
.
5
.
9.9
5.3
8.9
2.11
12.3
14.9
]
multipl
,
subtract
,
divis
and
exponenti
are
as
easi
as
the
previou
addit
:
print
(
v
*
2.2
)
[
4.4
6.6
17.38
7.26
15.18
0.242
22.66
28.38
]
print
(
v
-
1.38
)
[
0.62
1.62
6.52
1.92
5.52
-1.27
8.92
11.52
]
print
(
v
**
2
)
print
(
v
**
1.5
)
[
4.00000000e+00
9.00000000e+00
6.24100000e+01
1.08900000e+01
4.76100000e+01
1.21000000e-02
1.06090000e+02
1.66410000e+02
]
[
2.82842712e+00
5.19615242e+00
2.22044815e+01
5.99474770e+00
1.81248172e+01
3.64828727e-02
3.30564215e+01
4.63323753e+01
]
We
start
thi
exampl
with
a
list
lst
,
which
we
turn
into
the
array
v.
Do
you
know
how
to
perform
the
abov
oper
on
a
list
,
i.e
.
multipli
,
add
,
subtract
and
exponenti
everi
element
of
the
list
with
a
scalar
?
We
could
use
a
for
loop
for
thi
purpos
.
let
us
do
it
for
the
addit
without
loss
of
gener
.
We
will
add
the
valu
2
to
everi
element
of
the
list
:
lst
=
[
2,3
,
7.9
,
3.3
,
6.9
,
0.11
,
10.3
,
12.9
]
re
=
[
]
for
val
in
lst
:
res.append
(
val
+
2
)
print
(
re
)
[
4
,
5
,
9.9
,
5.3
,
8.9
,
2.11
,
12.3
,
14.9
]
even
though
thi
solut
work
it
is
not
the
python
way
to
do
it
.
We
will
rather
use
a
list
comprehens
for
thi
purpos
than
the
clumsi
solut
abov
.
If
you
are
not
familar
with
thi
approach
,
you
may
consult
our
chapter
on
list
comprehens
in
our
python
cours
.
re
=
[
val
+
2
for
val
in
lst
]
print
(
re
)
[
4
,
5
,
9.9
,
5.3
,
8.9
,
2.11
,
12.3
,
14.9
]
even
though
we
had
alreadi
measur
the
time
consum
by
numpi
compar
to
``
plane
''
python
,
we
will
compar
these
two
approach
as
well
:
v
=
np.random.randint
(
0
,
100
,
1000
)
%
timeit
v
+
1
1000000
loop
,
best
of
3
:
1.69
µs
per
loop
lst
=
list
(
v
)
%
timeit
[
val
+
2
for
val
in
lst
]
1000
loop
,
best
of
3
:
452
µs
per
loop
arithmet
oper
with
two
array
If
we
use
anoth
array
instead
of
a
scalar
,
the
element
of
both
array
will
be
component-wis
combin
:
import
numpi
as
np
A
=
np.array
(
[
[
11
,
12
,
13
]
,
[
21
,
22
,
23
]
,
[
31
,
32
,
33
]
]
)
B
=
np.one
(
(
3,3
)
)
print
(
``
ad
to
array
:
``
)
print
(
A
+
B
)
print
(
``
\nmultipli
two
array
:
``
)
print
(
A
*
(
B
+
1
)
)
ad
to
array
:
[
[
12
.
13
.
14
.
]
[
22
.
23
.
24
.
]
[
32
.
33
.
34
.
]
]
multipli
two
array
:
[
[
22
.
24
.
26
.
]
[
42
.
44
.
46
.
]
[
62
.
64
.
66
.
]
]
``
A
*
B
''
in
the
previou
exampl
should
n't
be
mistaken
for
matrix
multipl
.
the
element
are
sole
component-wis
multipli
.
matrix
multipl
:
for
thi
purpos
,
we
can
use
the
dot
product
.
use
the
previou
array
,
we
can
calcul
the
matrix
multipl
:
np.dot
(
A
,
B
)
the
abov
code
return
the
follow
output
:
array
(
[
[
36.
,
36.
,
36
.
]
,
[
66.
,
66.
,
66
.
]
,
[
96.
,
96.
,
96
.
]
]
)
definit
of
the
dot
product
the
dot
product
is
defin
like
thi
:
dot
(
a
,
b
,
out=non
)
for
2-d
array
the
dot
product
is
equival
to
matrix
multipl
.
for
1-d
array
it
is
the
same
as
the
inner
product
of
vector
(
without
complex
conjug
)
.
for
N
dimens
it
is
a
sum
product
over
the
last
axi
of
'
a
'
and
the
second-to-last
of
'
b
'
:
:
paramet
mean
a
array
or
array
like
argument
b
array
or
array
like
argument
out
'out
'
is
an
option
paramet
,
which
must
have
the
exact
kind
of
what
would
be
return
,
if
it
wa
not
use
.
thi
is
a
perform
featur
.
therefor
,
if
these
condit
are
not
met
,
an
except
is
rais
,
instead
of
attempt
to
be
flexibl
.
the
function
dot
return
the
dot
product
of
'
a
'
and
'
b
'
.
If
'
a
'
and
'
b
'
are
both
scalar
or
both
1-d
array
then
a
scalar
is
return
;
otherwis
an
array
will
return
.
It
will
rais
a
valueerror
,
if
the
shape
of
the
last
dimens
of
'
a
'
is
not
the
same
size
as
the
shape
of
the
second-to-last
dimens
of
'
b
'
,
i.e
.
a.shap
[
-1
]
==
b.shape
[
-2
]
exampl
of
use
the
dot
productw
will
begin
with
the
case
in
which
both
argument
are
scalar
or
one-dimension
array
:
print
(
np.dot
(
3
,
4
)
)
x
=
np.array
(
[
3
]
)
y
=
np.array
(
[
4
]
)
print
(
x.ndim
)
print
(
np.dot
(
x
,
y
)
)
x
=
np.array
(
[
3
,
-2
]
)
y
=
np.array
(
[
-4
,
1
]
)
print
(
np.dot
(
x
,
y
)
)
12
1
12
-14
let
's
go
to
the
two-dimension
use
case
:
A
=
np.array
(
[
[
1
,
2
,
3
]
,
[
3
,
2
,
1
]
]
)
B
=
np.array
(
[
[
2
,
3
,
4
,
-2
]
,
[
1
,
-1
,
2
,
3
]
,
[
1
,
2
,
3
,
0
]
]
)
#
es
muss
gelten
:
print
(
a.shap
[
-1
]
==
b.shape
[
-2
]
,
a.shap
[
1
]
)
print
(
np.dot
(
A
,
B
)
)
(
true
,
3
)
[
[
7
7
17
4
]
[
9
9
19
0
]
]
We
can
learn
from
the
previou
exampl
that
the
number
of
column
of
the
first
two-dimens
array
have
to
be
the
same
as
the
number
of
the
line
of
the
second
two-dimension
array
.
the
dot
product
in
the
3-dimension
caseit
's
get
realli
vex
,
if
we
use
3-dimension
array
as
the
argument
of
dot
.
We
will
use
two
symmetr
three-dimension
array
in
the
first
exampl
:
import
numpi
as
np
X
=
np.array
(
[
[
[
3
,
1
,
2
]
,
[
4
,
2
,
2
]
,
[
2
,
4
,
1
]
]
,
[
[
3
,
2
,
2
]
,
[
4
,
4
,
3
]
,
[
4
,
1
,
1
]
]
,
[
[
2
,
2
,
1
]
,
[
3
,
1
,
3
]
,
[
3
,
2
,
3
]
]
]
)
Y
=
np.array
(
[
[
[
2
,
3
,
1
]
,
[
2
,
2
,
4
]
,
[
3
,
4
,
4
]
]
,
[
[
1
,
4
,
1
]
,
[
4
,
1
,
2
]
,
[
4
,
1
,
2
]
]
,
[
[
1
,
2
,
3
]
,
[
4
,
1
,
1
]
,
[
3
,
1
,
4
]
]
]
)
R
=
np.dot
(
X
,
Y
)
print
(
``
the
shape
:
''
)
print
(
x.shape
)
print
(
y.shape
)
print
(
r.shape
)
print
(
``
\nthe
result
R
:
''
)
print
(
R
)
the
shape
:
(
3
,
3
,
3
)
(
3
,
3
,
3
)
(
3
,
3
,
3
,
3
)
the
result
R
:
[
[
[
[
14
19
15
]
[
15
15
9
]
[
13
9
18
]
]
[
[
18
24
20
]
[
20
20
12
]
[
18
12
22
]
]
[
[
15
18
22
]
[
22
13
12
]
[
21
9
14
]
]
]
[
[
[
16
21
19
]
[
19
16
11
]
[
17
10
19
]
]
[
[
25
32
32
]
[
32
23
18
]
[
29
15
28
]
]
[
[
13
18
12
]
[
12
18
8
]
[
11
10
17
]
]
]
[
[
[
11
14
14
]
[
14
11
8
]
[
13
7
12
]
]
[
[
17
23
19
]
[
19
16
11
]
[
16
10
22
]
]
[
[
19
25
23
]
[
23
17
13
]
[
20
11
23
]
]
]
]
To
demonstr
how
the
dot
product
in
the
three-dimension
case
work
,
we
will
use
differ
array
with
non-symmetr
shape
in
the
follow
exampl
:
import
numpi
as
np
X
=
np.array
(
[
[
[
3
,
1
,
2
]
,
[
4
,
2
,
2
]
]
,
[
[
-1
,
0
,
1
]
,
[
1
,
-1
,
-2
]
]
,
[
[
3
,
2
,
2
]
,
[
4
,
4
,
3
]
]
,
[
[
2
,
2
,
1
]
,
[
3
,
1
,
3
]
]
]
)
Y
=
np.array
(
[
[
[
2
,
3
,
1
,
2
,
1
]
,
[
2
,
2
,
2
,
0
,
0
]
,
[
3
,
4
,
0
,
1
,
-1
]
]
,
[
[
1
,
4
,
3
,
2
,
2
]
,
[
4
,
1
,
1
,
4
,
-3
]
,
[
4
,
1
,
0
,
3
,
0
]
]
]
)
R
=
np.dot
(
X
,
Y
)
print
(
``
x.shape
:
``
,
x.shape
,
``
x.ndim
:
``
,
x.ndim
)
print
(
``
y.shape
:
``
,
y.shape
,
``
y.ndim
:
``
,
y.ndim
)
print
(
``
r.shape
:
``
,
r.shape
,
``
r.ndim
:
``
,
r.ndim
)
print
(
``
\nthe
result
array
R
:
\n
''
)
print
(
R
)
(
'
x.shape
:
'
,
(
4
,
2
,
3
)
,
'
x.ndim
:
'
,
3
)
(
'
y.shape
:
'
,
(
2
,
3
,
5
)
,
'
y.ndim
:
'
,
3
)
(
'
r.shape
:
'
,
(
4
,
2
,
2
,
5
)
,
'
r.ndim
:
'
,
4
)
the
result
array
R
:
[
[
[
[
14
19
5
8
1
]
[
15
15
10
16
3
]
]
[
[
18
24
8
10
2
]
[
20
20
14
22
2
]
]
]
[
[
[
1
1
-1
-1
-2
]
[
3
-3
-3
1
-2
]
]
[
[
-6
-7
-1
0
3
]
[
-11
1
2
-8
5
]
]
]
[
[
[
16
21
7
8
1
]
[
19
16
11
20
0
]
]
[
[
25
32
12
11
1
]
[
32
23
16
33
-4
]
]
]
[
[
[
11
14
6
5
1
]
[
14
11
8
15
-2
]
]
[
[
17
23
5
9
0
]
[
19
16
10
19
3
]
]
]
]
let
's
have
a
look
at
the
follow
sum
product
:
i
=
0
for
j
in
rang
(
x.shape
[
1
]
)
:
for
k
in
rang
(
y.shape
[
0
]
)
:
for
m
in
rang
(
y.shape
[
2
]
)
:
fmt
=
``
sum
(
X
[
{
}
,
{
}
,
:
]
*
Y
[
{
}
,
:
,
{
}
]
:
{
}
''
argument
=
(
i
,
j
,
k
,
m
,
sum
(
X
[
i
,
j
,
:
]
*
Y
[
k
,
:
,
m
]
)
)
print
(
fmt.format
(
*argument
)
)
sum
(
X
[
0
,
0
,
:
]
*
Y
[
0
,
:
,
0
]
:
14
sum
(
X
[
0
,
0
,
:
]
*
Y
[
0
,
:
,
1
]
:
19
sum
(
X
[
0
,
0
,
:
]
*
Y
[
0
,
:
,
2
]
:
5
sum
(
X
[
0
,
0
,
:
]
*
Y
[
0
,
:
,
3
]
:
8
sum
(
X
[
0
,
0
,
:
]
*
Y
[
0
,
:
,
4
]
:
1
sum
(
X
[
0
,
0
,
:
]
*
Y
[
1
,
:
,
0
]
:
15
sum
(
X
[
0
,
0
,
:
]
*
Y
[
1
,
:
,
1
]
:
15
sum
(
X
[
0
,
0
,
:
]
*
Y
[
1
,
:
,
2
]
:
10
sum
(
X
[
0
,
0
,
:
]
*
Y
[
1
,
:
,
3
]
:
16
sum
(
X
[
0
,
0
,
:
]
*
Y
[
1
,
:
,
4
]
:
3
sum
(
X
[
0
,
1
,
:
]
*
Y
[
0
,
:
,
0
]
:
18
sum
(
X
[
0
,
1
,
:
]
*
Y
[
0
,
:
,
1
]
:
24
sum
(
X
[
0
,
1
,
:
]
*
Y
[
0
,
:
,
2
]
:
8
sum
(
X
[
0
,
1
,
:
]
*
Y
[
0
,
:
,
3
]
:
10
sum
(
X
[
0
,
1
,
:
]
*
Y
[
0
,
:
,
4
]
:
2
sum
(
X
[
0
,
1
,
:
]
*
Y
[
1
,
:
,
0
]
:
20
sum
(
X
[
0
,
1
,
:
]
*
Y
[
1
,
:
,
1
]
:
20
sum
(
X
[
0
,
1
,
:
]
*
Y
[
1
,
:
,
2
]
:
14
sum
(
X
[
0
,
1
,
:
]
*
Y
[
1
,
:
,
3
]
:
22
sum
(
X
[
0
,
1
,
:
]
*
Y
[
1
,
:
,
4
]
:
2
hope
,
you
have
notic
that
we
have
creat
the
element
of
R
[
0
]
,
one
ofter
the
other
.
print
(
R
[
0
]
)
[
[
[
14
19
5
8
1
]
[
15
15
10
16
3
]
]
[
[
18
24
8
10
2
]
[
20
20
14
22
2
]
]
]
thi
mean
that
we
could
have
creat
the
array
R
by
appli
the
sum
product
in
the
way
abov
.
To
``
prove
''
thi
,
we
will
creat
an
array
R2
by
use
the
sum
product
,
which
is
equal
to
R
in
the
follow
exampl
:
R2
=
np.zero
(
r.shape
,
dtype=np.int
)
for
i
in
rang
(
x.shape
[
0
]
)
:
for
j
in
rang
(
x.shape
[
1
]
)
:
for
k
in
rang
(
y.shape
[
0
]
)
:
for
m
in
rang
(
y.shape
[
2
]
)
:
R2
[
i
,
j
,
k
,
m
]
=
sum
(
X
[
i
,
j
,
:
]
*
Y
[
k
,
:
,
m
]
)
print
(
np.array_equ
(
R
,
R2
)
)
true
matric
vs.
two-dimension
arrayssom
may
have
taken
two-dimension
array
of
numpi
as
matric
.
thi
is
principi
all
right
,
becaus
they
behav
in
most
aspect
like
our
mathemat
idea
of
a
matrix
.
We
even
saw
that
we
can
perform
matrix
multipl
on
them
.
yet
,
there
is
a
subtl
differ
.
there
are
``
real
''
matric
in
numpi
.
they
are
a
subset
of
the
two-dimension
array
.
We
can
turn
a
two-dimension
array
into
a
matrix
by
appli
the
``
mat
''
function
.
the
main
differ
show
,
if
you
multipli
two
two-dimension
array
or
two
matric
.
We
get
real
matrix
multipl
by
multipli
two
matric
,
but
the
two-dimension
array
will
be
onli
multipli
component-wis
:
import
numpi
as
np
A
=
np.array
(
[
[
1
,
2
,
3
]
,
[
2
,
2
,
2
]
,
[
3
,
3
,
3
]
]
)
B
=
np.array
(
[
[
3
,
2
,
1
]
,
[
1
,
2
,
3
]
,
[
-1
,
-2
,
-3
]
]
)
R
=
A
*
B
print
(
R
)
[
[
3
4
3
]
[
2
4
6
]
[
-3
-6
-9
]
]
MA
=
np.mat
(
A
)
MB
=
np.mat
(
B
)
R
=
MA
*
MB
print
(
R
)
[
[
2
0
-2
]
[
6
4
2
]
[
9
6
3
]
]
comparison
oper
We
are
use
to
comparison
oper
from
python
,
when
we
appli
them
to
integ
,
float
or
string
for
exampl
.
We
use
them
to
test
for
true
or
fals
.
If
we
compar
two
array
,
we
do
n't
get
a
simpl
true
or
fals
as
a
return
valu
.
the
comparison
are
perform
elementswis
.
thi
mean
that
we
get
a
boolean
array
as
a
return
valu
:
import
numpi
as
np
A
=
np.array
(
[
[
11
,
12
,
13
]
,
[
21
,
22
,
23
]
,
[
31
,
32
,
33
]
]
)
B
=
np.array
(
[
[
11
,
102
,
13
]
,
[
201
,
22
,
203
]
,
[
31
,
32
,
303
]
]
)
A
==
B
the
abov
python
code
return
the
follow
output
:
array
(
[
[
true
,
fals
,
true
]
,
[
fals
,
true
,
fals
]
,
[
true
,
true
,
fals
]
]
,
dtype=bool
)
It
is
possibl
to
compar
complet
array
for
equal
as
well
.
We
use
array_equ
for
thi
purpos
.
array_equ
return
true
if
two
array
have
the
same
shape
and
element
,
otherwis
fals
will
be
return
.
print
(
np.array_equ
(
A
,
B
)
)
print
(
np.array_equ
(
A
,
A
)
)
fals
true
logic
oper
We
can
also
appli
the
logic
'or
'
and
the
logic
'and
'
to
array
elementwis
.
We
can
use
the
function
'logical_or
'
and
'logical_and
'
to
thi
purpos
.
a
=
np.array
(
[
[
true
,
true
]
,
[
fals
,
fals
]
]
)
b
=
np.array
(
[
[
true
,
fals
]
,
[
true
,
fals
]
]
)
print
(
np.logical_or
(
a
,
b
)
)
print
(
np.logical_and
(
a
,
b
)
)
[
[
true
true
]
[
true
fals
]
]
[
[
true
fals
]
[
fals
fals
]
]
appli
oper
on
array
with
differ
shape
So
far
we
have
cover
two
differ
case
with
basic
oper
like
``
+
''
or
``
*
''
:
an
oper
appli
to
an
array
and
a
scalar
an
oper
appli
to
two
array
of
the
same
shape
We
will
see
in
the
follow
that
we
can
also
appli
oper
on
array
,
if
they
have
differ
shape
.
yet
,
it
work
onli
under
certain
condit
.
broadcastingnumpi
provid
a
power
mechan
,
call
broadcast
,
which
allow
to
perform
arithmet
oper
on
array
of
differ
shape
.
thi
mean
that
we
have
a
smaller
array
and
a
larger
array
,
and
we
transform
or
appli
the
smaller
array
multipl
time
to
perform
some
oper
on
the
larger
array
.
In
other
word
:
under
certain
condit
,
the
smaller
array
is
``
broadcast
''
in
a
way
that
it
ha
the
same
shape
as
the
larger
array
.
with
the
aid
of
broadcast
we
can
avoid
loop
in
our
python
program
.
the
loop
occur
implicitli
in
the
numpi
implement
,
i.e
.
in
C.
We
also
avoid
creat
unnecessari
copi
of
our
data
.
We
demonstr
the
oper
principl
of
broadcast
in
three
simpl
and
descript
exampl
.
first
exampl
of
broadcast
:
import
numpi
as
np
A
=
np.array
(
[
[
11
,
12
,
13
]
,
[
21
,
22
,
23
]
,
[
31
,
32
,
33
]
]
)
B
=
np.array
(
[
1
,
2
,
3
]
)
print
(
``
multipl
with
broadcast
:
``
)
print
(
A
*
B
)
print
(
``
...
and
now
addit
with
broadcast
:
``
)
print
(
A
+
B
)
multipl
with
broadcast
:
[
[
11
24
39
]
[
21
44
69
]
[
31
64
99
]
]
...
and
now
addit
with
broadcast
:
[
[
12
14
16
]
[
22
24
26
]
[
32
34
36
]
]
the
follow
diagram
illustr
the
way
of
work
of
broadcast
:
B
is
treat
as
if
it
were
constru
like
thi
:
B
=
np.array
(
[
[
1
,
2
,
3
]
,
]
*
3
)
print
(
B
)
[
[
1
2
3
]
[
1
2
3
]
[
1
2
3
]
]
second
exampl
:
for
thi
exampl
,
we
need
to
know
how
to
turn
a
row
vector
into
a
column
vector
:
B
=
np.array
(
[
1
,
2
,
3
]
)
B
[
:
,
np.newaxi
]
the
abov
code
return
the
follow
output
:
array
(
[
[
1
]
,
[
2
]
,
[
3
]
]
)
now
we
are
capabl
of
do
the
multiplipl
use
broadcast
:
A
*
B
[
:
,
np.newaxi
]
thi
get
us
the
follow
output
:
array
(
[
[
11
,
12
,
13
]
,
[
42
,
44
,
46
]
,
[
93
,
96
,
99
]
]
)
B
is
treat
as
if
it
were
constru
like
thi
:
np.array
(
[
[
1
,
2
,
3
]
,
]
*
3
)
.transpos
(
)
after
have
execut
the
python
code
abov
we
receiv
the
follow
:
array
(
[
[
1
,
1
,
1
]
,
[
2
,
2
,
2
]
,
[
3
,
3
,
3
]
]
)
third
exampl
:
A
=
np.array
(
[
10
,
20
,
30
]
)
B
=
np.array
(
[
1
,
2
,
3
]
)
A
[
:
,
np.newaxi
]
after
have
execut
the
python
code
abov
we
receiv
the
follow
output
:
array
(
[
[
10
]
,
[
20
]
,
[
30
]
]
)
A
[
:
,
np.newaxi
]
*
B
the
previou
code
return
the
follow
result
:
array
(
[
[
10
,
20
,
30
]
,
[
20
,
40
,
60
]
,
[
30
,
60
,
90
]
]
)
anoth
way
to
Do
it
do
it
without
broadcast
:
import
numpi
as
np
A
=
np.array
(
[
[
11
,
12
,
13
]
,
[
21
,
22
,
23
]
,
[
31
,
32
,
33
]
]
)
B
=
np.array
(
[
1
,
2
,
3
]
)
B
=
B
[
np.newaxi
,
:
]
B
=
np.concaten
(
(
B
,
B
,
B
)
)
print
(
``
multipl
:
``
)
print
(
A
*
B
)
print
(
``
...
and
now
addit
again
:
``
)
print
(
A
+
B
)
multipl
:
[
[
11
24
39
]
[
21
44
69
]
[
31
64
99
]
]
...
and
now
addit
again
:
[
[
12
14
16
]
[
22
24
26
]
[
32
34
36
]
]
use
'tile
'
:
import
numpi
as
np
A
=
np.array
(
[
[
11
,
12
,
13
]
,
[
21
,
22
,
23
]
,
[
31
,
32
,
33
]
]
)
B
=
np.tile
(
np.array
(
[
1
,
2
,
3
]
)
,
(
3
,
1
)
)
print
(
B
)
print
(
``
multipl
:
``
)
print
(
A
*
B
)
print
(
``
...
and
now
addit
again
:
``
)
print
(
A
+
B
)
[
[
1
2
3
]
[
1
2
3
]
[
1
2
3
]
]
multipl
:
[
[
11
24
39
]
[
21
44
69
]
[
31
64
99
]
]
...
and
now
addit
again
:
[
[
12
14
16
]
[
22
24
26
]
[
32
34
36
]
]
distanc
matrix
In
mathemat
,
comput
scienc
and
especi
graph
theori
,
a
distanc
matrix
is
a
matrix
or
a
two-dimension
array
,
which
contain
the
distanc
between
the
element
of
a
set
,
pairwis
taken
.
the
size
of
thi
two-dimension
array
in
n
x
n
,
if
the
set
consist
of
n
element
.
A
practic
exampl
of
a
distanc
matrix
is
a
distanc
matrix
between
geograph
locat
,
in
our
exampl
eurpean
citi
:
citi
=
[
``
barcelona
''
,
``
berlin
''
,
``
brussel
''
,
``
bucharest
''
,
``
budapest
''
,
``
copenhagen
''
,
``
dublin
''
,
``
hamburg
''
,
``
istanbul
''
,
``
kiev
''
,
``
london
''
,
``
madrid
''
,
``
milan
''
,
``
moscow
''
,
``
munich
''
,
``
pari
''
,
``
pragu
''
,
``
rome
''
,
``
saint
petersburg
''
,
``
stockholm
''
,
``
vienna
''
,
``
warsaw
''
]
dist2barcelona
=
[
0
,
1498
,
1063
,
1968
,
1498
,
1758
,
1469
,
1472
,
2230
,
2391
,
1138
,
505
,
725
,
3007
,
1055
,
833
,
1354
,
857
,
2813
,
2277
,
1347
,
1862
]
dist
=
np.array
(
dist2barcelona
[
:12
]
)
print
(
dist
)
print
(
np.ab
(
dist
-
dist
[
:
,
np.newaxi
]
)
)
[
0
1498
1063
1968
1498
1758
1469
1472
2230
2391
1138
505
]
[
[
0
1498
1063
1968
1498
1758
1469
1472
2230
2391
1138
505
]
[
1498
0
435
470
0
260
29
26
732
893
360
993
]
[
1063
435
0
905
435
695
406
409
1167
1328
75
558
]
[
1968
470
905
0
470
210
499
496
262
423
830
1463
]
[
1498
0
435
470
0
260
29
26
732
893
360
993
]
[
1758
260
695
210
260
0
289
286
472
633
620
1253
]
[
1469
29
406
499
29
289
0
3
761
922
331
964
]
[
1472
26
409
496
26
286
3
0
758
919
334
967
]
[
2230
732
1167
262
732
472
761
758
0
161
1092
1725
]
[
2391
893
1328
423
893
633
922
919
161
0
1253
1886
]
[
1138
360
75
830
360
620
331
334
1092
1253
0
633
]
[
505
993
558
1463
993
1253
964
967
1725
1886
633
0
]
]
3-dimension
broadcast
A
=
np.array
(
[
[
[
3
,
4
,
7
]
,
[
5
,
0
,
-1
]
,
[
2
,
1
,
5
]
]
,
[
[
1
,
0
,
-1
]
,
[
8
,
2
,
4
]
,
[
5
,
2
,
1
]
]
,
[
[
2
,
1
,
3
]
,
[
1
,
9
,
4
]
,
[
5
,
-2
,
4
]
]
]
)
B
=
np.array
(
[
[
[
3
,
4
,
7
]
,
[
1
,
0
,
-1
]
,
[
1
,
2
,
3
]
]
]
)
B
*
A
thi
get
us
the
follow
output
:
array
(
[
[
[
9
,
16
,
49
]
,
[
5
,
0
,
1
]
,
[
2
,
2
,
15
]
]
,
[
[
3
,
0
,
-7
]
,
[
8
,
0
,
-4
]
,
[
5
,
4
,
3
]
]
,
[
[
6
,
4
,
21
]
,
[
1
,
0
,
-4
]
,
[
5
,
-4
,
12
]
]
]
)
We
will
use
the
follow
transform
in
our
chapter
on
imag
manipul
and
process
:
B
=
np.array
(
[
1
,
2
,
3
]
)
B
=
B
[
np.newaxi
,
:
]
print
(
b.shape
)
B
=
np.concaten
(
(
B
,
B
,
B
)
)
.transpos
(
)
print
(
b.shape
)
B
=
B
[
:
,
np.newaxi
]
print
(
b.shape
)
print
(
B
)
print
(
A
*
B
)
(
1
,
3
)
(
3
,
3
)
(
3
,
1
,
3
)
[
[
[
1
1
1
]
]
[
[
2
2
2
]
]
[
[
3
3
3
]
]
]
[
[
[
3
4
7
]
[
5
0
-1
]
[
2
1
5
]
]
[
[
2
0
-2
]
[
16
4
8
]
[
10
4
2
]
]
[
[
6
3
9
]
[
3
27
12
]
[
15
-6
12
]
]
]
previou
chapter
:
data
type
object
,
dtype
next
chapter
:
chang
the
dimens
of
array
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

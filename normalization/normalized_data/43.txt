python
tutori
:
road
to
metaclass
python
cours
python
3
tutori
the
origin
of
pythonstart
with
python
:
the
interact
shellexecut
a
scriptindentationdata
type
and
variablesoperatorssequenti
data
type
:
list
and
stringslist
manipulationsshallow
and
deep
copydictionariesset
and
frozen
setsan
extens
exampl
use
setsinput
via
the
keyboardcondit
statementsloop
,
while
loopfor
loopsdiffer
between
inter
und
iterablesoutput
with
printformat
output
with
string
modulo
and
the
format
methodfunctionsrecurs
and
recurs
functionsparamet
pass
in
functionsnamespacesglob
and
local
variablesdecoratorsmemo
with
decoratorsread
and
write
filesmodular
program
and
modulespackag
in
pythonregular
expressionsregular
express
,
advancedlambda
oper
,
filter
,
reduc
and
maplist
comprehensioniter
and
generatorsexcept
handlingtest
,
doctest
,
unittestsobject
orient
programmingclass
and
instanc
attributesproperti
vs.
getter
and
settersinheritancemultipl
inheritancemag
method
and
oper
overloadingoop
,
inherit
exampleslotsclass
and
class
creationroad
to
metaclassesmetaclassesmetaclass
use
case
:
count
function
callsabstract
class
superclass
vs.
metaclass
metaclass
should
n't
be
withtaken
with
superclass
.
thi
websit
is
support
by
:
linux
and
python
cours
as
well
as
in-hous
cours
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
einführung
in
metaklassenpython
3thi
is
a
tutori
in
python3
,
but
thi
chapter
of
our
cours
is
avail
in
a
version
for
python
2.x
as
well
:
road
to
metaclass
in
python
2.x
train
class
thi
websit
aim
at
provid
you
with
educ
materi
suitabl
for
self-learn
.
nevertheless
,
it
is
faster
and
more
effici
to
attend
a
``
real
''
python
cours
in
a
classroom
,
with
an
experienc
trainer
.
So
whi
not
attend
one
of
the
live
python
cours
in
strasbourg
,
pari
,
london
,
berlin
,
munich
,
hamburg
,
frankfurt
,
or
lake
constanc
by
bernd
klein
,
the
author
of
thi
tutori
?
in-hous
train
cours
If
you
like
it
,
we
will
come
to
your
compani
or
institut
and
provid
a
special
train
for
your
employe
,
as
we
've
done
it
mani
time
in
amsterdam
(
the
netherland
)
,
berlin
(
germani
)
,
bern
(
switzerland
)
,
basel
(
switzerland
)
,
zurich
(
switzerland
)
,
frankfurt
(
germani
)
,
locarno
(
switzerland
)
,
den
haag
(
the
hagu
)
,
hamburg
,
munich
(
germani
)
,
bucharest
(
romania
)
,
toronto
(
canada
)
,
edmonton
(
canada
)
,
and
mani
other
citi
.
We
do
train
cours
in
england
,
switzerland
,
liechtenstein
,
austria
,
germani
,
franc
,
belgium
,
the
netherland
,
luxembourg
,
romania
,
UK
,
itali
,
spain
and
other
locat
in
europ
and
in
canada
.
thi
way
you
will
get
a
perfect
train
up
to
your
need
and
it
will
be
extrem
cost
effici
as
well
.
contact
us
so
we
can
find
the
ideal
cours
to
meet
your
need
.
skill
python
programm
you
are
look
for
experienc
python
develop
or
programm
?
We
can
help
you
,
pleas
contact
us
.
quot
of
the
day
:
''
comput
scienc
is
no
more
about
comput
than
astronomi
is
about
telescop
.
''
(
edsger
dijkstra
)
data
protect
declar
data
protect
declar
previou
chapter
:
class
and
class
creation
next
chapter
:
metaclass
On
the
road
to
metaclassesmotiv
for
metaclass
In
thi
chapter
of
our
tutori
we
want
to
provid
some
incent
or
motiv
for
the
use
of
metaclass
.
To
demonstr
some
design
problem
,
which
can
be
solv
by
metaclass
,
we
will
introduc
and
design
a
bunch
of
philosoph
class
.
each
philosoph
class
(
philosopher1
,
philosopher2
,
and
so
on
)
need
the
same
``
set
''
of
method
(
in
our
exampl
just
one
,
i.e
.
``
the_answ
''
)
as
the
basic
for
hi
or
her
ponder
and
brood
.
A
stupid
way
to
implement
the
class
consist
in
have
the
same
code
in
everi
philosph
class
:
class
philosopher1
:
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher2
:
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher3
:
def
the_answ
(
self
,
*arg
)
:
return
42
plato
=
philosopher1
(
)
print
(
plato.the_answ
(
)
)
kant
=
philosopher2
(
)
#
let
's
see
what
kant
ha
to
say
:
-
)
print
(
kant.the_answ
(
)
)
42
42
We
can
see
that
we
have
multipl
copi
of
the
method
``
the_answ
''
.
thi
is
error
prone
and
tediou
to
maintain
,
of
cours
.
from
what
we
know
so
far
,
the
easiest
way
to
accomplish
our
goal
without
creat
redund
code
consist
in
design
a
base
,
which
contain
``
the_answ
''
as
a
method
.
each
philosoph
class
inherit
now
from
thi
base
class
:
class
answer
:
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher1
(
answer
)
:
pass
class
philosopher2
(
answer
)
:
pass
class
philosopher3
(
answer
)
:
pass
plato
=
philosopher1
(
)
print
(
plato.the_answ
(
)
)
kant
=
philosopher2
(
)
#
let
's
see
what
kant
ha
to
say
:
-
)
print
(
kant.the_answ
(
)
)
42
42
the
way
we
have
design
our
class
,
each
philosoph
class
will
alway
have
a
method
``
the_answ
''
.
let
's
assum
,
we
do
n't
know
a
priori
if
we
want
or
need
thi
method
.
let
's
assum
that
the
decis
,
if
the
class
have
to
be
augment
,
can
onli
be
made
at
runtim
.
thi
decis
might
depend
on
configur
file
,
user
input
or
some
calcul
.
#
the
follow
variabl
would
be
set
as
the
result
of
a
runtim
calcul
:
x
=
input
(
``
Do
you
need
the
answer
?
(
y/n
)
:
``
)
if
x==
''
y
''
:
requir
=
true
els
:
requir
=
fals
def
the_answ
(
self
,
*arg
)
:
return
42
class
philosopher1
:
pass
if
requir
:
philosopher1.the_answ
=
the_answ
class
philosopher2
:
pass
if
requir
:
philosopher2.the_answ
=
the_answ
class
philosopher3
:
pass
if
requir
:
philosopher3.the_answ
=
the_answ
plato
=
philosopher1
(
)
kant
=
philosopher2
(
)
#
let
's
see
what
plato
and
kant
have
to
say
:
-
)
if
requir
:
print
(
kant.the_answ
(
)
)
print
(
plato.the_answ
(
)
)
els
:
print
(
``
the
silenc
of
the
philosph
''
)
Do
you
need
the
answer
?
(
y/n
)
:
y
42
42
even
though
thi
is
anoth
solut
to
our
problem
,
there
are
still
some
seriou
drawback
.
It
's
error-pron
,
becaus
we
have
to
add
the
same
code
to
everi
class
and
it
seem
like
that
we
might
forget
it
.
besid
thi
it
's
get
hardli
manag
and
mayb
even
confus
,
if
there
are
mani
method
we
want
to
add
.
We
can
improv
our
approach
by
defin
a
manag
function
and
avoid
redund
code
thi
way
.
the
manag
function
will
be
use
to
augment
the
class
condit
.
#
the
follow
variabl
would
be
set
as
the
result
of
a
runtim
calcul
:
x
=
input
(
``
Do
you
need
the
answer
?
(
y/n
)
:
``
)
if
x==
''
y
''
:
requir
=
true
els
:
requir
=
fals
def
the_answ
(
self
,
*arg
)
:
return
42
#
manag
function
def
augment_answ
(
cl
)
:
if
requir
:
cls.the_answ
=
the_answ
class
philosopher1
:
pass
augment_answ
(
philosopher1
)
class
philosopher2
:
pass
augment_answ
(
philosopher2
)
class
philosopher3
:
pass
augment_answ
(
philosopher3
)
plato
=
philosopher1
(
)
kant
=
philosopher2
(
)
#
let
's
see
what
plato
and
kant
have
to
say
:
-
)
if
requir
:
print
(
kant.the_answ
(
)
)
print
(
plato.the_answ
(
)
)
els
:
print
(
``
the
silenc
of
the
philosph
''
)
Do
you
need
the
answer
?
(
y/n
)
:
y
42
42
thi
is
again
use
to
solv
our
problem
,
but
we
,
i.e
.
the
class
design
,
must
be
care
not
to
forget
to
call
the
manag
function
``
augment_answ
''
.
the
code
should
be
execut
automat
.
We
need
a
way
to
make
sure
that
``
some
''
code
might
be
execut
automat
after
the
end
of
a
class
definit
.
#
the
follow
variabl
would
be
set
as
the
result
of
a
runtim
calcul
:
x
=
input
(
``
Do
you
need
the
answer
?
(
y/n
)
:
``
)
if
x==
''
y
''
:
requir
=
true
els
:
requir
=
fals
def
the_answ
(
self
,
*arg
)
:
return
42
def
augment_answ
(
cl
)
:
if
requir
:
cls.the_answ
=
the_answ
#
we
have
to
return
the
class
now
:
return
cl
@
augment_answ
class
philosopher1
:
pass
@
augment_answ
class
philosopher2
:
pass
@
augment_answ
class
philosopher3
:
pass
plato
=
philosopher1
(
)
kant
=
philosopher2
(
)
#
let
's
see
what
plato
and
kant
have
to
say
:
-
)
if
requir
:
print
(
kant.the_answ
(
)
)
print
(
plato.the_answ
(
)
)
els
:
print
(
``
the
silenc
of
the
philosph
''
)
Do
you
need
the
answer
?
(
y/n
)
:
y
42
42
metaclass
can
also
be
use
for
thi
purpos
as
we
will
learn
in
the
next
chapter
.
previou
chapter
:
class
and
class
creation
next
chapter
:
metaclass
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

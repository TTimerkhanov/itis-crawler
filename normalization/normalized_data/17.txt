python
tutori
:
inherit
python
cours
python
3
tutori
the
origin
of
pythonstart
with
python
:
the
interact
shellexecut
a
scriptindentationdata
type
and
variablesoperatorssequenti
data
type
:
list
and
stringslist
manipulationsshallow
and
deep
copydictionariesset
and
frozen
setsan
extens
exampl
use
setsinput
via
the
keyboardcondit
statementsloop
,
while
loopfor
loopsdiffer
between
inter
und
iterablesoutput
with
printformat
output
with
string
modulo
and
the
format
methodfunctionsrecurs
and
recurs
functionsparamet
pass
in
functionsnamespacesglob
and
local
variablesdecoratorsmemo
with
decoratorsread
and
write
filesmodular
program
and
modulespackag
in
pythonregular
expressionsregular
express
,
advancedlambda
oper
,
filter
,
reduc
and
maplist
comprehensioniter
and
generatorsexcept
handlingtest
,
doctest
,
unittestsobject
orient
programmingclass
and
instanc
attributesproperti
vs.
getter
and
settersinheritancemultipl
inheritancemag
method
and
oper
overloadingoop
,
inherit
exampleslotsclass
and
class
creationroad
to
metaclassesmetaclassesmetaclass
use
case
:
count
function
callsabstract
class
object-ori
program
``
certainli
not
everi
good
program
is
object-ori
,
and
not
everi
object-ori
program
is
good
.
''
(
bjarn
stroustrup
,
danish
comput
scientist
,
best
known
for
the
creation
and
the
develop
of
the
wide
use
c++
program
languag
.
)
``
object-ori
program
is
an
except
bad
idea
which
could
onli
have
origin
in
california
.
''
(
edsger
dijkstra
,
(
dutch
comput
scientist
,
1930-2002
)
dijkstra
also
said
:
``
...
what
societi
over­whel­mingli
ask
for
is
snake
oil
.
Of
cours
,
the
snake
oil
ha
the
most
impress
name
-
otherwis
you
would
be
sell
noth
-
like
``
structur
analysi
and
design
''
,
``
softwar
engin
''
,
``
matur
model
''
,
``
manag
inform
system
''
,
``
integr
project
support
environ
''
``
object
orient
''
and
``
busi
process
re-engin
''
japanes
food
and
oop
``
public
opinion
is
that
both
oop
and
japanes
food
are
``
good
and
good
for
you
''
,
and
both
simpl
and
pretti
.
and
they
are
!
but
that
doe
n't
automat
make
them
intuit
,
much
less
easi
.
both
are
,
in
fact
,
much
harder
than
they
look
.
``
,
sean
M.
burk
``
when
given
a
program
project
,
you
do
n't
``
solv
''
anyth
by
declar
that
thi
project
will
be
done
in
oop
,
ani
more
than
you
``
solv
''
anyth
be
survey
a
set
of
ingredi
and
declar
that
they
are
to
be
cook
japanese-styl
.
``
,
sean
M.
burk
thi
websit
is
support
by
:
linux
and
python
cours
and
seminar
thi
websit
is
free
of
annoy
ad
.
We
want
to
keep
it
like
thi
.
you
can
help
with
your
donat
:
the
need
for
donat
bernd
klein
on
facebook
search
thi
websit
:
thi
topic
in
german
/
deutsch
übersetzung
:
vererbung
train
class
thi
websit
aim
at
provid
you
with
educ
materi
suitabl
for
self-learn
.
nevertheless
,
it
is
faster
and
more
effici
to
attend
a
``
real
''
python
cours
in
a
classroom
,
with
an
experienc
trainer
.
So
whi
not
attend
one
of
the
live
python
cours
in
strasbourg
,
pari
,
london
,
berlin
,
munich
,
hamburg
,
frankfurt
,
or
lake
constanc
by
bernd
klein
,
the
author
of
thi
tutori
?
in-hous
train
cours
If
you
like
it
,
we
will
come
to
your
compani
or
institut
and
provid
a
special
train
for
your
employe
,
as
we
've
done
it
mani
time
in
amsterdam
(
the
netherland
)
,
berlin
(
germani
)
,
bern
(
switzerland
)
,
basel
(
switzerland
)
,
zurich
(
switzerland
)
,
frankfurt
(
germani
)
,
locarno
(
switzerland
)
,
den
haag
(
the
hagu
)
,
hamburg
,
munich
(
germani
)
,
bucharest
(
romania
)
,
toronto
(
canada
)
,
edmonton
(
canada
)
,
and
mani
other
citi
.
We
do
train
cours
in
england
,
switzerland
,
liechtenstein
,
austria
,
germani
,
franc
,
belgium
,
the
netherland
,
luxembourg
,
romania
,
UK
,
itali
,
spain
and
other
locat
in
europ
and
in
canada
.
thi
way
you
will
get
a
perfect
train
up
to
your
need
and
it
will
be
extrem
cost
effici
as
well
.
contact
us
so
we
can
find
the
ideal
cours
to
meet
your
need
.
skill
python
programm
you
are
look
for
experienc
python
develop
or
programm
?
We
can
help
you
,
pleas
contact
us
.
quot
of
the
day
:
''
ani
program
is
onli
as
good
as
it
is
use
.
''
(
linu
torvald
)
data
protect
declar
data
protect
declar
previou
chapter
:
properti
vs.
getter
and
setter
next
chapter
:
multipl
inherit
inherit
introduct
everi
object-ori
program
languag
would
not
be
worthi
to
look
at
or
use
,
if
it
were
n't
to
support
inherit
.
Of
cours
,
python
support
inherit
,
it
even
support
multipl
inherit
.
class
can
inherit
from
other
class
.
A
class
can
inherit
attribut
and
behaviour
method
from
anoth
class
,
call
the
superclass
.
A
class
which
inherit
from
a
superclass
is
call
a
subclass
,
also
call
heir
class
or
child
class
.
superclass
are
sometim
call
ancestor
as
well
.
there
exist
a
hierarchi
relationship
between
class
.
It
's
similar
to
relationship
or
categor
that
we
know
from
real
life
.
think
about
vehicl
,
for
exampl
.
bike
,
car
,
buse
and
truck
are
vehicl
.
pick-up
,
van
,
sport
car
,
convert
and
estat
car
are
all
car
and
by
be
car
they
are
vehicl
as
well
.
We
could
implement
a
vehicl
class
in
python
,
which
might
have
method
like
acceler
and
brake
.
car
,
buse
and
truck
and
bike
can
be
implement
as
subclass
which
will
inherit
these
method
from
vehicl
.
syntax
and
simpl
inherit
exampl
We
demonstr
inherit
in
a
veri
simpl
exampl
.
We
creat
a
person
class
with
the
two
attribut
``
firstnam
''
and
``
lastnam
''
.
thi
class
ha
onli
one
method
,
the
name
method
,
essenti
a
getter
,
but
we
do
n't
have
an
attribut
name
.
thi
method
is
a
further
exampl
for
a
``
getter
''
,
which
creat
an
output
by
creat
it
from
more
than
one
privat
attribut
.
name
return
the
concaten
of
the
first
name
and
the
last
name
of
a
person
,
separ
by
a
space
.
It
goe
without
say
that
a
use
person
class
would
have
addit
attribut
and
further
method
.
thi
chapter
of
our
tutori
is
about
inherit
,
so
we
need
a
class
,
which
inherit
from
person
.
So
far
employe
are
person
in
compani
,
even
though
they
may
not
be
treat
as
such
in
some
firm
.
If
we
creat
an
employe
class
without
inherit
from
person
,
we
would
have
to
defin
all
the
attribut
and
method
in
the
employe
class
again
.
thi
mean
we
would
creat
a
design
and
mayb
even
a
data
redund
.
with
thi
in
mind
,
we
have
to
let
employe
inherit
from
person
.
the
syntax
for
a
subclass
definit
look
like
thi
:
class
derivedclassnam
(
baseclassnam
)
:
pass
Of
cours
,
usual
we
will
have
an
indent
block
with
the
class
attribut
and
method
instead
of
mere
a
pass
statement
.
the
name
baseclassnam
must
be
defin
in
a
scope
contain
the
deriv
class
definit
.
with
all
thi
said
,
we
can
implement
our
person
and
employe
class
:
class
person
:
def
__init__
(
self
,
first
,
last
)
:
self.firstnam
=
first
self.lastnam
=
last
def
name
(
self
)
:
return
self.firstnam
+
``
``
+
self.lastnam
class
employe
(
person
)
:
def
__init__
(
self
,
first
,
last
,
staffnum
)
:
person.__init__
(
self
,
first
,
last
)
self.staffnumb
=
staffnum
def
getemploye
(
self
)
:
return
self.nam
(
)
+
``
,
``
+
self.staffnumb
x
=
person
(
``
marg
''
,
``
simpson
''
)
y
=
employe
(
``
homer
''
,
``
simpson
''
,
``
1007
''
)
print
(
x.name
(
)
)
print
(
y.getemploye
(
)
)
our
program
return
the
follow
output
:
$
python3
person.pi
marg
simpson
homer
simpson
,
1007
the
__init__
method
of
our
employe
class
explicitli
invok
the
__init__method
of
the
person
class
.
We
could
have
use
super
instead
.
super
(
)
.__init__
(
first
,
last
)
is
automat
replac
by
a
call
to
the
superclass
method
,
in
thi
case
__init__
:
def
__init__
(
self
,
first
,
last
,
staffnum
)
:
super
(
)
.__init__
(
first
,
last
)
self.staffnumb
=
staffnum
pleas
note
that
we
use
super
(
)
)
without
argument
.
thi
is
onli
possibl
in
python3
.
We
could
have
written
``
super
(
employe
,
self
)
.__init__
(
first
,
last
,
age
)
''
which
still
work
in
python3
and
is
compat
with
python2
.
overload
and
overrid
instead
of
use
the
method
``
name
''
and
``
getemploye
''
in
our
previou
exampl
,
it
might
have
been
better
to
put
thi
function
into
the
``
__str__
''
method
.
In
do
so
,
we
gain
a
lot
,
especi
a
leaner
design
.
We
have
a
string
cast
for
our
class
and
we
can
simpli
print
out
instanc
.
let
's
start
with
a
__str__
method
in
person
:
class
person
:
def
__init__
(
self
,
first
,
last
)
:
self.firstnam
=
first
self.lastnam
=
last
def
__str__
(
self
)
:
return
self.firstnam
+
``
``
+
self.lastnam
class
employe
(
person
)
:
def
__init__
(
self
,
first
,
last
,
staffnum
)
:
super
(
)
.__init__
(
first
,
last
)
self.staffnumb
=
staffnum
x
=
person
(
``
marg
''
,
``
simpson
''
)
y
=
employe
(
``
homer
''
,
``
simpson
''
,
``
1007
''
)
print
(
x
)
print
(
y
)
the
output
look
like
thi
:
$
python3
person2.pi
marg
simpson
homer
simpson
first
of
all
,
we
can
see
that
if
we
print
an
instanc
of
the
employe
class
,
the
__str__
method
of
person
is
use
.
thi
is
due
to
inherit
.
the
onli
problem
we
have
now
is
the
fact
that
the
output
of
``
print
(
y
)
''
is
not
the
same
as
the
``
print
(
y.getemploye
(
)
)
''
.
thi
mean
that
our
employe
class
need
it
own
__str__
method
.
We
could
write
it
like
thi
:
def
__str__
(
self
)
:
return
self.firstnam
+
``
``
+
self.lastnam
+
``
,
``
+
self.staffnumb
but
it
is
a
lot
better
to
use
the
__str__
method
of
person
insid
of
the
new
definit
.
thi
way
,
we
can
make
sure
that
the
output
of
the
employe
__str__method
will
automat
chang
,
if
the
__str__
method
from
the
superclass
person
chang
.
We
could
,
for
exampl
,
add
a
new
attribut
age
in
person
:
class
person
:
def
__init__
(
self
,
first
,
last
,
age
)
:
self.firstnam
=
first
self.lastnam
=
last
self.ag
=
age
def
__str__
(
self
)
:
return
self.firstnam
+
``
``
+
self.lastnam
+
``
,
``
+
str
(
self.ag
)
class
employe
(
person
)
:
def
__init__
(
self
,
first
,
last
,
age
,
staffnum
)
:
super
(
)
.__init__
(
first
,
last
,
age
)
self.staffnumb
=
staffnum
def
__str__
(
self
)
:
return
super
(
)
.__str__
(
)
+
``
,
``
+
self.staffnumb
x
=
person
(
``
marg
''
,
``
simpson
''
,
36
)
y
=
employe
(
``
homer
''
,
``
simpson
''
,
28
,
``
1007
''
)
print
(
x
)
print
(
y
)
We
have
overridden
the
method
__str__
from
person
in
employe
.
By
the
way
,
we
have
overridden
__init__
also
.
method
overrid
is
an
object-ori
program
featur
that
allow
a
subclass
to
provid
a
differ
implement
of
a
method
that
is
alreadi
defin
by
it
superclass
or
by
one
of
it
superclass
.
the
implement
in
the
subclass
overrid
the
implement
of
the
superclass
by
provid
a
method
with
the
same
name
,
same
paramet
or
signatur
,
and
same
return
type
as
the
method
of
the
parent
class
.
overwrit
is
not
a
differ
concept
but
usual
a
term
wrongli
use
for
overrid
!
In
the
context
of
object-ori
program
,
you
might
have
heard
about
``
overload
''
as
well
.
overload
is
the
abil
to
defin
the
same
method
,
with
the
same
name
but
with
a
differ
number
of
argument
and
type
.
It
's
the
abil
of
one
function
to
perform
differ
task
,
depend
on
the
number
of
paramet
or
the
type
of
the
paramet
.
let
's
look
first
at
the
case
,
in
which
we
have
the
same
number
of
paramet
but
differ
type
for
the
paramet
.
when
we
defin
a
function
in
python
,
we
do
n't
have
to
and
we
ca
n't
declar
the
type
of
the
paramet
.
So
if
we
defin
the
function
``
successor
''
in
the
follow
exampl
,
we
implicitli
defin
a
famili
of
function
,
i.e
.
a
function
,
which
can
work
on
integ
valu
,
one
which
can
cope
with
float
valu
and
so
.
Of
cours
,
there
are
type
which
will
lead
to
an
error
if
use
:
>
>
>
def
successor
(
number
)
:
...
return
number
+
1
...
>
>
>
successor
(
1
)
2
>
>
>
successor
(
1.6
)
2.6
>
>
>
successor
(
[
3,5,9
]
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
file
``
<
stdin
>
''
,
line
2
,
in
successor
typeerror
:
can
onli
concaten
list
(
not
``
int
''
)
to
list
>
>
>
you
can
skip
the
follow
paragraph
with
the
comparison
with
c++
,
if
you
want
to
.
thi
cours
is
not
about
c++
and
we
have
so
far
avoid
use
ani
c++
code
.
We
want
to
make
an
except
now
,
so
that
you
can
see
,
how
overload
work
in
c++
.
while
we
had
just
one
definit
in
python
,
we
have
two
function
definit
in
c++
,
i.e
.
one
for
the
type
``
int
''
and
one
for
``
doubl
''
:
#
includ
<
iostream
>
#
includ
<
cstdlib
>
use
namespac
std
;
int
successor
(
int
number
)
{
return
number
+
1
;
}
doubl
successor
(
doubl
number
)
{
return
number
+
1
;
}
int
main
(
)
{
cout
<
<
successor
(
10
)
<
<
endl
;
cout
<
<
successor
(
10.3
)
<
<
endl
;
return
0
;
}
have
a
function
with
a
differ
number
of
paramet
is
anoth
way
of
function
overload
.
the
follow
c++
program
show
such
an
exampl
.
the
function
f
can
be
call
with
either
one
or
two
integ
argument
:
#
includ
<
iostream
>
use
namespac
std
;
int
f
(
int
n
)
;
int
f
(
int
n
,
int
m
)
;
int
main
(
)
{
cout
<
<
``
f
(
3
)
:
``
<
<
f
(
3
)
<
<
endl
;
cout
<
<
``
f
(
3
,
4
)
:
``
<
<
f
(
3
,
4
)
<
<
endl
;
return
0
;
}
int
f
(
int
n
)
{
return
n
+
42
;
}
int
f
(
int
n
,
int
m
)
{
return
n
+
m
+
42
;
}
thi
doe
n't
work
in
python
,
as
we
can
see
in
the
follow
exampl
.
the
second
definit
of
f
with
two
paramet
redefin
or
overrid
the
first
definit
with
one
argument
.
overrid
mean
that
the
first
definit
is
not
avail
anymor
.
thi
explain
the
error
messag
:
>
>
>
def
f
(
n
)
:
...
return
n
+
42
...
>
>
>
def
f
(
n
,
m
)
:
...
return
n
+
m
+
42
...
>
>
>
f
(
3,4
)
49
>
>
>
f
(
3
)
traceback
(
most
recent
call
last
)
:
file
``
<
stdin
>
''
,
line
1
,
in
<
modul
>
typeerror
:
f
(
)
take
exactli
2
argument
(
1
given
)
>
>
>
If
we
need
such
a
behaviour
,
we
can
simul
it
with
default
paramet
:
def
f
(
n
,
m=none
)
:
if
m
:
return
n
+
m
+42
els
:
return
n
+
42
the
*
oper
can
be
use
as
a
more
gener
approach
for
a
famili
of
function
with
1
,
2
,
3
,
or
even
more
paramet
:
def
f
(
*x
)
:
if
len
(
x
)
==
1
:
return
x
[
0
]
+
42
els
:
return
x
[
0
]
+
x
[
1
]
+
42
previou
chapter
:
properti
vs.
getter
and
setter
next
chapter
:
multipl
inherit
©
2011
-
2018
,
bernd
klein
,
bodenseo
;
design
by
denis
mitchinson
adapt
for
python-course.eu
by
bernd
klein

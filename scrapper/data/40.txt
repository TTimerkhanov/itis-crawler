Python Tutorial: Count Function calls with the help of a Metaclass Python Course Python 3 Tutorial The Origins of PythonStarting with Python: The Interactive ShellExecuting a ScriptIndentationData Types and VariablesOperatorsSequential Data Types: Lists and StringsList ManipulationsShallow and Deep CopyDictionariesSets and Frozen SetsAn Extensive Example Using Setsinput via the keyboardConditional StatementsLoops, while LoopFor LoopsDifference between interators und IterablesOutput with PrintFormatted output with string modulo and the format methodFunctionsRecursion and Recursive FunctionsParameter Passing in FunctionsNamespacesGlobal and Local VariablesDecoratorsMemoization with DecoratorsRead and Write FilesModular Programming and ModulesPackages in PythonRegular ExpressionsRegular Expressions, AdvancedLambda Operator, Filter, Reduce and MapList ComprehensionIterators and GeneratorsException HandlingTests, DocTests, UnitTestsObject Oriented ProgrammingClass and Instance AttributesProperties vs. getters and settersInheritanceMultiple InheritanceMagic Methods and Operator OverloadingOOP, Inheritance ExampleSlotsClasses and Class CreationRoad to MetaclassesMetaclassesMetaclass Use Case: Count Function CallsAbstract Classes Thou Shalt Count 'And the Lord spake, saying, "First shalt thou take out the Holy Pin. Then, shalt thou count to three. No more. No less. Three shalt be the number thou shalt count, and the number of the counting shall be three. Four shalt thou not count, neither count thou two, excepting that thou then proceed to three. Five is right out. Once at the number three, being the third number to be reached, then, lobbest thou thy Holy Hand Grenade of Antioch towards thy foe, who, being naughty in My sight, shall snuff it."' Excerp from John Cleese, Graham Chapman, Terry Gilliam, Eric Idle, Terry Jones and Michael Palin, Monty Python and the Holy Grail: The Screenplay, page 76, Methuen, 2003 (UK) Profiling Generally, i.e. in non-computer terms, profiling is often known as profiling one or more persons or groups of persons by using personal characteristics or behaviour patterns. In computer science profiling is understood as a dynamic program analysis measuring the behaviour of a program or a software package. This may include, for example, determining the memory used or the time consumed by a program, or which fits perfetly to the topic of our chapter, the frequency or duration of function calls. This website is supported by: Linux and Python Courses and Seminars This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Beispielanwendung für MetaklassenPython 3This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: Count Function calls with the help of a Metaclass in Python 2.x Classroom Training Courses The goal of this website is to provide educational material, allowing you to learn Python on your own. Nevertheless, it is faster and more efficient to attend a "real" Python course in a classroom, with an experienced trainer. So why not attend one of the live Python courses in Strasbourg, Paris, Luxembourg, Amsterdam, Zürich / Zurich, Vienna / Wien, London, Berlin, Munich, Hamburg, Frankfurt, Stuttgart, or Lake Constance by Bernd Klein, the author of this tutorial? You can book on-site classes at your company or organization, e.g. in England, Switzerland, Austria, Germany, France, Belgium, the Netherlands, Luxembourg, Poland, UK, Italy and other locations in Europe and in Canada. We had courses in the following cities: Amsterdam (The Netherlands), Berlin (Germany), Bern (Switzerland), Basel (Switzerland), Zurich (Switzerland), Locarno (Switzerland), Den Haag (The Hague), Hamburg, Toronto (Canada), Edmonton (Canada), Munich (Germany) and many other cities. Contact us so we can define and find the best course curriculum to meet your needs, and schedule course sessions to be held at your location. Skilled Python Programmers You are looking for experienced Python developers or programmers? We can help you, please contact us. Quote of the Day:"I think it is inevitable that people program poorly. Training will not substantially help matters. We have to learn to live with it." (Alan Perlis) Data Protection Declaration Data Protection Declaration Previous Chapter: Metaclasses Next Chapter: Abstract Classes Count Method Calls Using a Metaclass Introduction After you have hopefully gone through our chapter Introduction into Metaclasses you may have asked yourself about possible use cases for metaclasses. There are some interesting use cases and it's not - like some say - a solution waiting for a problem. We have mentioned already some examples. In this chapter of our tutorial on Python, we want to elaborate an example metaclass, which will decorate the methods of the subclass. The decorated function returned by the decorator makes it possible to count the number of times each method of the subclass has been called. This is usually one of the tasks, we expect from a profiler. So we can use this metaclass for simple profiling purposes. Of course, it will be easy to extend our metaclass for further profiling tasks. Preliminary Remarks Before we actually dive into the problem, we want to call to mind again how we can access the attributes of a class. We will demonstrate this with the list class. We can get the list of all the non private attributes of a class - in our example the random class - with the following construct. import random cls = "random" # name of the class as a string all_attributes = [x for x in dir(eval(cls)) if not x.startswith("__") ] print(all_attributes) ['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'Random', 'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_BuiltinMethodType', '_MethodType', '_Sequence', '_Set', '_acos', '_ceil', '_cos', '_e', '_exp', '_inst', '_log', '_pi', '_random', '_sha512', '_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_warn', 'betavariate', 'choice', 'expovariate', 'gammavariate', 'gauss', 'getrandbits', 'getstate', 'lognormvariate', 'normalvariate', 'paretovariate', 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 'weibullvariate'] Now, we are filtering the callable attributes, i.e. the public methods of the class. methods = [x for x in dir(eval(cls)) if not x.startswith("__") and callable(eval(cls + "." + x))] print(methods) ['Random', 'SystemRandom', '_BuiltinMethodType', '_MethodType', '_Sequence', '_Set', '_acos', '_ceil', '_cos', '_exp', '_log', '_sha512', '_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_warn', 'betavariate', 'choice', 'expovariate', 'gammavariate', 'gauss', 'getrandbits', 'getstate', 'lognormvariate', 'normalvariate', 'paretovariate', 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 'weibullvariate'] Getting the non callable attributes of the class can be easily achieved by negating callable, i.e. adding "not": non_callable_attributes = [x for x in dir(eval(cls)) if not x.startswith("__") and not callable(eval(cls + "." + x))] print(non_callable_attributes) ['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'SG_MAGICCONST', 'TWOPI', '_e', '_inst', '_pi', '_random'] In normal Python programming it is neither recommended nor necessary to apply methods in the following way, but it is possible: lst = [3,4] list.__dict__["append"](lst, 42) lst The previous Python code returned the following output: [3, 4, 42] Please note the remark from the Python documentation: "Because dir() is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. For example, metaclass attributes are not in the result list when the argument is a class." A Decorator for Counting Function Calls Finally, we will begin to design the metaclass, which we have mentioned as our target in the beginning of this chapter. It will decorate all the methods of its subclass with a decorator, which counts the number of calls. We have defined such a decorator in our chapter Memoization and Decorators: def call_counter(func): def helper(*args, **kwargs): helper.calls += 1 return func(*args, **kwargs) helper.calls = 0 helper.__name__= func.__name__ return helper We can use it in the usual way: @call_counter def f(): pass print(f.calls) for _ in range(10): f() print(f.calls) 0 10 It better if you call to mind the alternative notation for decorating function. We will need this in our final metaclass: def f(): pass f = call_counter(f) print(f.calls) for _ in range(10): f() print(f.calls) 0 10 The "Count Calls" Metaclass Now we have all the necessary "ingredients" together to write our metaclass. We will include our call_counter decorator as a staticmethod: class FuncCallCounter(type): """ A Metaclass which decorates all the methods of the subclass using call_counter as the decorator """ @staticmethod def call_counter(func): """ Decorator for counting the number of function or method calls to the function or method func """ def helper(*args, **kwargs): helper.calls += 1 return func(*args, **kwargs) helper.calls = 0 helper.__name__= func.__name__ return helper def __new__(cls, clsname, superclasses, attributedict): """ Every method gets decorated with the decorator call_counter, which will do the actual call counting """ for attr in attributedict: if callable(attributedict[attr]) and not attr.startswith("__"): attributedict[attr] = cls.call_counter(attributedict[attr]) return type.__new__(cls, clsname, superclasses, attributedict) class A(metaclass=FuncCallCounter): def foo(self): pass def bar(self): pass if __name__ == "__main__": x = A() print(x.foo.calls, x.bar.calls) x.foo() print(x.foo.calls, x.bar.calls) x.foo() x.bar() print(x.foo.calls, x.bar.calls) 0 0 1 0 2 1 Previous Chapter: Metaclasses Next Chapter: Abstract Classes © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
Numerical & Scientific Computing with Python: Pandas Tutorial: Multi-level Indexing Numerical Python Course Numerical Programming NumPy IntroductionCreate Numpy ArraysData Type Object, dtypeNumerical Operations on Numpy ArraysChanging the Dimensions of ArraysPython, Numpy and ProbabilityWeighted Choices and Weighted SamplesCreation of Synthetical Test DataBoolean Masking of ArraysMatrix ArithmeticReading and Writing ndarraysMatplotlib IntroductionSpines and TicksLegends and AnnotationsMultiple Figures and AxesHistogramsContour PlotsPython Image Processing TutorialImage Processing TechniquesPandas TutorialPandas DataFramesPandas Data FilesDealing with NaNBinning DataPandas Tutorial Continuation: multi-level indexingData Visualization with Pandas and PythonPython, Date and TimePython, Pandas and TimeseriesLinear Combinations Python In Greek mythology, Python is the name of a a huge serpent and sometimes a dragon. Python had been killed by the god Apollo at Delphi. Python was created out of the slime and mud left after the great flood. He was appointed by Gaia (Mother Earth) to guard the oracle of Delphi, known as Pytho. The programming language Python has not been created out of slime and mud but out of the programming language ABC. It has been devised by a Dutch programmer, named Guido van Rossum, in Amsterdam. Origins of Python Guido van Rossum wrote the following about the origins of Python in a foreword for the book "Programming Python" by Mark Lutz in 1996: "Over six years ago, in December 1989, I was looking for a "hobby" programming project that would keep me occupied during the week around Christmas. My office (a government-run research lab in Amsterdam) would be closed, but I had a home computer, and not much else on my hands. I decided to write an interpreter for the new scripting language I had been thinking about lately: a descendant of ABC that would appeal to Unix/C hackers. I chose Python as a working title for the project, being in a slightly irreverent mood (and a big fan of Monty Python's Flying Circus)." This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Pandas Multi-Level-IndizierungClassroom Training Courses This website contains a free and extensive online tutorial by Bernd Klein, using material from his classroom Python training courses. If you are interested in an instructor-led classroom training course, you may have a look at the Python classes by Bernd Klein at Bodenseo. © kabliczech - Fotolia.com Quote of the Day:"Many people tend to look at programming styles and languages like religions: if you belong to one, you cannot belong to others. But this analogy is another fallacy." (Niklaus Wirth) If you have the choice working with Python 2 or Python 3, we recomend to switch to Python 3! You can read our Python Tutorial to see what the differences are. Data Protection Declaration Data Protection Declaration Previous Chapter: Binning Data Next Chapter: Data Visualization with Pandas and Python Pandas Tutorial: Multi-level IndexingIntroduction We learned the basic concepts of Pandas in our previous chapter of our tutorial on Pandas. We introduced the data structures Series and DataFrame We also learned how to create and manipulate the Series and DataFrame objects in numerous Python programs. Now it is time to learn some further aspects of theses data structures in this chapter of our tutorial. We will start with advanced indexing possibilities in Pandas. Advanced or Multi-Level IndexingAdvanced or multi-level indexing is available both for Series and for DataFrames. It is a fascinating way of working with higher dimensional data, using Pandas data structures. It's an efficient way to store and manipulate arbitrarily high dimension data in 1-dimensional (Series) and 2-dimensional tabular (DataFrame) structures. In other words, we can work with higher dimensional data in lower dimensions. It's time to present an example in Python: import pandas as pd cities = ["Vienna", "Vienna", "Vienna", "Hamburg", "Hamburg", "Hamburg", "Berlin", "Berlin", "Berlin", "Zürich", "Zürich", "Zürich"] index = [cities, ["country", "area", "population", "country", "area", "population", "country", "area", "population", "country", "area", "population"]] print(index) [['Vienna', 'Vienna', 'Vienna', 'Hamburg', 'Hamburg', 'Hamburg', 'Berlin', 'Berlin', 'Berlin', 'Zürich', 'Zürich', 'Zürich'], ['country', 'area', 'population', 'country', 'area', 'population', 'country', 'area', 'population', 'country', 'area', 'population']] data = ["Austria", 414.60, 1805681, "Germany", 755.00, 1760433, "Germany", 891.85, 3562166, "Switzerland", 87.88, 378884] city_series = pd.Series(data, index=index) print(city_series) Vienna country Austria area 414.6 population 1805681 Hamburg country Germany area 755 population 1760433 Berlin country Germany area 891.85 population 3562166 Zürich country Switzerland area 87.88 population 378884 dtype: object We can access the data of a city in the following way: print(city_series["Vienna"]) country Austria area 414.6 population 1805681 dtype: object We can also access the information about the country, area or population of a city. We can do this in two ways: print(city_series["Vienna"]["area"]) 414.6 The other way to accomplish it: print(city_series["Vienna", "area"]) 414.6 We can also get the content of multiple cities at the same time by using a list of city names as the key: city_series["Hamburg",:] The previous Python code returned the following: country Germany area 755 population 1760433 dtype: object If the index is sorted, we can also apply a slicing operation: city_series = city_series.sort_index() print("city_series with sorted index:") print(city_series) print("\n\nSlicing the city_series:") city_series["Berlin":"Vienna"] city_series with sorted index: Berlin area 891.85 country Germany population 3562166 Hamburg area 755 country Germany population 1760433 Vienna area 414.6 country Austria population 1805681 Zürich area 87.88 country Switzerland population 378884 dtype: object Slicing the city_series: This gets us the following output: Berlin area 891.85 country Germany population 3562166 Hamburg area 755 country Germany population 1760433 Vienna area 414.6 country Austria population 1805681 dtype: object In the next example, we show that it is possible to access the inner keys as well: print(city_series[:, "area"]) Berlin 891.85 Hamburg 755 Vienna 414.6 Zürich 87.88 dtype: object Swapping MultiIndex LevelsIt is possible to swap the levels of a MultiIndex with the method swaplevel: swaplevel(self, i=-2, j=-1, copy=True) Swap levels i and j in a MultiIndex Parameters ---------- i, j : int, string (can be mixed) Level of index to be swapped. Can pass level name as string. The indexes 'i' and 'j' are optional, and default to the two innermost levels of the index Returns ------- swapped : Series city_series = city_series.swaplevel() city_series.sort_index(inplace=True) city_series This gets us the following output: area Berlin 891.85 Hamburg 755 Vienna 414.6 Zürich 87.88 country Berlin Germany Hamburg Germany Vienna Austria Zürich Switzerland population Berlin 3562166 Hamburg 1760433 Vienna 1805681 Zürich 378884 dtype: object Previous Chapter: Binning Data Next Chapter: Data Visualization with Pandas and Python © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
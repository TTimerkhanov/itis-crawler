Python Tutorial: Dynamically Creating Classes with type Python Course Python 3 Tutorial The Origins of PythonStarting with Python: The Interactive ShellExecuting a ScriptIndentationData Types and VariablesOperatorsSequential Data Types: Lists and StringsList ManipulationsShallow and Deep CopyDictionariesSets and Frozen SetsAn Extensive Example Using Setsinput via the keyboardConditional StatementsLoops, while LoopFor LoopsDifference between interators und IterablesOutput with PrintFormatted output with string modulo and the format methodFunctionsRecursion and Recursive FunctionsParameter Passing in FunctionsNamespacesGlobal and Local VariablesDecoratorsMemoization with DecoratorsRead and Write FilesModular Programming and ModulesPackages in PythonRegular ExpressionsRegular Expressions, AdvancedLambda Operator, Filter, Reduce and MapList ComprehensionIterators and GeneratorsException HandlingTests, DocTests, UnitTestsObject Oriented ProgrammingClass and Instance AttributesProperties vs. getters and settersInheritanceMultiple InheritanceMagic Methods and Operator OverloadingOOP, Inheritance ExampleSlotsClasses and Class CreationRoad to MetaclassesMetaclassesMetaclass Use Case: Count Function CallsAbstract Classes Difference between Classes and Type To put it in a nutshell: There is no difference, but they used to be different, a "long" time ago! Self-Study vs. Live Class Lot's of visitors from our website wonder which method of learning Python may be best: studying entirely on one's own with our online tutorial or other textbooks, i.e. "self-study" live classroom trainings or on-site courses We can't provide a general answer to this question. It depends on the goals of a student. One benefit of self-study is that it is the most economical option in terms of money. Although a live class involves expenses, and often requires travelling to the course's location, there are significant and numerous benefits by attending a course taught by a live lecturer in a classroom setting: First of all, it's a lot faster, because our experience is that participants in one of our courses learn in just 3 or 5 days more than they could have learned in weeks of self-study. Moreover, this learning in a classroom setting is fun to learn. Travelling might not even be necessary, if you book Bernd Klein for an on-site course at your institution or company. This website is supported by: Linux and Python Courses as well as in-house courses This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Dynamische Erzeugung von KlassenPython 3This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: Dynamically Creating Classes with type in Python 2.x Training Classes This website aims at providing you with educational material suitable for self-learning. Nevertheless, it is faster and more efficient to attend a "real" Python course in a classroom, with an experienced trainer. So why not attend one of the live Python courses in Strasbourg, Paris, London, Berlin, Munich, Hamburg, Frankfurt, or Lake Constance by Bernd Klein, the author of this tutorial? In-house Training Courses If you like it, we will come to your company or institute and provide a special training for your employees, as we've done it many times in Amsterdam (The Netherlands), Berlin (Germany), Bern (Switzerland), Basel (Switzerland), Zurich (Switzerland), Frankfurt (Germany), Locarno (Switzerland), Den Haag (The Hague), Hamburg, Munich (Germany), Bucharest (Romania), Toronto (Canada), Edmonton (Canada), and many other cities. We do training courses in England, Switzerland, Liechtenstein, Austria, Germany, France, Belgium, the Netherlands, Luxembourg, Romania, UK, Italy, Spain and other locations in Europe and in Canada. This way you will get a perfect training up to your needs and it will be extremely cost efficient as well. Contact us so we can find the ideal course to meet your needs. Skilled Python Programmers You are looking for experienced Python developers or programmers? We can help you, please contact us. Quote of the Day:Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it. (Alan Perlis) Data Protection Declaration Data Protection Declaration Previous Chapter: Slots Next Chapter: Road to Metaclasses Classes and Class Creation Behind the scenes: Relationship between Class and type In this chapter of our tutorial, we will provide you with a deeper insight into the magic happening behind the scenes, when we are defining a class or creating an instance of a class. You may ask yourself: "Do I really have to learn theses additional details on object oriented programming in Python?" Most probably not, or you belong to the few people who design classes at a very advanced level. First, we will concentrate on the relationship between type and class. When you have defined classes so far, you may have asked yourself, what is happening "behind the lines". We have already seen, that applying "type" to an object returns the class of which the object is an instance of: x = [4, 5, 9] y = "Hello" print(type(x), type(y)) The code above returned the following: <class 'list'> <class 'str'> If you apply type on the name of a class itself, you get the class "type" returned. print(type(list), type(str)) The above Python code returned the following: <class 'type'> <class 'type'> This is similar to applying type on type(x) and type(y): x = [4, 5, 9] y = "Hello" print(type(x), type(y)) print(type(type(x)), type(type(y))) This gets us the following result: <class 'list'> <class 'str'> <class 'type'> <class 'type'> A user-defined class (or the class "object") is an instance of the class "type". So, we can see, that classes are created from type. In Python3 there is no difference between "classes" and "types". They are in most cases used as synonyms. The fact that classes are instances of a class "type" allows us to program metaclasses. We can create classes, which inherit from the class "type". So, a metaclass is a subclass of the class "type". Instead of only one argument, type can be called with three parameters: type(classname, superclasses, attributes_dict) If type is called with three arguments, it will return a new type object. This provides us with a dynamic form of the class statement. "classname" is a string defining the class name and becomes the name attribute; "superclasses" is a list or tuple with the superclasses of our class. This list or tuple will become the bases attribute; the attributes_dict is a dictionary, functioning as the namespace of our class. It contains the definitions for the class body and it becomes the dict attribute. Let's have a look at a simple class definition: class A: pass x = A() print(type(x)) After having executed the Python code above we received the following result: <class '__main__.A'> We can use "type" for the previous class defintion as well: A = type("A", (), {}) x = A() print(type(x)) The previous Python code returned the following result: <class '__main__.A'> Generally speaking, this means, that we can define a class A with type(classname, superclasses, attributedict) When we call "type", the call method of type is called. The call method runs two other methods: new and init: type.__new__(typeclass, classname, superclasses, attributedict) type.__init__(cls, classname, superclasses, attributedict) The new method creates and returns the new class object, and after this the init method initializes the newly created object. class Robot: counter = 0 def __init__(self, name): self.name = name def sayHello(self): return "Hi, I am " + self.name def Rob_init(self, name): self.name = name Robot2 = type("Robot2", (), {"counter":0, "__init__": Rob_init, "sayHello": lambda self: "Hi, I am " + self.name}) x = Robot2("Marvin") print(x.name) print(x.sayHello()) y = Robot("Marvin") print(y.name) print(y.sayHello()) print(x.__dict__) print(y.__dict__) The previous Python code returned the following result: Marvin Hi, I am Marvin Marvin Hi, I am Marvin {'name': 'Marvin'} {'name': 'Marvin'} The class definitions for Robot and Robot2 are syntactically completely different, but they implement logically the same class. What Python actually does in the first example, i.e. the "usual way" of defining classes, is the following: Python processes the complete class statement from class Robot to collect the methods and attributes of Robot to add them to the attributes_dict of the type call. So, Python will call type in a similar or the same way than we did in Robot2. Previous Chapter: Slots Next Chapter: Road to Metaclasses © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
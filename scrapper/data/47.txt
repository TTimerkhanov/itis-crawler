Python Tutorial: Slots, Avoiding Dynamically Created Attributes Python Course Python 3 Tutorial The Origins of PythonStarting with Python: The Interactive ShellExecuting a ScriptIndentationData Types and VariablesOperatorsSequential Data Types: Lists and StringsList ManipulationsShallow and Deep CopyDictionariesSets and Frozen SetsAn Extensive Example Using Setsinput via the keyboardConditional StatementsLoops, while LoopFor LoopsDifference between interators und IterablesOutput with PrintFormatted output with string modulo and the format methodFunctionsRecursion and Recursive FunctionsParameter Passing in FunctionsNamespacesGlobal and Local VariablesDecoratorsMemoization with DecoratorsRead and Write FilesModular Programming and ModulesPackages in PythonRegular ExpressionsRegular Expressions, AdvancedLambda Operator, Filter, Reduce and MapList ComprehensionIterators and GeneratorsException HandlingTests, DocTests, UnitTestsObject Oriented ProgrammingClass and Instance AttributesProperties vs. getters and settersInheritanceMultiple InheritanceMagic Methods and Operator OverloadingOOP, Inheritance ExampleSlotsClasses and Class CreationRoad to MetaclassesMetaclassesMetaclass Use Case: Count Function CallsAbstract Classes Definition of Slots Generally, slots are narrow opening, like a groove or a slit: for example, a slot to input coins in a vending machine or a mail slot. A slot can also be an assigned place in a schedule or a sequence: the time slot for a meeting or a TV program. Slots are known as slot machines as well. In computers the term "slot" is used for expansion slots. An expansion slot is an opening located inside a computer on the motherboard or riser board that allows additional boards to be connected. This website is supported by: Linux and Python Courses and Seminars This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Slots, Vermeidung von dynamisch erzeugten AttributenPython 3This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: Slots, Avoiding Dynamically Created Attributes in Python 2.x Classroom Training Courses The goal of this website is to provide educational material, allowing you to learn Python on your own. Nevertheless, it is faster and more efficient to attend a "real" Python course in a classroom, with an experienced trainer. So why not attend one of the live Python courses in Strasbourg, Paris, Luxembourg, Amsterdam, Zürich / Zurich, Vienna / Wien, London, Berlin, Munich, Hamburg, Frankfurt, Stuttgart, or Lake Constance by Bernd Klein, the author of this tutorial? You can book on-site classes at your company or organization, e.g. in England, Switzerland, Austria, Germany, France, Belgium, the Netherlands, Luxembourg, Poland, UK, Italy and other locations in Europe and in Canada. We had courses in the following cities: Amsterdam (The Netherlands), Berlin (Germany), Bern (Switzerland), Basel (Switzerland), Zurich (Switzerland), Locarno (Switzerland), Den Haag (The Hague), Hamburg, Toronto (Canada), Edmonton (Canada), Munich (Germany) and many other cities. Contact us so we can define and find the best course curriculum to meet your needs, and schedule course sessions to be held at your location. Skilled Python Programmers You are looking for experienced Python developers or programmers? We can help you, please contact us. Quote of the Day:"It scarcely needs mentioning that, when you have a decorator inside a decorator, it's an interior decorator." (Neale Morison) Data Protection Declaration Data Protection Declaration Previous Chapter: OOP, Inheritance Example Next Chapter: Classes and Class Creation Slots Avoiding Dynamically Created Attributes The attributes of objects are stored in a dictionary "__dict__". Like any other dictionary, a dictionary used for attribute storage doesn't have a fixed number of elements. In other words, you can add elements to dictionaries after they have been defined, as we have seen in our chapter on dictionaries. This is the reason, why you can dynamically add attributes to objects of classes that we have created so far: >>> class A(object): ... pass ... >>> a = A() >>> a.x = 66 >>> a.y = "dynamically created attribute" The dictionary containing the attributes of "a" can be accessed like this: >>> a.__dict__ {'y': 'dynamically created attribute', 'x': 66} You might have wondered that you can dynamically add attributes to the classes, we have defined so far, but that you can't do this with built-in classes like 'int', or 'list': >>> x = 42 >>> x.a = "not possible to do it" Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: 'int' object has no attribute 'a' >>> >>> lst = [34, 999, 1001] >>> lst.a = "forget it" Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: 'list' object has no attribute 'a' Using a dictionary for attribute storage is very convenient, but it can mean a waste of space for objects, which have only a small amount of instance variables. The space consumption can become critical when creating large numbers of instances. Slots are a nice way to work around this space consumption problem. Instead of having a dynamic dict that allows adding attributes to objects dynamically, slots provide a static structure which prohibits additions after the creation of an instance. When we design a class, we can use slots to prevent the dynamic creation of attributes. To define slots, you have to define a list with the name __slots__. The list has to contain all the attributes, you want to use. We demonstrate this in the following class, in which the slots list contains only the name for an attribute "val". class S(object): __slots__ = ['val'] def __init__(self, v): self.val = v x = S(42) print(x.val) x.new = "not possible" If we start this program, we can see, that it is not possible to create dynamically a new attribute. We fail to create an attribute "new": 42 Traceback (most recent call last): File "slots_ex.py", line 12, in <module> x.new = "not possible" AttributeError: 'S' object has no attribute 'new' We mentioned in the beginning that slots are preventing a waste of space with objects. Since Python 3.3 this advantage is not as impressive any more. With Python 3.3 Key-Sharing Dictionaries are used for the storage of objects. The attributes of the instances are capable of sharing part of their internal storage between each other, i.e. the part which stores the keys and their corresponding hashes. This helps to reduce the memory consumption of programs, which create many instances of non-builtin types. Previous Chapter: OOP, Inheritance Example Next Chapter: Classes and Class Creation © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
Python Advanced: Fork and Processes Python Advanced Course Topics Advanced Topics Introduction into the sys modulePython and the ShellForks and Forking in PythonIntroduction into ThreadsPipe, Pipes and "99 Bottles of Beer"Python Network ScannerGraph Theory and Graphs in PythonGraphs: PyGraphGraphsA Python Class for Polynomial FunctionsCurrying in PythonFinite State Machine in PythonTuring Machine in PythonLevenshtein DistanceExample for recursive Programming: Towers of HanoiMastermind / Bulls and CowsCreating dynamic websites with WSGIDynamic websites with mod_pythonDynamic websites with PylonsPython, SQL, MySQL and SQLitePython Scores Fork in History Forks were not commonly used in Western Europe until the 10th century. This is amazing, as forks are already mentioned in the Old Testament: "Now it was the practice of the priests that, whenever any of the people offered a sacrifice, the priest's servant would come with a three-pronged fork in his hand while the meat was being boiled 14 and would plunge the fork into the pan or kettle or caldron or pot. Whatever the fork brought up the priest would take for himself." (Samuel 2:13-17) The generally understood defintion of a fork is a piece of cutlery or kitchenware, usually made of metal. A fork is a tool consisting of a handle with several narrow tines on one end. The fork, as an eating utensil, has been used primarily in the West, whereas in East Asia chopsticks have been more prevalent. A fork is used to lift food to the mouth or to hold food in place while cooking or cutting it. Forks are often curved slightly. The American style of etiquette stipulates that a fork is held with tines curving up; while in Europe the fork is held with the tines curving down. The devil's fork is an optical illusion. It provides the impression of an impossible object. It appears to have three cylindrical prongs at one end, which seem to transform into two rectangular prongs at the other end. The devil's fork is also known as a blivet, poiuyt or widget. This website is supported by: Python Training Courses And of course there is this unforgettable sketch about a fork of Monty Python: Man: 	Oh, er by the way - got a bit of a dirty fork, could you ... er.. get me another one? Waiter: 	I beg your pardon. Man: 	Oh it's nothing ... er, I've got a fork a little bit dirty. Could you get me another one? Thank you. Waiter: 	Oh ... sir, I do apologize. Man: 	Oh, no need to apologize, it doesn't worry me. Waiter: 	Oh no, no, no, I do apologize. I will fetch the head waiter immediatement. Man: 	Oh, there's no need to do that! Waiter: 	Oh, no no... I'm sure the head waiter, he will want to apologize to you himself. I will fetch him at once. Lady: 	Well, you certainly get good service here. Man: 	They really look after you... yes. Head Waiter: 	Excuse me monsieur and madame. (examines the fork) It's filthy, Gaston ... find out who washed this up, and give them their cards immediately. Man: 	Oh, no, no. Head Waiter: 	Better still, we can't afford to take any chances, sack the entire washing-up staff. Man: 	No, look I don't want to make any trouble. Head Waiter: 	Oh, no please, no trouble. It's quite right that you should point these kind of things out. Gaston, tell the manager what has happened immediately! (The Waiter runs off) Man: 	Oh, no I don't want to cause any fuss. Head Waiter: 	Please, it's no fuss. I quite simply wish to ensure that nothing interferes with your complete enjoyment of the meal. Man: 	Oh I'm sure it won't, it was only a dirty fork. Head Waiter: 	I know. And I'm sorry, bitterly sorry, but I know that... no apologies I can make can alter the fact that in our restaurant you have been given a dirty, filthy, smelly piece of cutlery... Man: 	It wasn't smelly. This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Fork und ProzesseClassroom Training Courses This website contains a free and extensive online tutorial by Bernd Klein with material from his live Python courses. You can attend one of his courses in Paris, London, Toronto, Berlin, Munich, Hamburg, Amsterdam, Den Haag (The Hague) or Lake Constance / Zurich. It is also possible to book an on-site training course at your company or institute. If you are interested in an instructor-led classroom training course, you may have a look at the Python courses by Bernd Klein at Bodenseo. © kabliczech - Fotolia.com Python Tricks "Python tricks" is a tough one, cuz the language is so clean. E.g., C makes an art of confusing pointers with arrays and strings, which leads to lotsa neat pointer tricks; APL mistakes everything for an array, leading to neat one-liners; and Perl confuses everything period, making each line a joyous adventure . (Tim Peters, Pythoneer who formulated the "Zen of Python") Python compared to Lisp Greenspun's "Tenth Rule of Programming" states: Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp. Sounds complicated? Lisp is complicated. Guido van Rossum compared it - or to be precise Common Lisp and Scheme - to Python with the following words: "These languages are close to Python in their dynamic semantics, but so different in their approach to syntax that a comparison becomes almost a religious argument: is Lisp's lack of syntax an advantage or a disadvantage? It should be noted that Python has introspective capabilities similar to those of Lisp, and Python programs can construct and execute program fragments on the fly. Usually, real-world properties are decisive: Common Lisp is big (in every sense), and the Scheme world is fragmented between many incompatible versions, where Python has a single, free, compact implementation." (excerpt from "Comparing Python to Other Languages" by Guido van Rossum) Wizards and Magic "Things in Python are very clear, but are harder to find than the secrets of wizards. Things in Perl are easy to find, but look like arcane spells to invoke magic." Data Protection Declaration Data Protection Declaration Previous Chapter: Python and the Shell Next Chapter: Introduction into Threads Fork und Prozesse Fork Long before biologists started their research of cloning, computer scientists had a successful history of cloning. They cloned processes, though they didn't call it cloning but forking. Forking is one of the most important aspects of Unix and Linux. When a process forks, it creates a copy of itself. More generally, a fork in a multithreading environment means that a thread of execution is duplicated, creating a child thread from the parent thread. they are identical but can be told apart. The fork operation creates a separate address space for the child. The child process has an exact copy of all the memory of the parent process. The execution of the parent and child process is independent of each other. In computer science the term fork stands for at least two different aspects: The cloning of a process, as roughly described above. In software engineering, a project fork happens when developers take a legal copy of source code from one software package and start independent development on it. This way starting a distinct piece of software. Fork in Python The system function call fork() creates a copy of the process, which has called it. This copy runs as a child process of the calling process. The child process gets the data and the code of the parent process. The child process receives a process number (PID, Process IDentifier) of its own from the operating system. The child process runs as an independent instance, this means independent of a parent process. With the return value of fork() we can decide in which process we are: 0 means that we are in the child process while a positive return value means that we are in the parent process. A negative return value means that an error occurred while trying to fork. To be able to fork processes we need to import the os module in Python. The following Python3 example shows a parent process, which forks every time the user types in a "c", when prompted. Both the child process and the parent process continue after the "if newpid == 0:" statement. The value of newpid is greater than 0 in the parent process and 0 in the child process. The exit statement os.exit(0) of the child function is necessary, because otherwise the child process would return into the parent process, i.e. to the input statement. import os def child(): print('\nA new child ', os.getpid()) os._exit(0) def parent(): while True: newpid = os.fork() if newpid == 0: child() else: pids = (os.getpid(), newpid) print("parent: %d, child: %d\n" % pids) reply = input("q for quit / c for new fork") if reply == 'c': continue else: break parent() Starting independent Processes via fork() So far we have called functions in our examples which are defined in the same script file. Forks are often used to start independent programs. To do this we need the exec*() functions. They execute a new program by replacing the current process by this program. They do not return to the program which has called them. They even receive the same process ID as the calling program. The exec*()-Functions The exec*()-Funktionen are available in various formats: os.execl(path, arg0, arg1, ...) os.execle(path, arg0, arg1, ..., env) os.execlp(file, arg0, arg1, ...) os.execlpe(file, arg0, arg1, ..., env) os.execv(path, args) os.execve(path, args, env) os.execvp(file, args) os.execvpe(file, args, env) We will explain these functions with examples, because they are hardly explained in literature. We will use a bash shell script, which we save under test.sh in the directory /home/monty/bin2 To understand the following examples it's only necessary that the script test.sh is not included in a directory which is included in the PATH (the environment variable $PATH of bash). test.sh has to be executable: chmod 755 test.sh #!/bin/bash script_name=$0 arg1=$1 current=`pwd` echo $script_name, $arg1 echo "XYZ: "$XYZ echo "PATH: "$PATH echo "current directory: $current" The Python script execvp.py, which calls our script test.sh, is saved in a different directory, e.g. /home/monty/python: #!/usr/bin/python import os args = ("test","abc") os.execvp("test.sh", args) As test.sh can't be found in any of the $PATH locations, we get an error message, if we call execvp in a command line: $ ./execvp.py Traceback (most recent call last): File "./execvp.py", line 6, in <module> os.execvp("test.sh", args) File "/usr/lib/python2.6/os.py", line 344, in execvp _execvpe(file, args) File "/usr/lib/python2.6/os.py", line 380, in _execvpe func(fullname, *argrest) OSError: [Errno 2] No such file or directory To prevent this error message, and to achieve that our shell script is called, we extend the PATH environment variable with the directory which contains test.sh, in our case /home/monty/bin2: $ PATH=$PATH:/home/monty/bin2 $ ./execvp.py /home/monty/bin2/test.sh, abc XYZ: PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/bin:/home/monty/bin:/home/monty/bin2 current directory: /home/monty/python Another elegant possibility to extend the search path PATH offers the execvpe()-function. This function has a third parameter which is a dictionary with environment variables. If environment variables already exist, they will be replaced by the corresponding values of this dictionary. If an environment variable doesn't exist, e.g. "XYZ" in the next example, it will be created. import os env = {"PATH":"/home/monty/bin2", "XYZ":"BlaBla"} args = ("test","abc") os.execvpe("test.sh", args, env) If we save this script under the file name execvpe.py, we receive the following output, if we call it: $ ./execvpe.py /home/monty/bin2/test.sh, abc XYZ: BlaBla PATH: /home/monty/bin2/ current directory: /home/monty/python/ $ The value of the shell environment variable $PATH is replaced by the new value of our dictionary. If you want to avoid this, i.e. if you want to new directory to be appended to the existing path "PATH", you have to change the code like this: import os path = os.environ["PATH"] + ":/home/monty/bin2/" env = {"PATH":path, "XYZ":"BlaBla"} os.execlpe("test.sh", "test","abc", env) It's possible to use execlpe() instead of execvpe(), but the code of our Python script has to be changed in the following way: import os env = {"PATH":"/home/monty/bin2/", "XYZ":"BlaBla"} os.execlpe("test.sh", "test","abc", env) Overview of the exec Functions Previous Chapter: Python and the Shell Next Chapter: Introduction into Threads © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
Python Tutorial: Metaclasses Tutorial Python Course Python 3 Tutorial The Origins of PythonStarting with Python: The Interactive ShellExecuting a ScriptIndentationData Types and VariablesOperatorsSequential Data Types: Lists and StringsList ManipulationsShallow and Deep CopyDictionariesSets and Frozen SetsAn Extensive Example Using Setsinput via the keyboardConditional StatementsLoops, while LoopFor LoopsDifference between interators und IterablesOutput with PrintFormatted output with string modulo and the format methodFunctionsRecursion and Recursive FunctionsParameter Passing in FunctionsNamespacesGlobal and Local VariablesDecoratorsMemoization with DecoratorsRead and Write FilesModular Programming and ModulesPackages in PythonRegular ExpressionsRegular Expressions, AdvancedLambda Operator, Filter, Reduce and MapList ComprehensionIterators and GeneratorsException HandlingTests, DocTests, UnitTestsObject Oriented ProgrammingClass and Instance AttributesProperties vs. getters and settersInheritanceMultiple InheritanceMagic Methods and Operator OverloadingOOP, Inheritance ExampleSlotsClasses and Class CreationRoad to MetaclassesMetaclassesMetaclass Use Case: Count Function CallsAbstract Classes Python In Greek mythology, Python is the name of a a huge serpent and sometimes a dragon. Python had been killed by the god Apollo at Delphi. Python was created out of the slime and mud left after the great flood. He was appointed by Gaia (Mother Earth) to guard the oracle of Delphi, known as Pytho. The programming language Python has not been created out of slime and mud but out of the programming language ABC. It has been devised by a Dutch programmer, named Guido van Rossum, in Amsterdam. Origins of Python Guido van Rossum wrote the following about the origins of Python in a foreword for the book "Programming Python" by Mark Lutz in 1996: "Over six years ago, in December 1989, I was looking for a "hobby" programming project that would keep me occupied during the week around Christmas. My office (a government-run research lab in Amsterdam) would be closed, but I had a home computer, and not much else on my hands. I decided to write an interpreter for the new scripting language I had been thinking about lately: a descendant of ABC that would appeal to Unix/C hackers. I chose Python as a working title for the project, being in a slightly irreverent mood (and a big fan of Monty Python's Flying Circus)." This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Metaklassen-TutorialPython 3This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: Metaclasses Tutorial in Python 2.x Classroom Training Courses The goal of this website is to provide educational material, allowing you to learn Python on your own. Nevertheless, it is faster and more efficient to attend a "real" Python course in a classroom, with an experienced trainer. So why not attend one of the live Python courses in Strasbourg, Paris, Luxembourg, Amsterdam, Zürich / Zurich, Vienna / Wien, London, Berlin, Munich, Hamburg, Frankfurt, or Lake Constance by Bernd Klein, the author of this tutorial? Onsite Training Courses Let us come to your company or institute and train your employees, as we've done it many times in Amsterdam (The Netherlands), Berlin (Germany), Bern (Switzerland), Basel (Switzerland), Zurich (Switzerland), Locarno (Switzerland), Den Haag (The Hague), Hamburg (Germany), Frankfurt (Germany), Toronto (Canada), Edmonton (Canada), Munich (Germany), Vienna / Wien (Austria) and many other cities. We do training courses in England, Switzerland, Liechtenstein, Austria, Germany, France, Belgium, the Netherlands, Luxembourg, Poland, UK, Italy and other locations in Europe and in Canada. This way you will get a perfect training up to your needs and it will be extremely cost efficient as well. Contact us so we can define and find the best course curriculum to meet your needs, and schedule course sessions to be held at your location. Skilled Python Programmers You are looking for experienced Python developers or programmers? We can help you, please contact us. Quote of the Day:"How to test?" is a question that cannot be answered in general. "When to test?" however, does have a general answer: as early and as often as possible." (Bjarne Stroustrup) Data Protection Declaration Data Protection Declaration Previous Chapter: Road to Metaclasses Next Chapter: Metaclass Use Case: Count Function Calls Metaclasses A metaclass is a class whose instances are classes. Like an "ordinary" class defines the behavior of the instances of the class, a metaclass defines the behavior of classes and their instances. Metaclasses are not supported by every object oriented programming language. Those programming language, which support metaclasses, considerably vary in way the implement them. Python is supporting them. Some programmers see metaclasses in Python as "solutions waiting or looking for a problem". There are numerous use cases for metaclasses. Just to name a few: logging and profiling interface checking registering classes at creation time automatically adding new methods automatic property creation proxies automatic resource locking/synchronization. Defining Metaclasses Principially, metaclasses are defined like any other Python class, but they are classes that inherit from "type". Another difference is, that a metaclass is called automatically, when the class statement using a metaclass ends. In other words: If no "metaclass" keyword is passed after the base classes (there may be no base classes either) of the class header, type() (i.e. __call__ of type) will be called. If a metaclass keyword is used on the other hand, the class assigned to it will be called instead of type. Now we create a very simple metaclass. It's good for nothing, except that it will print the content of its arguments in the __new__ method and returns the results of the type.__new__ call: class LittleMeta(type): def __new__(cls, clsname, superclasses, attributedict): print("clsname: ", clsname) print("superclasses: ", superclasses) print("attributedict: ", attributedict) return type.__new__(cls, clsname, superclasses, attributedict) We will use the metaclass "LittleMeta" in the following example: class S: pass class A(S, metaclass=LittleMeta): pass a = A() clsname: A superclasses: (<class '__main__.S'>,) attributedict: {'__module__': '__main__', '__qualname__': 'A'} We can see LittleMeta.__new__ has been called and not type.__new__. Resuming our thread from the last chapter: We define a metaclass "EssentialAnswers" which is capable of automatically including our augment_answer method: x = input("Do you need the answer? (y/n): ") if x.lower() == "y": required = True else: required = False def the_answer(self, *args): return 42 class EssentialAnswers(type): def __init__(cls, clsname, superclasses, attributedict): if required: cls.the_answer = the_answer class Philosopher1(metaclass=EssentialAnswers): pass class Philosopher2(metaclass=EssentialAnswers): pass class Philosopher3(metaclass=EssentialAnswers): pass plato = Philosopher1() print(plato.the_answer()) kant = Philosopher2() # let's see what Kant has to say :-) print(kant.the_answer()) Do you need the answer? (y/n): y 42 42 We have learned in our chapter "Type and Class Relationship" that after the class definition has been processed, Python calls type(classname, superclasses, attributes_dict)This is not the case, if a metaclass has been declared in the header. That is what we have done in our previous example. Our classes Philosopher1, Philosopher2 and Philosopher3 have been hooked to the metaclass EssentialAnswers. That's why EssentialAnswer will be called instead of type: EssentialAnswer(classname, superclasses, attributes_dict)To be precise, the arguments of the calls will be set the the following values: EssentialAnswer('Philopsopher1', (), {'__module__': '__main__', '__qualname__': 'Philosopher1'}) The other philosopher classes are treated in an analogue way. Creating Singletons using Metaclasses The singleton pattern is a design pattern that restricts the instantiation of a class to one object. It is used in cases where exactly one object is needed. The conceptcan be generalized to restrict the instantiation to a certain or fixed number of objects. The term stems from mathematics, where a singleton, - also called a unit set -, is used for sets with exactly one element. class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class SingletonClass(metaclass=Singleton): pass class RegularClass(): pass x = SingletonClass() y = SingletonClass() print(x == y) x = RegularClass() y = RegularClass() print(x == y) True False Creating Singletons using MetaclassesAlternatively, we can create Singleton classes by inheriting from a Singleton class, which can be defined like this: class Singleton(object): _instance = None def __new__(cls, *args, **kwargs): if not cls._instance: cls._instance = object.__new__(cls, *args, **kwargs) return cls._instance class SingletonClass(Singleton): pass class RegularClass(): pass x = SingletonClass() y = SingletonClass() print(x == y) x = RegularClass() y = RegularClass() print(x == y) True False Previous Chapter: Road to Metaclasses Next Chapter: Metaclass Use Case: Count Function Calls © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
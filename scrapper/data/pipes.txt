Python Advanced: Pipes in Python Python Advanced Course Topics Advanced Topics Introduction into the sys modulePython and the ShellForks and Forking in PythonIntroduction into ThreadsPipe, Pipes and "99 Bottles of Beer"Python Network ScannerGraph Theory and Graphs in PythonGraphs: PyGraphGraphsA Python Class for Polynomial FunctionsCurrying in PythonFinite State Machine in PythonTuring Machine in PythonLevenshtein DistanceExample for recursive Programming: Towers of HanoiMastermind / Bulls and CowsCreating dynamic websites with WSGIDynamic websites with mod_pythonDynamic websites with PylonsPython, SQL, MySQL and SQLitePython Scores More Pipes A pipe is a hollow cylinder or tube, usually but not necessarily of circular cross-section. Pipes are used to conduct liquids, gas, or other substances which can flow. Smoke can "flow" as well, so we have a device for smokers as well, which is called pipe: It consists of a tube of wood or other material with a small bowl at one of its ends. And then there are all these pipes in music: tubular wind instruments, e.g. flutes or the tubes of an organ. And in Scottland you will find very special pipes, i.e. the bagpipe. This website is supported by: Linux and Python Courses and Seminars This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Pipes in PythonClassroom Training Courses This website contains a free and extensive online tutorial by Bernd Klein with material from his live Python courses. You can attend one of his courses in Paris, London, Toronto, Berlin, Munich, Hamburg, Amsterdam, Den Haag (The Hague) or Lake Constance / Zurich. It is also possible to book an on-site training course at your company or institute. If you are interested in an instructor-led classroom training course, you may have a look at the Python courses by Bernd Klein at Bodenseo. © kabliczech - Fotolia.com Python Tricks "Python tricks" is a tough one, cuz the language is so clean. E.g., C makes an art of confusing pointers with arrays and strings, which leads to lotsa neat pointer tricks; APL mistakes everything for an array, leading to neat one-liners; and Perl confuses everything period, making each line a joyous adventure . (Tim Peters, Pythoneer who formulated the "Zen of Python") Python compared to Lisp Greenspun's "Tenth Rule of Programming" states: Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp. Sounds complicated? Lisp is complicated. Guido van Rossum compared it - or to be precise Common Lisp and Scheme - to Python with the following words: "These languages are close to Python in their dynamic semantics, but so different in their approach to syntax that a comparison becomes almost a religious argument: is Lisp's lack of syntax an advantage or a disadvantage? It should be noted that Python has introspective capabilities similar to those of Lisp, and Python programs can construct and execute program fragments on the fly. Usually, real-world properties are decisive: Common Lisp is big (in every sense), and the Scheme world is fragmented between many incompatible versions, where Python has a single, free, compact implementation." (excerpt from "Comparing Python to Other Languages" by Guido van Rossum) Wizards and Magic "Things in Python are very clear, but are harder to find than the secrets of wizards. Things in Perl are easy to find, but look like arcane spells to invoke magic." Data Protection Declaration Data Protection Declaration Previous Chapter: Introduction into Threads Next Chapter: Python Network Scanner Pipes in Python Pipe Unix or Linux without pipes is unthinkable, or at least, pipelines are a very important part of Unix and Linux applications. Small elements are put together by using pipes. Processes are chained together by their standard streams, i.e. the output of one process is used as the input of another process. To chain processes like this, so-called anonomymous pipes are used. The concept of pipes and pipelines was introduced by Douglas McIlroy, one of the authors of the early command shells, after he noticed that much of the time they were processing the output of one program as the input to another. Ken Thompson added the concept of pipes to the UNIX operating system in 1973. Pipelines have later been ported to other operating systems like DOS, OS/2 and Microsoft Windows as well. Generally there are two kinds of pipes: anonymous pipesand named pipes Anonymous pipes exist solely within processes and are usually used in combination with forks. Beer Pipe in Python "99 Bottles of Beer" is a traditional song in the United States and Canada. The song is derived from the English "Ten Green Bottles". The song consists of 100 verses, which are very similar. Just the number of bottles varies. Only one, i.e. the hundredth verse is slightly different. This song is often sung on long trips, because it is easy to memorize, especially when drunken, and it can take a long time to sing. Here are the lyrics of this song: Ninety-nine bottles of beer on the wall, Ninety-nine bottles of beer. Take one down, pass it around, Ninety-eight bottles of beer on the wall. The next verse is the same starting with 98 bottles of beer. So the general rule is, each verse one bottle less, until there in none left. The song normally ends here. But we want to implement the Aleph-Null (i.e. the infinite) version of this song with an additional verse: No more bottles of beer on the wall, no more bottles of beer. Go to the store and buy some more, Ninety-nine bottles of beer on the wall. This song has been implemented in all conceivable computer languages like "Whitespace" or "Brainfuck". You find the collection at http://99-bottles-of-beer.net We program the Aleph-Null variant of the song with a fork and a pipe: import os def child(pipeout): bottles = 99 while True: bob = "bottles of beer" otw = "on the wall" take1 = "Take one down and pass it around" store = "Go to the store and buy some more" if bottles > 0: values = (bottles, bob, otw, bottles, bob, take1, bottles - 1,bob,otw) verse = "%2d %s %s,\n%2d %s.\n%s,\n%2d %s %s." % values os.write(pipeout, verse) bottles -= 1 else: bottles = 99 values = (bob, otw, bob, store, bottles, bob,otw) verse = "No more %s %s,\nno more %s.\n%s,\n%2d %s %s." % values os.write(pipeout, verse) def parent(): pipein, pipeout = os.pipe() if os.fork() == 0: child(pipeout) else: counter = 1 while True: if counter % 100: verse = os.read(pipein, 117) else: verse = os.read(pipein, 128) print 'verse %d\n%s\n' % (counter, verse) counter += 1 parent() The problem in the code above is that we or better the parent process have to know exactly how many bytes the child will send each time. For the first 99 verses it will be 117 Bytes (verse = os.read(pipein, 117)) and for the Aleph-Null verse it will be 128 bytes (verse = os.read(pipein, 128) We fixed this in the following implementation, in which we read complete lines: import os def child(pipeout): bottles = 99 while True: bob = "bottles of beer" otw = "on the wall" take1 = "Take one down and pass it around" store = "Go to the store and buy some more" if bottles > 0: values = (bottles, bob, otw, bottles, bob, take1, bottles - 1,bob,otw) verse = "%2d %s %s,\n%2d %s.\n%s,\n%2d %s %s.\n" % values os.write(pipeout, verse) bottles -= 1 else: bottles = 99 values = (bob, otw, bob, store, bottles, bob,otw) verse = "No more %s %s,\nno more %s.\n%s,\n%2d %s %s.\n" % values os.write(pipeout, verse) def parent(): pipein, pipeout = os.pipe() if os.fork() == 0: os.close(pipein) child(pipeout) else: os.close(pipeout) counter = 1 pipein = os.fdopen(pipein) while True: print 'verse %d' % (counter) for i in range(4): verse = pipein.readline()[:-1] print '%s' % (verse) counter += 1 print parent() Bidirectional Pipes Now we come to something completely non-alcoholic. It's a simple guessing game, which small children often play. We want to implement this game with bidirectional Pipes. There is an explanation of this game in our tutorial in the chapter about loops. The following diagram explains both the rules of the game and the way we implemented it: The deviser, the one who devises the number, has to imagine a number between a range of 1 to n. The Guesser inputs his guess. The deviser informs the player, if this number is larger, smaller or equal to the secret number, i.e. the number which the deviser has randomly created. Both the deviser and the guesser write their results into log files, i.e. deviser.log and guesser.log respectively. This is the complete implementation: import os, sys, random def deviser(max): fh = open("deviser.log","w") to_be_guessed = int(max * random.random()) + 1 guess = 0 while guess != to_be_guessed: guess = int(raw_input()) fh.write(str(guess) + " ") if guess > 0: if guess > to_be_guessed: print 1 elif guess < to_be_guessed: print -1 else: print 0 sys.stdout.flush() else: break fh.close() def guesser(max): fh = open("guesser.log","w") bottom = 0 top = max fuzzy = 10 res = 1 while res != 0: guess = (bottom + top) / 2 print guess sys.stdout.flush() fh.write(str(guess) + " ") res = int(raw_input()) if res == -1: # number is higher bottom = guess elif res == 1: top = guess elif res == 0: message = "Wanted number is %d" % guess fh.write(message) else: # this case shouldn't occur print "input not correct" fh.write("Something's wrong") n = 100 stdin = sys.stdin.fileno() # usually 0 stdout = sys.stdout.fileno() # usually 1 parentStdin, childStdout = os.pipe() childStdin, parentStdout = os.pipe() pid = os.fork() if pid: # parent process os.close(childStdout) os.close(childStdin) os.dup2(parentStdin, stdin) os.dup2(parentStdout, stdout) deviser(n) else: # child process os.close(parentStdin) os.close(parentStdout) os.dup2(childStdin, stdin) os.dup2(childStdout, stdout) guesser(n) Named Pipes, Fifos Under Unix as well as under Linux it's possible to create Pipes, which are implemented as files. These Pipes are called "named pipes" or sometimes Fifos (First In First Out). A process reads from and writes to such a pipe as if it were a regular file. Sometimes more than one process write to such a pipe but only one process reads from it. The following example illustrates the case, in which one process (child process) writes to the pipe and another process (the parent process) reads from this pipe. import os, time, sys pipe_name = 'pipe_test' def child( ): pipeout = os.open(pipe_name, os.O_WRONLY) counter = 0 while True: time.sleep(1) os.write(pipeout, 'Number %03d\n' % counter) counter = (counter+1) % 5 def parent( ): pipein = open(pipe_name, 'r') while True: line = pipein.readline()[:-1] print 'Parent %d got "%s" at %s' % (os.getpid(), line, time.time( )) if not os.path.exists(pipe_name): os.mkfifo(pipe_name) pid = os.fork() if pid != 0: parent() else: child() Previous Chapter: Introduction into Threads Next Chapter: Python Network Scanner © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
Python Tutorial: Road to Metaclasses Python Course Python 3 Tutorial The Origins of PythonStarting with Python: The Interactive ShellExecuting a ScriptIndentationData Types and VariablesOperatorsSequential Data Types: Lists and StringsList ManipulationsShallow and Deep CopyDictionariesSets and Frozen SetsAn Extensive Example Using Setsinput via the keyboardConditional StatementsLoops, while LoopFor LoopsDifference between interators und IterablesOutput with PrintFormatted output with string modulo and the format methodFunctionsRecursion and Recursive FunctionsParameter Passing in FunctionsNamespacesGlobal and Local VariablesDecoratorsMemoization with DecoratorsRead and Write FilesModular Programming and ModulesPackages in PythonRegular ExpressionsRegular Expressions, AdvancedLambda Operator, Filter, Reduce and MapList ComprehensionIterators and GeneratorsException HandlingTests, DocTests, UnitTestsObject Oriented ProgrammingClass and Instance AttributesProperties vs. getters and settersInheritanceMultiple InheritanceMagic Methods and Operator OverloadingOOP, Inheritance ExampleSlotsClasses and Class CreationRoad to MetaclassesMetaclassesMetaclass Use Case: Count Function CallsAbstract Classes Superclasses vs. Metaclasses Metaclasses shouldn't be withtaken with Superclasses. This website is supported by: Linux and Python Courses as well as in-house courses This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Einführung in MetaklassenPython 3This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: Road to Metaclasses in Python 2.x Training Classes This website aims at providing you with educational material suitable for self-learning. Nevertheless, it is faster and more efficient to attend a "real" Python course in a classroom, with an experienced trainer. So why not attend one of the live Python courses in Strasbourg, Paris, London, Berlin, Munich, Hamburg, Frankfurt, or Lake Constance by Bernd Klein, the author of this tutorial? In-house Training Courses If you like it, we will come to your company or institute and provide a special training for your employees, as we've done it many times in Amsterdam (The Netherlands), Berlin (Germany), Bern (Switzerland), Basel (Switzerland), Zurich (Switzerland), Frankfurt (Germany), Locarno (Switzerland), Den Haag (The Hague), Hamburg, Munich (Germany), Bucharest (Romania), Toronto (Canada), Edmonton (Canada), and many other cities. We do training courses in England, Switzerland, Liechtenstein, Austria, Germany, France, Belgium, the Netherlands, Luxembourg, Romania, UK, Italy, Spain and other locations in Europe and in Canada. This way you will get a perfect training up to your needs and it will be extremely cost efficient as well. Contact us so we can find the ideal course to meet your needs. Skilled Python Programmers You are looking for experienced Python developers or programmers? We can help you, please contact us. Quote of the Day:"Computer science is no more about computers than astronomy is about telescopes." (Edsger Dijkstra) Data Protection Declaration Data Protection Declaration Previous Chapter: Classes and Class Creation Next Chapter: Metaclasses On the Road to MetaclassesMotivation for Metaclasses In this chapter of our tutorial we want to provide some incentives or motivation for the use of metaclasses. To demonstrate some design problems, which can be solved by metaclasses, we will introduce and design a bunch of philosopher classes. Each philosopher class (Philosopher1, Philosopher2, and so on) need the same "set" of methods (in our example just one, i.e. "the_answer") as the basics for his or her pondering and brooding. A stupid way to implement the classes consists in having the same code in every philospher class: class Philosopher1: def the_answer(self, *args): return 42 class Philosopher2: def the_answer(self, *args): return 42 class Philosopher3: def the_answer(self, *args): return 42 plato = Philosopher1() print(plato.the_answer()) kant = Philosopher2() # let's see what Kant has to say :-) print(kant.the_answer()) 42 42 We can see that we have multiple copies of the method "the_answer". This is error prone and tedious to maintain, of course. From what we know so far, the easiest way to accomplish our goal without creating redundant code consists in designing a base, which contains "the_answer" as a method. Each Philosopher class inherits now from this base class: class Answers: def the_answer(self, *args): return 42 class Philosopher1(Answers): pass class Philosopher2(Answers): pass class Philosopher3(Answers): pass plato = Philosopher1() print(plato.the_answer()) kant = Philosopher2() # let's see what Kant has to say :-) print(kant.the_answer()) 42 42 The way we have designed our classes, each Philosopher class will always have a method "the_answer". Let's assume, we don't know a priori if we want or need this method. Let's assume that the decision, if the classes have to be augmented, can only be made at runtime. This decision might depend on configuration files, user input or some calculations. # the following variable would be set as the result of a runtime calculation: x = input("Do you need the answer? (y/n): ") if x=="y": required = True else: required = False def the_answer(self, *args): return 42 class Philosopher1: pass if required: Philosopher1.the_answer = the_answer class Philosopher2: pass if required: Philosopher2.the_answer = the_answer class Philosopher3: pass if required: Philosopher3.the_answer = the_answer plato = Philosopher1() kant = Philosopher2() # let's see what Plato and Kant have to say :-) if required: print(kant.the_answer()) print(plato.the_answer()) else: print("The silence of the philosphers") Do you need the answer? (y/n): y 42 42 Even though this is another solution to our problem, there are still some serious drawbacks. It's error-prone, because we have to add the same code to every class and it seems likely that we might forget it. Besides this it's getting hardly manageable and maybe even confusing, if there are many methods we want to add. We can improve our approach by defining a manager function and avoiding redundant code this way. The manager function will be used to augment the classes conditionally. # the following variable would be set as the result of a runtime calculation: x = input("Do you need the answer? (y/n): ") if x=="y": required = True else: required = False def the_answer(self, *args): return 42 # manager function def augment_answer(cls): if required: cls.the_answer = the_answer class Philosopher1: pass augment_answer(Philosopher1) class Philosopher2: pass augment_answer(Philosopher2) class Philosopher3: pass augment_answer(Philosopher3) plato = Philosopher1() kant = Philosopher2() # let's see what Plato and Kant have to say :-) if required: print(kant.the_answer()) print(plato.the_answer()) else: print("The silence of the philosphers") Do you need the answer? (y/n): y 42 42 This is again useful to solve our problem, but we, i.e. the class designers, must be careful not to forget to call the manager function "augment_answer". The code should be executed automatically. We need a way to make sure that "some" code might be executed automatically after the end of a class definition. # the following variable would be set as the result of a runtime calculation: x = input("Do you need the answer? (y/n): ") if x=="y": required = True else: required = False def the_answer(self, *args): return 42 def augment_answer(cls): if required: cls.the_answer = the_answer # we have to return the class now: return cls @augment_answer class Philosopher1: pass @augment_answer class Philosopher2: pass @augment_answer class Philosopher3: pass plato = Philosopher1() kant = Philosopher2() # let's see what Plato and Kant have to say :-) if required: print(kant.the_answer()) print(plato.the_answer()) else: print("The silence of the philosphers") Do you need the answer? (y/n): y 42 42 Metaclasses can also be used for this purpose as we will learn in the next chapter. Previous Chapter: Classes and Class Creation Next Chapter: Metaclasses © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein
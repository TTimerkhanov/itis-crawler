Python Advanced: Turing Machine in Python Python Advanced Course Topics Advanced Topics Introduction into the sys modulePython and the ShellForks and Forking in PythonIntroduction into ThreadsPipe, Pipes and "99 Bottles of Beer"Python Network ScannerGraph Theory and Graphs in PythonGraphs: PyGraphGraphsA Python Class for Polynomial FunctionsCurrying in PythonFinite State Machine in PythonTuring Machine in PythonLevenshtein DistanceExample for recursive Programming: Towers of HanoiMastermind / Bulls and CowsCreating dynamic websites with WSGIDynamic websites with mod_pythonDynamic websites with PylonsPython, SQL, MySQL and SQLitePython Scores Alan Turing Alan Mathison Turing (23 June 1912 - 7 June 1954) was an English mathematician, logician, cryptanalyst, and computer scientist. He developped the concept of a Turing Machine. "Machine" is misleading, because the Turing machine has never been intended as a practical computing technology. It's a theoretical model of a device that is representing a real computer. A Turing Machine is useful to get to the bottom of "algorithms" and the theory of "computation". It's useful to explore the limits of computations. He is also famous for his "Turing Test". He devised this test to answer the question, when a machine could be called "intelligent". A computer could be said to "think" if a human interrogator could not tell it apart, through conversation, from a human being. This website is created by: Python Training Courses in Toronto, Canada On site trainings in Europe, Canada and the US. This website is free of annoying ads. We want to keep it like this. You can help with your donation: The need for donations Bernd Klein on Facebook Search this website: This topic in German / Deutsche Übersetzung: Turingmaschine in PythonClassroom Training Courses This website contains a free and extensive online tutorial by Bernd Klein, using material from his classroom Python training courses. If you are interested in an instructor-led classroom training course, you may have a look at the Python classes by Bernd Klein at Bodenseo. © kabliczech - Fotolia.com Quote of the Day:"It scarcely needs mentioning that, when you have a decorator inside a decorator, it's an interior decorator." (Neale Morison) If you have the choice working with Python 2 or Python 3, we recomend to switch to Python 3! You can read our Python Tutorial to see what the differences are. Data Protection Declaration Data Protection Declaration Previous Chapter: Finite State Machine in Python Next Chapter: Levenshtein Distance Turing Machine Just to let you know straight-away: The Turing machine is not a machine. It is a mathematical model, which was formulated by the English mathematician Alan Turing in 1936. It's a very simple model of a computer, yet it has the complete computing capability of a general purpose computer. The Turing machine (TM) serves two needs in theoretical computer science: The class of languages defined by a TM, i.e. structured or recursively enumerable languages The class of functions a TM is capable to compute, i.e. the partial recursive functions A Turing machine consists only of a few components: A tape on which data can be sequentially stored. The tape consists of fields, which are sequentially arranged. Each field can contain a character of a finite alphabet. This tape has no limits, it goes on infinitely in both directions. In a real machine, the tape would have to be large enough to contain all the data for the algorithm. A TM also contains a head moving in both directions over the tape. This head can read and write one character from the field over which the head resides. The Turing machine is at every moment in a certain state, one of a finite number of states. A Turing program is a list of transitions, which determine for a given state and character ("under" the head) a new state, a character which has to be written into the field under the head and a movement direction for the head, i.e. either left, right or static (motionless). Formal Definition of a Turing machine A deterministic Turing machine can be defined as a 7-tuple M = (Q, Σ, Γ, δ, b, q0, qf) with Q is a finite, non-empty set of states Γ is a finite, non-empty set of the tape alphabet Σ is the set of input symbols with Σ ⊂ Γ δ is a partially defined function, the transition function: δ : (Q \ {qf}) x Γ → Q x Γ x {L,N,R} b ∈ &Gamma \ Σ is the blank symbol q0 ∈ Q is the initial state qf ∈ Q is the set of accepting or final states Example: Binary Complement function Let's define a Turing machine, which complements a binary input on the tape, i.e. an input "1100111" e.g. will be turned into "0011000". Σ = {0, 1} Q = {init, final} q0 = init qf = final Function Definition Description δ(init,0) = (init, 1, R) If the machine is in state "init" and a 0 is read by the head, a 1 will be written, the state will change to "init" (so actually, it will not change) and the head will be moved one field to the right. δ(init,1) = (init, 0, R) If the machine is in state "init" and a 1 is read by the head, a 0 will be written, the state will change to "init" (so actually, it will not change) and the head will be moved one field to the right. δ(init,b) = (final, b, N) If a blank ("b"), defining the end of the input string, is read, the TM reaches the final state "final" and halts. Implementation of a Turing machine in Python We implement a Turing Machine in Python as a class. We define another class for the read/write tape of the Turing Machine. The core of the tape inside the class Tape is a dictionary, which contains the entries of the tape. This way, we can have negative indices. A Python list is not a convenient data structure, because Python lists are bounded on one side, i.e. bounded by 0. We define the method __str__(self) for the class Tape. __str__(self) is called by the built-in str() function. The print function uses also the str function to calculate the "informal" string representation of an object, in our case the tape of the TM. The method get_tape() of our class TuringMachine makes use of the str representation returned by __str__. With the aid of the method __getitem__(), we provide a reading access to the tape via indices. The definition of the method __setitem__() allows a writing access as well, as we can see e.g. in the statement self.__tape[self.__head_position] = y[1] of our class TuringMachine implementation. The class TuringMachine: We define the method __str__(self), which is called by the str() built-in function and by the print statement to compute the "informal" string representation of an object, in our case the string representation of a tape. class Tape(object): blank_symbol = " " def __init__(self, tape_string = ""): self.__tape = dict((enumerate(tape_string))) # last line is equivalent to the following three lines: #self.__tape = {} #for i in range(len(tape_string)): # self.__tape[i] = input[i] def __str__(self): s = "" min_used_index = min(self.__tape.keys()) max_used_index = max(self.__tape.keys()) for i in range(min_used_index, max_used_index): s += self.__tape[i] return s def __getitem__(self,index): if index in self.__tape: return self.__tape[index] else: return Tape.blank_symbol def __setitem__(self, pos, char): self.__tape[pos] = char class TuringMachine(object): def __init__(self, tape = "", blank_symbol = " ", initial_state = "", final_states = None, transition_function = None): self.__tape = Tape(tape) self.__head_position = 0 self.__blank_symbol = blank_symbol self.__current_state = initial_state if transition_function == None: self.__transition_function = {} else: self.__transition_function = transition_function if final_states == None: self.__final_states = set() else: self.__final_states = set(final_states) def get_tape(self): return str(self.__tape) def step(self): char_under_head = self.__tape[self.__head_position] x = (self.__current_state, char_under_head) if x in self.__transition_function: y = self.__transition_function[x] self.__tape[self.__head_position] = y[1] if y[2] == "R": self.__head_position += 1 elif y[2] == "L": self.__head_position -= 1 self.__current_state = y[0] def final(self): if self.__current_state in self.__final_states: return True else: return False Using the TuringMachine class: from turing_machine import TuringMachine initial_state = "init", accepting_states = ["final"], transition_function = {("init","0"):("init", "1", "R"), ("init","1"):("init", "0", "R"), ("init"," "):("final"," ", "N"), } final_states = {"final"} t = TuringMachine("010011 ", initial_state = "init", final_states = final_states, transition_function=transition_function) print("Input on Tape:\n" + t.get_tape()) while not t.final(): t.step() print("Result of the Turing machine calculation:") print(t.get_tape()) The previous program prints the following results: Input on Tape: 010011 Result of the Turing machine calculation: 101100 Previous Chapter: Finite State Machine in Python Next Chapter: Levenshtein Distance © 2011 - 2018, Bernd Klein, Bodenseo; Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein